#![cfg(test)]

use std::collections::HashMap;
use crate::CollectJoin;
use crate::dfa::TokenId;
use crate::grammar::{LL1, ProdRuleSet, Symbol};
use crate::grammar::tests::build_prs;
use crate::parsergen::ParserBuilder;

#[test]
fn parser_parse_stream() {
    let tests = vec![
        (5, 0, vec![
            ("++;;", true),
            ("--+;;", true),
            ("+-;;", false),
            ("++;;-", false),
            ("++;-", false),
            ("-", false),
        ]),
        (4, 0, vec![
            ("I*I", true),
        ])
    ];
    const VERBOSE: bool = false;
    for (test_id, (ll_id, start, sequences)) in tests.into_iter().enumerate() {
        if VERBOSE { println!("{:=<80}\ntest {test_id} with parser {ll_id}/{start}", ""); }
        let mut ll1 = ProdRuleSet::<LL1>::from(build_prs(ll_id));
        ll1.set_start(start);
        let symbols = (0..ll1.get_num_terminals() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(ll1.get_symbol_table()), s))
            .collect::<HashMap<_, _>>();
        let mut parser = ParserBuilder::from_rules(ll1).make_parser();
        for (input, expected_success) in sequences {
            if VERBOSE { println!("{:-<60}\ninput '{input}'", ""); }
            let mut stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    if let Some(s) = symbols.get(&c_str) {
                        // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                        Some((*s, c_str))
                    } else {
                        panic!("unrecognized test input '{c}' in test {test_id}/{ll_id}/{start}, input {input}");
                    }
                }
            });
            let success = match parser.parse_stream(stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            assert_eq!(success, expected_success, "test {test_id}/{ll_id}/{start} failed for input {input}");
        }
    }
}

mod listener {
    use crate::grammar::tests::build_prs;
    use crate::grammar::VarId;
    use crate::parser::Listener;
    use super::*;

    // Code generated by rparser -------------------------------------

    pub trait ExprListenerTrait {
        fn visit_e(&mut self) {}
        fn visit_t(&mut self) {}
        fn visit_f(&mut self) {}
        fn visit_e_1(&mut self) {}
        fn visit_t_1(&mut self) {}
    }

    struct ListenerWrapper<T>(T);

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T) -> Self {
            Self(listener)
        }

        pub fn listener(self) -> T {
            self.0
        }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, nt: VarId) {
            match nt {
                0 => self.0.visit_e(),
                1 => self.0.visit_t(),
                2 => self.0.visit_f(),
                3 => self.0.visit_e_1(),
                4 => self.0.visit_t_1(),
                _ => panic!("unexpected nt exit value: {nt}")
            }
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        result: Vec<String>,
    }

    impl TestListener {
        pub fn new() -> Self {
            Self { result: Vec::new() }
        }
    }

    impl ExprListenerTrait for TestListener {
        fn visit_e(&mut self) {
            println!("E");
            self.result.push("E".to_string());
        }

        fn visit_t(&mut self) {
            println!("T");
            self.result.push("T".to_string());
        }

        fn visit_f(&mut self) {
            println!("F");
            self.result.push("F".to_string());
        }

        // we're not interested in visit_e_1

        fn visit_t_1(&mut self) {
            println!("T_1");
            self.result.push("T_1".to_string());
        }
    }

    #[test]
    fn parser_parse_stream_hook() {
        let tests = vec![
            (4, 0, vec![
                ("I+N*I", true),
            ])
        ];
        const VERBOSE: bool = true;
        for (test_id, (ll_id, start, sequences)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ntest {test_id} with parser {ll_id}/{start}", ""); }
            let mut ll1 = ProdRuleSet::<LL1>::from(build_prs(ll_id));
            ll1.set_start(start);
            let symbols = (0..ll1.get_num_terminals() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(ll1.get_symbol_table()), s))
                .collect::<HashMap<_, _>>();
            let mut parser = ParserBuilder::from_rules(ll1).make_parser();
            for (input, expected_success) in sequences {
                if VERBOSE { println!("{:-<60}\ninput '{input}'", ""); }
                let mut stream = input.chars().into_iter().filter_map(|c| {
                    if c.is_ascii_whitespace() {
                        None
                    } else {
                        let c_str = c.to_string();
                        if let Some(s) = symbols.get(&c_str) {
                            // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                            Some((*s, c_str))
                        } else {
                            panic!("unrecognized test input '{c}' in test {test_id}/{ll_id}/{start}, input {input}");
                        }
                    }
                });

                // User code -----------------------------------------

                let listener = TestListener::new();
                let mut wrapper = ListenerWrapper::new(listener);
                let success = match parser.parse_stream_hook(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                let listener = wrapper.listener();

                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id}/{ll_id}/{start} failed for input {input}");
                if VERBOSE { println!("listener data: {}", listener.result.join(" -> ")); }
                assert_eq!(listener.result, ["F", "T_1", "T", "F", "F", "T_1", "T_1", "T", "E"])
            }
        }
    }
}