lexicon MicroCalc;

fragment BlockComment   : '/*' .*? '*/';
fragment LineComment    : '//' ~[\r\n]*;

Eq                      : '==';
Ne                      : '!=';
Lt                      : '<';
Gt                      : '>';
Le                      : '<=';
Ge                      : '>=';
Not                     : '!';

Add                     : '+';
Comma                   : ',';
Div                     : '/';
Equal                   : '=';
Exp                     : '^';
Mul                     : '*';
Lbracket                : '{';
Lpar                    : '(';
Rbracket                : '}';
Rpar                    : ')';
Semi                    : ';';
Sub                     : '-';

Def                     : 'def';
Else                    : 'else';
If                      : 'if';
Let                     : 'let';
Print                   : 'print';
Return                  : 'return';
While                   : 'while';

SComment                : BlockComment              -> skip;
SLineComment            : LineComment               -> skip;
SWhiteSpace             : [ \n\r\t]+                -> skip;

Id                      : [a-zA-Z][a-zA-Z_0-9]*;

fragment BinDigit       : [0-1];
fragment DecDigit       : [0-9];
fragment HexDigit       : DecDigit | 'A'..'F' | 'a'..'f';
fragment NZHexDigit     : DecDigit | 'A'..'F' | 'a'..'f';
fragment BinInteger     : BinDigit ( '_' | BinDigit)*;
fragment DecInteger     : DecDigit ( '_' | DecDigit)*;
fragment HexInteger     : HexDigit ( '_' | HexDigit)*;

Num                     : '0b' BinInteger | '0x' HexInteger | DecInteger;

grammar MicroCalc;

program:
    function+
;

function:
    Def Id Lpar fun_params Rpar instruction
;

fun_params:
    Id (Comma Id)*
|
;

block:
    Lbracket instruction* Rbracket
;

instruction:
    Let Id Equal expr Semi
|   Id Equal expr Semi
|   Return expr Semi
|   Print expr Semi
|   Id Lpar fun_args Rpar Semi
|   If expr instruction (<G> Else instruction)?
|   While expr block
|   block
;

expr:
    Sub expr
|   expr <R> Exp expr
|   expr (Mul | <P> Div) expr
|   expr (Add | <P> Sub) expr
|   Not expr
|   expr (Eq | <P> Ne | <P> Lt | <P> Gt | <P> Le | <P> Ge) expr
|   Lpar expr Rpar
|   Id Lpar fun_args Rpar
|   Id
|   Num
;

fun_args:
    expr (Comma expr)*
|
;
