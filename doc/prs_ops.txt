================================================================================
Simple rules
--------------------------------------------------------------------------------
PRS(9): A -> a B c
        B -> b | d

//  factors       | opcodes     | items
//  --------------+-------------+-------
//  0: A -> a B c | ◄0 c! ►B a! | a B c
//  1: B -> b     | ◄1 b!       | b
//  2: B -> d     | ◄2 d!       | d

    pub enum CtxA {
        A { a: String, b: SynB, c: String },    /// `A -> a B c`
    }
    pub enum CtxB {
        B1 { b: String },                       /// `B -> b`
        B2 { d: String },                       /// `B -> d`
    }

    pub trait TestListener {
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_a(),    // A
                1 => self.listener.init_b(),    // B
            }
        }
        Call::Exit => {
            match factor_id {
                0 => self.exit_a(),             // A -> a B c
                1 |                             // B -> b
                2 => self.exit_b(factor_id),    // B -> d
            }
        }
        Call::End => {
            self.exit();
        }
    }

    fn exit(&mut self) {
        let a = self.stack.pop().unwrap().get_a();
        self.listener.exit(a);
    }

    fn exit_a(&mut self) {
        let c = self.stack_t.pop().unwrap();
        let b = self.stack.pop().unwrap().get_b();
        let a = self.stack_t.pop().unwrap();
        let val = self.listener.exit_a(CtxA::A { a, b, c });
        self.stack.push(SynValue::A(val));
    }

    fn exit_b(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            1 => {
                let b = self.stack_t.pop().unwrap();
                CtxB::B1 { b }
            }
            2 => {
                let d = self.stack_t.pop().unwrap();
                CtxB::B2 { d }
            }
        };
        let val = self.listener.exit_b(ctx);
        self.stack.push(SynValue::B(val));
    }
================================================================================
Repetitions + and *
--------------------------------------------------------------------------------
RTS(21): A -> a (b)* c

// NT flags:
//  - A: parent_+_or_* (2048)
//  - A_1: child_+_or_* (1)
// parents:
//  - A_1 -> A

//  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
//  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | A_1 b
//  2: A_1 -> ε     | ◄2            |

    pub enum CtxA {
        A { a: String, star: SynA1, c: String },    /// `A -> a [b]* c`
    }

    pub struct SynA1(pub Vec<String>);

    pub trait TestListener {
        // ...
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_a(),    // A
                1 => self.init_a1(),            // A_1
            }
        }
        Call::Exit => {
            match factor_id {
                0 => self.exit_a(),             // A -> a [b]* c
                1 => self.exit_a1(),            // [b]* item in A -> a  ► [b]* ◄  c
                2 => {}                         // end of [b]* items in A -> a  ► [b]* ◄  c
            }
        }

    fn exit_a(&mut self) {
        let c = self.stack_t.pop().unwrap();
        let star = self.stack.pop().unwrap().get_a1();
        let a = self.stack_t.pop().unwrap();
        let val = self.listener.exit_a(CtxA::A { a, star, c });
        self.stack.push(SynValue::A(val));
    }

    fn init_a1(&mut self) {
        let val = SynA1(Vec::new());
        self.stack.push(SynValue::A1(val));
    }

    fn exit_a1(&mut self) {
        let b = self.stack_t.pop().unwrap();
        let mut star_it = self.stack.pop().unwrap().get_a1();
        star_it.0.push(b);
        self.stack.push(SynValue::A1(star_it));
    }
--------------------------------------------------------------------------------
RTS(22): A -> a (b <L=AIter1>)* c

// NT flags:
//  - A: parent_+_or_* (2048)
//  - AIter1: child_+_or_* | L-form (129)
// parents:
//  - AIter1 -> A

//  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
//  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b!    | AIter1 b
//  2: AIter1 -> ε        | ◄2               | AIter1

    pub enum CtxA {
        A { a: String, star: SynAIter, c: String },  /// `A -> a (b <L>)* c`
    }
    pub enum CtxAiter1 {
        Aiter1_1 { star_it: SynAIter, b: String },   /// `(b <L>)*` it. in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },              /// end of `(b <L>)*` it. in `A -> a  ► (b <L>)* ◄  c`
    }

    pub trait TestListener {
        // ...
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_a(),         // A
                1 => self.init_aiter1(),             // AIter1
            }
        }
        Call::Exit => {
            match factor_id {
                0 => self.exit_a(),                  // A -> a (b <L>)* c
                1 |                                  // (b <L>)* it. in A -> a  ► (b <L>)* ◄  c
                2 => self.exit_aiter1(factor_id),    // end of (b <L>)* it. in A -> a  ► (b <L>)* ◄  c
            }
        }

    fn exit_a(&mut self) {
        let c = self.stack_t.pop().unwrap();
        let star = self.stack.pop().unwrap().get_aiter1();
        let a = self.stack_t.pop().unwrap();
        let val = self.listener.exit_a(CtxA::A { a, star, c });
        self.stack.push(SynValue::A(val));
    }

    fn init_aiter1(&mut self) {
        let val = self.listener.init_aiter1();
        self.stack.push(SynValue::Aiter1(val));
    }

    fn exit_aiter1(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            1 => {
                let b = self.stack_t.pop().unwrap();
                let star_it = self.stack.pop().unwrap().get_aiter1();
                CtxAiter1::Aiter1_1 { star_it, b }
            }
            2 => {
                let star_it = self.stack.pop().unwrap().get_aiter1();
                CtxAiter1::Aiter1_2 { star_it }
            }
        };
        let val = self.listener.exit_aiter1(ctx);
        self.stack.push(SynValue::Aiter1(val));
    }
--------------------------------------------------------------------------------
RTS(23): A -> a (b)+ c

// NT flags:
//  - A: parent_+_or_* | plus (6144)
//  - A_1: child_+_or_* | parent_left_fact | plus (4129)
//  - A_2: child_left_fact (64)
// parents:
//  - A_1 -> A
//  - A_2 -> A_1

//  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
//  1: A_1 -> b A_2 | ►A_2 b!       |
//  2: A_2 -> A_1   | ●A_1 ◄2       | A_1 b
//  3: A_2 -> ε     | ◄3            | A_1 b

    pub enum CtxA {
        A { a: String, plus: SynA1, c: String },    /// `A -> a [b]+ c`
    }

... similar to A -> a (b)* c
================================================================================
Left factorization
--------------------------------------------------------------------------------
PRS(28): A -> a | a b | a b c | a b d | e

// NT flags:
//  - A: parent_left_fact (32)
//  - A_1: parent_left_fact | child_left_fact (96)
//  - A_2: child_left_fact (64)
// parents:
//  - A_1 -> A
//  - A_2 -> A_1

//  0: A -> a A_1   | ►A_1 a! |
//  1: A -> e       | ◄1 e!   | e
//  2: A_1 -> b A_2 | ►A_2 b! |
//  3: A_1 -> ε     | ◄3      | a
//  4: A_2 -> c     | ◄4 c!   | a b c
//  5: A_2 -> d     | ◄5 d!   | a b d
//  6: A_2 -> ε     | ◄6      | a b

    pub enum CtxA {
        A1 { e: String },                       /// `A -> e`
        A2 { a: String },                       /// `A -> a`
        A3 { a: String, b: String, c: String }, /// `A -> a b c`
        A4 { a: String, b: String, d: String }, /// `A -> a b d`
        A5 { a: String, b: String },            /// `A -> a b`
    }

    pub trait TestListener {
        // ...
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_a(),    // A
                1 => {}                         // A_1
                2 => {}                         // A_2
            }
        }
        Call::Exit => {
            match factor_id {
                1 |                             // A -> e
                3 |                             // A -> a
                4 |                             // A -> a b c
                5 |                             // A -> a b d
                6 => self.exit_a(factor_id),    // A -> a b
             /* 0 */                            // A -> a | a b | a b c | a b d (never called)
             /* 2 */                            // A -> a b | a b c | a b d (never called)
            }
        }

    fn exit_a(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            1 => {
                let e = self.stack_t.pop().unwrap();
                CtxA::A1 { e }
            }
            3 => {
                let a = self.stack_t.pop().unwrap();
                CtxA::A2 { a }
            }
            4 => {
                let c = self.stack_t.pop().unwrap();
                let b = self.stack_t.pop().unwrap();
                let a = self.stack_t.pop().unwrap();
                CtxA::A3 { a, b, c }
            }
            5 => {
                let d = self.stack_t.pop().unwrap();
                let b = self.stack_t.pop().unwrap();
                let a = self.stack_t.pop().unwrap();
                CtxA::A4 { a, b, d }
            }
            6 => {
                let b = self.stack_t.pop().unwrap();
                let a = self.stack_t.pop().unwrap();
                CtxA::A5 { a, b }
            }
            _ => panic!("unexpected factor id {factor_id} in fn exit_a")
        };
        let val = self.listener.exit_a(ctx);
        self.stack.push(SynValue::A(val));
    }
================================================================================
Left recursion
--------------------------------------------------------------------------------
PRS(31): E -> F | E . id
         F -> id

// NT flags:
//  - E: parent_left_rec (512)
//  - E_1: child_left_rec (4)
// parents:
//  - E_1 -> E

//  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
//  1: F -> id         | ◄1 id!        | id
//  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | E id
//  3: E_1 -> ε        | ◄3            | E

    pub enum CtxE {
        E1 { f: SynF },                 /// `E -> F`
        E2 { e: SynE, id: String },     /// `E -> E . id`
        E3 { e: SynE },                 /// end of iterations in E -> E . id
    }
    #[derive(Debug)]
    pub enum CtxF {
        F { id: String },               /// `F -> id`
    }

    pub trait TestListener {
        // ...
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_e(),    // E
                2 => {}                         // E_1
                1 => self.listener.init_f(),    // F
            }
        }
        Call::Exit => {
            match factor_id {
                0 => self.inter_e(),            // E -> F
                2 |                             // E -> E . id
                3 => self.exit_e1(factor_id),   // end of iterations in E -> E . id
                1 => self.exit_f(),             // F -> id
            }
        }

    fn inter_e(&mut self) {
        let f = self.stack.pop().unwrap().get_f();
        let val = self.listener.exit_e(CtxE::E1 { f });
        self.stack.push(SynValue::E(val));
    }

    fn exit_e1(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            2 => {
                let id = self.stack_t.pop().unwrap();
                let e = self.stack.pop().unwrap().get_e();
                CtxE::E2 { e, id }
            }
            3 => {
                let e = self.stack.pop().unwrap().get_e();
                CtxE::E3 { e }
            }
            _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
        };
        let val = self.listener.exit_e(ctx);
        self.stack.push(SynValue::E(val));
    }

    fn exit_f(&mut self) {
        let id = self.stack_t.pop().unwrap();
        let val = self.listener.exit_f(CtxF::F { id });
        self.stack.push(SynValue::F(val));
    }
================================================================================
Right recursion
--------------------------------------------------------------------------------
PRS(45): A -> a A | B
         B -> b

// NT flags:
//  - A: right_rec (2)
// parents:
//  - (nothing)

//  0: A -> a A | ◄0 ►A a! | a A
//  1: A -> B   | ◄1 ►B    | B
//  2: B -> b   | ◄2 b!    | b

    pub enum CtxA {
        A1 { a: String, a1: SynA },     /// `A -> a A`
        A2 { b: SynB },                 /// `A -> B`
    }
    pub enum CtxB {
        B { b: String },                /// `B -> b`
    }

    pub trait TestListener {
        // ...
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.listener.init_a(),    // A
                1 => self.listener.init_b(),    // B
            }
        }
        Call::Exit => {
            match factor_id {
                0 |                             // A -> a A
                1 => self.exit_a(factor_id),    // A -> B
                2 => self.exit_b(),             // B -> b
            }
        }

    fn exit_a(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            0 => {
                let a1 = self.stack.pop().unwrap().get_a();
                let a = self.stack_t.pop().unwrap();
                CtxA::A1 { a, a1 }
            }
            1 => {
                let b = self.stack.pop().unwrap().get_b();
                CtxA::A2 { b }
            }
            _ => panic!("unexpected factor id {factor_id} in fn exit_a")
        };
        let val = self.listener.exit_a(ctx);
        self.stack.push(SynValue::A(val));
    }

    fn exit_b(&mut self) {
        let b = self.stack_t.pop().unwrap();
        let val = self.listener.exit_b(CtxB::B { b });
        self.stack.push(SynValue::B(val));
    }
--------------------------------------------------------------------------------
PRS(48): A -> a A <L> | B
         B -> b

// NT flags:
//  - A: right_rec | L-form (130)
// parents:
//  - (nothing)

//  0: A -> a A | ●A ◄0 a! | A a
//  1: A -> B   | ◄1 ►B    | A B
//  2: B -> b   | ◄2 b!    | b

    pub enum CtxA {
        A1 { a: SynA, a1: String },     /// `A -> a A <L>`
        A2 { a: SynA, b: SynB },        /// `A -> B <L>`
    }
    pub enum CtxB {
        B { b: String },                /// `B -> b`
    }

    pub trait TestListener {
        // ...
        fn init_a(&mut self) -> SynA;
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    match call {
        Call::Enter => {
            match nt {
                0 => self.init_a(),             // A
                1 => self.listener.init_b(),    // B
            }
        }
        Call::Exit => {
            match factor_id {
                0 |                             // A -> a A <L>
                1 => self.exit_a(factor_id),    // A -> B <L>
                2 => self.exit_b(),             // B -> b
            }
        }

    fn init_a(&mut self) {
        let val = self.listener.init_a();
        self.stack.push(SynValue::A(val));
    }

    fn exit_a(&mut self, factor_id: FactorId) {
        let ctx = match factor_id {
            0 => {
                let a1 = self.stack_t.pop().unwrap();
                let a = self.stack.pop().unwrap().get_a();
                CtxA::A1 { a, a1 }
            }
            1 => {
                let b = self.stack.pop().unwrap().get_b();
                let a = self.stack.pop().unwrap().get_a();
                CtxA::A2 { a, b }
            }
            _ => panic!("unexpected factor id {factor_id} in fn exit_a")
        };
        let val = self.listener.exit_a(ctx);
        self.stack.push(SynValue::A(val));
    }

    fn exit_b(&mut self) {
        let b = self.stack_t.pop().unwrap();
        let val = self.listener.exit_b(CtxB::B { b });
        self.stack.push(SynValue::B(val));
    }
================================================================================
Ambiguous rules (binary recursion)
--------------------------------------------------------------------------------

old PRS(63):
        // E -> <R> E ^ E | E * E | - E | E + E | ID;
        // expanded with Clarke's method (produces ambiguities in the table):
        // E -> E ^ E5 | E * E5 | E + E3 | E6
        // E3 -> E3 ^ E5 | E3 * E5 | E6
        // E5 -> E6 ^ E5 | E6
        // E6 -> - E3 | ID
        // NT flags:
        //  - E: parent_left_rec (512)
        //  - E3: parent_left_rec (512)
        //  - E5: right_rec | parent_left_fact (34)
        //  - E_1: child_left_rec (4)
        //  - E3_1: child_left_rec (4)
        //  - E5_1: child_left_fact (64)
        // parents:
        //  - E_1 -> E
        //  - E3_1 -> E3
        //  - E5_1 -> E5
        (PRS(63), true, 0, btreemap![
            0 => "SynE".to_string(),
            1 => "SynE3".to_string(),
            2 => "SynE5".to_string(),
            3 => "SynE6".to_string(),
        ], btreemap![
            0 => symbols![nt 3],                    //  0: E -> E6 E_1       | ►E_1 ◄0 ►E6     | E6
            1 => symbols![nt 3],                    //  1: E3 -> E6 E3_1     | ►E3_1 ◄1 ►E6    | E6
            2 => symbols![],                        //  2: E5 -> E6 E5_1     | ►E5_1 ►E6       |
            3 => symbols![nt 1],                    //  3: E6 -> - E3        | ◄3 ►E3 -        | E3
            4 => symbols![t 4],                     //  4: E6 -> ID          | ◄4 ID!          | ID
            5 => symbols![nt 0, nt 2],              //  5: E_1 -> ^ E5 E_1   | ●E_1 ◄5 ►E5 ^   | E E5
            6 => symbols![nt 0, nt 2],              //  6: E_1 -> * E5 E_1   | ●E_1 ◄6 ►E5 *   | E E5
            7 => symbols![nt 0, nt 1],              //  7: E_1 -> + E3 E_1   | ●E_1 ◄7 ►E3 +   | E E3
            8 => symbols![nt 0],                    //  8: E_1 -> ε          | ◄8              | E
            9 => symbols![nt 1, nt 2],              //  9: E3_1 -> ^ E5 E3_1 | ●E3_1 ◄9 ►E5 ^  | E3 E5
            10 => symbols![nt 1, nt 2],             // 10: E3_1 -> * E5 E3_1 | ●E3_1 ◄10 ►E5 * | E3 E5
            11 => symbols![nt 1],                   // 11: E3_1 -> ε         | ◄11             | E3
            12 => symbols![nt 3, nt 2],             // 12: E5_1 -> ^ E5      | ◄12 ►E5 ^       | E6 E5
            13 => symbols![nt 3],                   // 13: E5_1 -> ε         | ◄13             | E6
        ], Default, btreemap![0 => vec![0], 1 => vec![1], 2 => vec![12, 13], 3 => vec![3, 4]]),

old PRS(65):
        // E -> <R> E ^ E | <R> E * E | - E | E + E | ID;
        // expanded with Clarke's method (produces ambiguities in the table):
        // E   -> E5 Eb
        // Eb  -> ^ E4 Eb | * E3 Eb | + E3 Eb | ε
        // E3  -> E5 E3b
        // E3b -> ^ E4 E3b | * E3 E3b | ε
        // E4  -> E5 E4b
        // E4b -> ^ E4 | ε
        // E5  -> - E3 | ID
        // NT flags:
        //  - E: parent_left_rec (512)
        //  - Eb: child_left_rec (4)
        //  - E3: parent_left_rec (512)
        //  - E3b: child_left_rec (4)
        //  - E4: right_rec | parent_left_fact (34)
        //  - E4b: child_left_fact (64)
        //  - E5: right_rec (2)
        // parents:
        //  - Eb -> E
        //  - E3b -> E3
        //  - E4b -> E4
        (PRS(65), true, 0, btreemap![
            0 => "SynE".to_string(),
            2 => "SynE3".to_string(),
            4 => "SynE4".to_string(),
            6 => "SynE5".to_string(),
        ], btreemap![
            0 => symbols![nt 6],                    //  0: E -> E5 Eb      | ►Eb ◄0 ►E5    | E5
            1 => symbols![nt 0, nt 4],              //  1: Eb -> ^ E4 Eb   | ●Eb ◄1 ►E4 ^  | E E4
            2 => symbols![nt 0, nt 2],              //  2: Eb -> * E3 Eb   | ●Eb ◄2 ►E3 *  | E E3
            3 => symbols![nt 0, nt 2],              //  3: Eb -> + E3 Eb   | ●Eb ◄3 ►E3 +  | E E3
            4 => symbols![nt 0],                    //  4: Eb -> ε         | ◄4            | E
            5 => symbols![nt 6],                    //  5: E3 -> E5 E3b    | ►E3b ◄5 ►E5   | E5
            6 => symbols![nt 2, nt 4],              //  6: E3b -> ^ E4 E3b | ●E3b ◄6 ►E4 ^ | E3 E4
            7 => symbols![nt 2, nt 2],              //  7: E3b -> * E3 E3b | ●E3b ◄7 ►E3 * | E3 E3
            8 => symbols![nt 2],                    //  8: E3b -> ε        | ◄8            | E3
            9 => symbols![],                        //  9: E4 -> E5 E4b    | ►E4b ►E5      |
            10 => symbols![nt 6, nt 4],             // 10: E4b -> ^ E4     | ◄10 ►E4 ^     | E5 E4
            11 => symbols![nt 6],                   // 11: E4b -> ε        | ◄11           | E5
            12 => symbols![nt 2],                   // 12: E5 -> - E3      | ◄12 ►E3 -     | E3
            13 => symbols![t 4],                    // 13: E5 -> ID        | ◄13 ID!       | ID
        ], Default, btreemap![0 => vec![0], 2 => vec![5], 4 => vec![10, 11], 6 => vec![12, 13]]),
