// Copyright (c) 2025 Redglyph (@gmail.com). All Rights Reserved.

#![cfg(test)]

// tests files generated by print_source_code(&lexergen)
mod lexer_source1 {
    use std::collections::HashMap;
    use std::io::{Cursor, Read};
    use crate::lexer::ModeOption;
    use crate::{escape_string, TokenId};
    use crate::char_reader::CharReader;
    use crate::segmap::GroupId;
    use crate::segmap::{Seg, SegMap};
    use crate::lexer::{Lexer, StateId, Terminal};

    // -------------------------------------------------------------------------
    // Copied from a print_source_code(&lexergen)

    const NBR_GROUPS: u32 = 5;
    const INITIAL_STATE: StateId = 0;
    const FIRST_END_STATE: StateId = 4;
    const NBR_STATES: StateId = 9;
    const ASCII_TO_GROUP: [GroupId; 128] = [
          5,   5,   5,   5,   5,   5,   5,   5,   5,   0,   0,   5,   5,   0,   5,   5,   // 0-15
          5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   // 16-31
          0,   5,   5,   5,   5,   5,   5,   5,   5,   5,   3,   5,   5,   5,   5,   1,   // 32-47
          2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   5,   5,   5,   5,   5,   5,   // 48-63
          5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   // 64-79
          5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   // 80-95
          5,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   // 96-111
          4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   4,   5,   5,   5,   5,   5,   // 112-127
    ];
    const UTF8_TO_GROUP: [(char, GroupId); 0] = [];
    // const UTF8_TO_GROUP: [(char, GroupId); 3] = [('Œî', 4),('‚àë', 5),('ùÜï', 2),];
    const SEG_TO_GROUP: [(Seg, GroupId); 0] = [];
    // const SEG_TO_GROUP: [(Seg, GroupId); 8] = [
    //     (Seg(256, 915), 6),
    //     (Seg(916, 916), 4),
    //     (Seg(917, 8720), 6),
    //     (Seg(8721, 8721), 5),
    //     (Seg(8722, 55295), 6),
    //     (Seg(57344, 119188), 6),
    //     (Seg(119189, 119189), 2),
    //     (Seg(119190, 1114111), 6),];
    const TERMINAL_TABLE: [Terminal;5] = [
        Terminal { action: crate::lexer::ActionOption::Skip,     channel: 0, mode: ModeOption::None, mode_state: None, pop: false },
        Terminal { action: crate::lexer::ActionOption::Token(0), channel: 0, mode: ModeOption::None, mode_state: None, pop: false },
        Terminal { action: crate::lexer::ActionOption::Skip,     channel: 0, mode: ModeOption::Push(1), mode_state: Some(2), pop: false },
        Terminal { action: crate::lexer::ActionOption::Skip,     channel: 0, mode: ModeOption::None, mode_state: None, pop: false },
        Terminal { action: crate::lexer::ActionOption::Skip,     channel: 0, mode: ModeOption::None, mode_state: None, pop: true }];
    const STATE_TABLE: [StateId; 45] = [
          4,   1,   5,   9,   9, // state 0
          9,   9,   9,   6,   9, // state 1
          7,   9,   9,   3,   7, // state 2
          9,   8,   9,   9,   9, // state 3
          4,   9,   9,   9,   9, // state 4 <skip>
          9,   9,   5,   9,   9, // state 5 <end:0>
          9,   9,   9,   9,   9, // state 6 <skip,push(mode 1,state 2)>
          7,   9,   9,   9,   7, // state 7 <skip>
          9,   9,   9,   9,   9, // state 8 <skip,pop>
    ];

    fn build_lexer<R: Read>() -> Lexer<'static, R> {
        Lexer::new(
            // parameters
            NBR_GROUPS,
            INITIAL_STATE,
            FIRST_END_STATE,
            NBR_STATES,
            // tables
            &ASCII_TO_GROUP,
            HashMap::<char, GroupId>::from(UTF8_TO_GROUP),
            SegMap::<GroupId>::from_iter(SEG_TO_GROUP),
            &STATE_TABLE,
            &TERMINAL_TABLE,
        )
    }

    // -------------------------------------------------------------------------

    #[test]
    fn lexer_modes() {
        let tests = vec![
            (1, vec![
                // no error
                (" 10 20 30", vec![0, 0, 0], vec!["10", "20", "30"]),
                (" 10 20 ", vec![0, 0], vec!["10", "20"]),
                (" 5 /* bla bla */ 6", vec![0, 0], vec!["5", "6"]),
            ]),
        ];
        const VERBOSE: bool = false;
        for (test_id, inputs) in tests.into_iter() {
            if VERBOSE { println!("test {test_id}:"); }
            let mut lexer = build_lexer();
            for (input, expected_tokens, expected_texts) in inputs {
                if VERBOSE { print!("\"{}\":", escape_string(input)); }
                let stream = CharReader::new(Cursor::new(input));
                lexer.attach_stream(stream);
                let (tokens, texts): (Vec<TokenId>, Vec<String>) = lexer.tokens().map(|(tok, ch, text, _span)| {
                    if VERBOSE { print!(" ({tok}, \"{text}\")")}
                    assert_eq!(ch, 0, "test {} failed for input {}", test_id, escape_string(input));
                    (tok, text)
                }).unzip();
                if VERBOSE { println!(); }
                assert_eq!(tokens, expected_tokens, "test {} failed for input '{}'", test_id, escape_string(input));
                assert_eq!(texts, expected_texts, "test {} failed for input '{}'", test_id, escape_string(input));
                assert!(!lexer.has_error() || lexer.is_eos(), "test {} failed for input '{}'",
                        test_id, escape_string(input));

            }
            if VERBOSE { println!("--------------------------------------\n"); }
        }
    }

}
