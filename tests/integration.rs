// Copyright 2023 Redglyph
//
// Integration tests: tests that all the functionalities are accessible and work as expected.

#![cfg(test)]

mod listener {
    use std::collections::HashMap;
    use rlexer::dfa::TokenId;
    use rlexer::grammar::{Symbol, VarId};
    use rlexer::parser::{Call, Listener, Parser};
    use rlexer::symbol_table::SymbolTable;

    // Code generated by rparser -------------------------------------

    const SYMBOLS_T: [(&str, Option<&str>); 8] = [("PLUS", Some("+")), ("MINUS", Some("-")), ("MUL", Some("*")), ("DIV", Some("/")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None)];
    const SYMBOLS_NT: [&str; 5] = ["E", "T", "F", "E_1", "T_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("E_1", 3), ("T_1", 4)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(3)]), (1, &[Symbol::NT(2), Symbol::NT(4)]), (2, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (2, &[Symbol::T(6)]), (2, &[Symbol::T(7)]), (3, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::Empty]), (4, &[Symbol::T(2), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::T(3), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::Empty])];
    const PARSING_TABLE: [VarId; 45] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 1, 11, 1, 1, 11, 11, 11, 11, 11, 2, 11, 3, 4, 11, 5, 6, 11, 11, 11, 7, 11, 11, 7, 10, 10, 8, 9, 11, 10, 11, 11, 10];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, Vec<Symbol>)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, s.to_vec())).collect();
        let table: Vec<VarId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: 5,
            num_t: 9,
            factors,
            table
        };
        Parser::new(parsing_table, symbol_table, START_SYMBOL)
    }

    // - 0: E -> T E_1
    // - 1: T -> F T_1
    // - 2: F -> ( E )
    // - 3: F -> NUM
    // - 4: F -> ID
    // - 5: E_1 -> + T E_1
    // - 6: E_1 -> - T E_1
    // - 7: E_1 -> ε
    // - 8: T_1 -> * F T_1
    // - 9: T_1 -> / F T_1
    // - 10: T_1 -> ε
    pub enum CtxF { LpRp, Num(String), Id(String) }
    pub enum CtxE1 { Add, Sub, Empty }
    pub enum CtxT1 { Mul, Div, Empty }

    pub trait ExprListenerTrait {
        fn enter_e(&mut self) {}
        fn enter_t(&mut self) {}
        fn enter_f(&mut self) {}
        fn enter_e_1(&mut self) {}
        fn enter_t_1(&mut self) {}
        fn exit_e(&mut self) {}
        fn exit_t(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) {}
        fn exit_e_1(&mut self, _ctx: CtxE1) {}
        fn exit_t_1(&mut self, _ctx: CtxT1) {}
    }

    struct ListenerWrapper<T>(T);

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T) -> Self {
            Self(listener)
        }

        pub fn listener(self) -> T {
            self.0
        }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, mut t_str: Vec<String>) -> bool {
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.0.enter_e(),
                        1 => self.0.enter_t(),
                        2 => self.0.enter_f(),
                        3 => self.0.enter_e_1(),
                        4 => self.0.enter_t_1(),
                        _ => panic!("unexpected nt exit value: {nt}")
                    }
                }
                Call::Exit => {
                    match factor_id {
                        0 => self.0.exit_e(),
                        1 => self.0.exit_t(),
                        2 => self.0.exit_f(CtxF::LpRp),
                        3 => self.0.exit_f(CtxF::Num(t_str.pop().unwrap())),
                        4 => self.0.exit_f(CtxF::Id(t_str.pop().unwrap())),
                        5 => self.0.exit_e_1(CtxE1::Add),
                        6 => self.0.exit_e_1(CtxE1::Sub),
                        7 => self.0.exit_e_1(CtxE1::Empty),
                        8 => self.0.exit_t_1(CtxT1::Mul),
                        9 => self.0.exit_t_1(CtxT1::Div),
                        10 => self.0.exit_t_1(CtxT1::Empty),
                        _ => panic!("unexpected nt exit factor id: {nt}")
                    }
                }
                Call::Rec => panic!("unexpected Call::Rec in this test"),
            }
            false
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        result: Vec<String>,
        level: usize,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { result: Vec::new(), level: 0, verbose }
        }
    }

    impl ExprListenerTrait for TestListener {
        fn enter_e(&mut self) {
            if self.verbose { println!("{: <1$}(E", "", self.level * 4); }
            self.result.push("(E".to_string());
            self.level += 1;
        }

        fn enter_t(&mut self) {
            if self.verbose { println!("{: <1$}(T", "", self.level * 4); }
            self.result.push("(T".to_string());
            self.level += 1;
        }

        fn enter_f(&mut self) {
            if self.verbose { println!("{: <1$}(F", "", self.level * 4); }
            self.result.push("(F".to_string());
            self.level += 1;
        }

        // we're not interested in enter_e_1

        fn enter_t_1(&mut self) {
            if self.verbose { println!("{: <1$}(T_1", "", self.level * 4); }
            self.result.push("(T_1".to_string());
            self.level += 1;
        }

        fn exit_e(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} E)", "", self.level * 4); }
            self.result.push("E)".to_string());
        }

        fn exit_t(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T)", "", self.level * 4); }
            self.result.push("T)".to_string());
        }

        fn exit_f(&mut self, ctx: CtxF) {
            self.level -= 1;
            let output = match ctx {
                CtxF::LpRp => format!("F)"),
                CtxF::Num(n) => format!("F)=#{n}"),
                CtxF::Id(i) => format!("F)='{i}'"),
            };
            if self.verbose { println!("{: <1$} {output}", "", self.level * 4); }
            self.result.push(output);
        }

        // we're not interested in exit_e_1

        fn exit_t_1(&mut self, _ctx: CtxT1) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T_1)", "", self.level * 4); }
            self.result.push("T_1)".to_string());
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // E -> T E_1
            // T -> F T_1
            // F -> ( E ) | NUM | ID
            // E_1 -> + T E_1 | - T E_1 | ε
            // T_1 -> * F T_1 | / F T_1 | ε
            ("a+2*b", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "T_1)", "T)", "(T", "(F", "F)=#2",
                "(T_1", "(F", "F)='b'", "T_1)", "(T_1", "T_1)", "T)", "E)"]),
            ("a*(4+5)", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "(F", "(E", "(T", "(F", "F)=#4", "(T_1", "T_1)", "T)",
                "(T", "(F", "F)=#5", "(T_1", "T_1)", "T)", "E)", "F)", "T_1)", "(T_1", "T_1)", "T)", "E)"]),
        ];
        const VERBOSE: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let listener = TestListener::new(VERBOSE);
            let mut wrapper = ListenerWrapper::new(listener);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            let listener = wrapper.listener();

            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {}", listener.result.join(" -> ")); }
            assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
        }
    }
}

// ---------------------------------------------------------------------------------------------
// General helper traits

#[allow(unused)]
pub(crate) trait CollectJoin {
    fn join(&mut self, separator: &str) -> String
        where Self: Iterator,
              <Self as Iterator>::Item: ToString
    {
        self.map(|x| x.to_string()).collect::<Vec<_>>().join(separator)
    }

    fn to_vec(self) -> Vec<<Self as Iterator>::Item>
        where Self: Iterator + Sized
    {
        self.collect::<Vec<_>>()
    }
}

impl<I: Iterator> CollectJoin for I {}

// ---------------------------------------------------------------------------------------------

#[allow(non_camel_case_types)]
#[allow(unused)]
mod listener2 {
    use std::collections::HashMap;
    use std::str::FromStr;
    use rlexer::dfa::TokenId;
    use rlexer::parser::{Call, Listener};

    // Code generated by rparser -------------------------------------

    use rlexer::grammar::{Symbol, VarId};
    use rlexer::parser::Parser;
    use rlexer::symbol_table::SymbolTable;
    use crate::CollectJoin;

    const PARSER_NUM_T: usize = 10;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("SUB", Some("-")), ("ADD", Some("+")), ("DIV", Some("/")), ("MUL", Some("*")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None), ("EXP", Some("^")), ("DUM", Some(":"))];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (1, &[Symbol::T(6)]), (1, &[Symbol::T(7)]), (2, &[Symbol::T(9), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(8), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(2), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(3), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [VarId; 33] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 11, 11, 1, 11, 2, 3, 11, 11, 11, 8, 9, 6, 7, 11, 10, 11, 11, 5, 4, 10];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, Vec<Symbol>)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, s.to_vec())).collect();
        let table: Vec<VarId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table
        };
        Parser::new(parsing_table, symbol_table, START_SYMBOL)
    }

    // E -> E : E | E ^ E | E / E | E * E | E - E | E + E | F
    // F -> ( E ) | NUM | ID
    //
    // E -> F E_1
    // F -> ( E ) | N | I
    // E_1 -> : F E_1 | ^ F E_1 | / F E_1 | * F E_1 | - F E_1 | + F E_1 | ε
    //
    // - 0: E -> F E_1
    // - 1: F -> ( E )
    // - 2: F -> N
    // - 3: F -> I
    // - 4: E_1 -> : F E_1
    // - 5: E_1 -> ^ F E_1
    // - 6: E_1 -> / F E_1
    // - 7: E_1 -> * F E_1
    // - 8: E_1 -> - F E_1
    // - 9: E_1 -> + F E_1
    // - 10: E_1 -> ε

    type SynE = Option<i64>;
    type SynF = Option<i64>;
    pub enum CtxE {
        Dum { e: [SynE; 2] },
        Exp { e: [SynE; 2] },
        Div { e: [SynE; 2] },
        Mul { e: [SynE; 2] },
        Sub { e: [SynE; 2] },
        Add  { e: [SynE; 2] },
        F { f: SynE } }
    pub enum CtxF { E { e: SynE }, Num(String), Id(String) }
    // internal
    enum CtxE_1 { Mul { f: SynE, e_1: SynE }, Add { f: SynE, e_1: SynE }, Empty }

    enum SynValue { F(SynE), E_1(SynE), E(SynE) }

    fn syn_e_str(e: &SynE) -> String {
        if let Some(v) = e {
            v.to_string()
        } else {
            "?".to_string()
        }
    }

    impl std::fmt::Debug for SynValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                SynValue::F(e) => write!(f, "E({})", syn_e_str(e)),
                SynValue::E_1(e) => write!(f, "E_1({})", syn_e_str(e)),
                SynValue::E(e) => write!(f, "E({})", syn_e_str(e)),
            }
        }
    }

    impl SynValue {
        fn e(self) -> SynE {
            if let SynValue::E(e) = self { e } else { panic!() }
        }
        fn e_1(self) -> SynE {
            if let SynValue::E_1(e_1) = self { e_1 } else { panic!() }
        }
        fn f(self) -> SynE {
            if let SynValue::F(f) = self { f } else { panic!() }
        }
    }

    #[derive(Debug, PartialEq)]
    enum RecE { E, E_1_Dum, E_1_Exp, E_1_Div, E_1_Mul, E_1_Sub, E_1_Add, E_1_Empty }

    struct RecItem {
        val: SynE,
        ty: RecE,
    }

    impl std::fmt::Debug for RecItem {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let e = &self.val;
            match self.ty {
                RecE::E => write!(f, "E({})", syn_e_str(e)),
                RecE::E_1_Dum => write!(f, "E_1(: {})", syn_e_str(e)),
                RecE::E_1_Exp => write!(f, "E_1(^ {})", syn_e_str(e)),
                RecE::E_1_Div => write!(f, "E_1(/ {})", syn_e_str(e)),
                RecE::E_1_Mul => write!(f, "E_1(* {})", syn_e_str(e)),
                RecE::E_1_Sub => write!(f, "E_1(- {})", syn_e_str(e)),
                RecE::E_1_Add => write!(f, "E_1(+ {})", syn_e_str(e)),
                RecE::E_1_Empty => write!(f, "E_1(ε)")
            }
        }
    }

    const LEFT_ASSOC_DUM: bool = true;
    const LEFT_ASSOC_EXP: bool = false;
    const LEFT_ASSOC_DIV: bool = true;
    const LEFT_ASSOC_MUL: bool = true;
    const LEFT_ASSOC_SUB: bool = true;
    const LEFT_ASSOC_ADD: bool = true;
    const LEFT_ASSOC_EMPTY: bool = true; // don't care as long as its priority is high enough to fold

    impl RecE {
        fn is_left_assoc(&self) -> bool {
            match self {
                RecE::E         => false,
                RecE::E_1_Dum   => LEFT_ASSOC_DUM,
                RecE::E_1_Exp   => LEFT_ASSOC_EXP,
                RecE::E_1_Div   => LEFT_ASSOC_DIV,
                RecE::E_1_Mul   => LEFT_ASSOC_MUL,
                RecE::E_1_Sub   => LEFT_ASSOC_SUB,
                RecE::E_1_Add   => LEFT_ASSOC_ADD,
                RecE::E_1_Empty => LEFT_ASSOC_EMPTY,
            }
        }
    }

    const PRIORITY_MIN: u16 = 0;
    const PRIORITY_ADD: u16 = 1;
    const PRIORITY_SUB: u16 = 2;
    const PRIORITY_MUL: u16 = 3;
    const PRIORITY_DIV: u16 = 4;
    const PRIORITY_EXP: u16 = 5;
    const PRIORITY_DUM: u16 = 6;
    const PRIORITY_MAX: u16 = u16::MAX;
    const PRIORITY_EMPTY: u16 = PRIORITY_MIN;

    pub trait ExprListenerTrait {
        fn init_e(&mut self) {}
        fn init_f(&mut self, _factor_id: VarId) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE { None }
        fn exit_f(&mut self, _ctx: CtxF) -> SynE { None }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        rec_stack: Vec<(RecItem, u16, bool)>, // item, priority, is_left_assoc
        max_stack: usize,
        max_rec_stack: usize,
    }

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), rec_stack: Vec::new(), max_stack: 0, max_rec_stack: 0 }
        }

        pub fn listener(self) -> T {
            self.listener
        }
    }

    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, mut t_str: Vec<String>) -> bool {
            let mut rec_required = false;
            match call {
                Call::Enter => {
                    match nt {
                        0 => {
                            self.listener.init_e();
                            self.init_e();
                            rec_required = true;
                        },
                        1 => self.listener.init_f(factor_id),
                        2 => if self.verbose { println!("► {}", factor_str(factor_id, true)); }
                        _ => panic!("unexpected exit nt: {nt}")
                    }
                }
                Call::Exit => {
                    if self.verbose && nt == 2 {
                        println!("◄ {}", factor_str(factor_id, true));
                    }
                    match factor_id {
                        0 => self.rec_e(),
                        1 => {
                            let e = self.stack.pop().unwrap().e();
                            self.stack.push(SynValue::F(self.listener.exit_f(CtxF::E { e })));
                        }
                        2 => { self.stack.push(SynValue::F(self.listener.exit_f(CtxF::Num(t_str.pop().unwrap())))); }
                        3 => { self.stack.push(SynValue::F(self.listener.exit_f(CtxF::Id(t_str.pop().unwrap())))); }
                        4 => self.rec_e_1(factor_id, PRIORITY_DUM, LEFT_ASSOC_DUM),
                        5 => self.rec_e_1(factor_id, PRIORITY_EXP, LEFT_ASSOC_EXP),
                        6 => self.rec_e_1(factor_id, PRIORITY_DIV, LEFT_ASSOC_DIV),
                        7 => self.rec_e_1(factor_id, PRIORITY_MUL, LEFT_ASSOC_MUL),
                        8 => self.rec_e_1(factor_id, PRIORITY_SUB, LEFT_ASSOC_SUB),
                        9 => self.rec_e_1(factor_id, PRIORITY_ADD, LEFT_ASSOC_ADD),
                        10 => {} //self.rec_e_1(factor_id, PRIORITY_EMPTY, LEFT_ASSOC_EMPTY),
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::Rec => {
                    match factor_id {
                        0 => self.inh_e(),
                        _ => panic!("unexpected rec factor id: {factor_id}")
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            self.max_rec_stack = std::cmp::max(self.max_rec_stack, self.rec_stack.len());
            if self.verbose {
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                println!("> rec stack: {}", self.rec_stack.iter().map(|(it, p, l)| format!("{it:?}/{p}/{}", if *l { "L" } else { "R" })).join(", "));
            }
            rec_required
        }
    }

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        fn fold_e_1(&mut self, priority: u16, mut is_left_assoc: bool) {
            // Folding the top two items while the priority of the top item is higher than the argument.
            // If left-associative, we allow folding items of the same priority, so we are sure that
            // the priority is always increasing towards the top of the stack. This allows us to fold
            // right- and left-associative items the same way (which we couldn't if two or more left-associative
            // items had the same priority).
            while self.rec_stack.len() > 1 && self.rec_stack.last().map(|(e, p, left)| e.ty != RecE::E && (*p > priority || (*p == priority && is_left_assoc))).unwrap() {
                let (new, _, _) = self.rec_stack.pop().unwrap();
                let (top, _, _) = self.rec_stack.last_mut().unwrap();
                if self.verbose {
                    println!("- fold with priority {priority}/{}: {top:?} and {new:?}", if is_left_assoc { "L" } else { "R" });
                }
                match new.ty {
                    RecE::E_1_Dum   => { top.val = self.listener.exit_e(CtxE::Dum { e: [top.val, new.val] }); }
                    RecE::E_1_Exp   => { top.val = self.listener.exit_e(CtxE::Exp { e: [top.val, new.val] }); }
                    RecE::E_1_Div   => { top.val = self.listener.exit_e(CtxE::Div { e: [top.val, new.val] }); }
                    RecE::E_1_Mul   => { top.val = self.listener.exit_e(CtxE::Mul { e: [top.val, new.val] }); }
                    RecE::E_1_Sub   => { top.val = self.listener.exit_e(CtxE::Sub { e: [top.val, new.val] }); }
                    RecE::E_1_Add   => { top.val = self.listener.exit_e(CtxE::Add { e: [top.val, new.val] }); }
                    RecE::E_1_Empty => { },
                    // we must never pop RecE::E here, so we must ignore its case
                    _ => panic!()
                }
                if self.verbose {
                    println!("-> {top:?}");
                }
                is_left_assoc = top.ty.is_left_assoc();
            }
        }

        fn init_e(&mut self) {
            // stopper for this expression (PRIORITY_MIN and right-associativity means it will never be merged)
            self.rec_stack.push((RecItem { val: None, ty: RecE::E}, PRIORITY_MIN, false));
        }

        fn inh_e(&mut self) {
            // F of E -> F E_1 is now on the stack => attach it
            let new_f = self.stack.pop().unwrap().f();
            // rec_child, so promoting the value:
            let mut new_e = self.listener.exit_e(CtxE::F { f: new_f });
            let top = &mut self.rec_stack.last_mut().unwrap().0;
            assert_eq!(top.ty, RecE::E);
            assert_eq!(top.val, None);
            top.val = new_e;
        }

        // rec_parent, ambig_parent, E : E | E ^ E | E / E | E * E | E - E | E + E | F
        // - 0: E -> F E_1
        fn rec_e(&mut self) {
            self.fold_e_1(PRIORITY_MIN, false);
            let (e, _, _) = self.rec_stack.pop().expect("E should be on top of the stack");
            assert_eq!(e.ty, RecE::E, "the top of the stack should be E instead of {e:?}");
            self.stack.push(SynValue::E(e.val));
        }

        // rec_child, ambig_child
        fn rec_e_1(&mut self, factor_id: VarId, priority: u16, is_left_assoc: bool) {
            // if factor_id == 10 {
            //     self.rec_stack.push((RecItem { val: None, ty: RecE::E_1_Empty }, PRIORITY_MAX, true));
            //     return;
            // }
            self.fold_e_1(priority, is_left_assoc);
            // ambig_child, so promoting the value:
            let new_f = self.stack.pop().unwrap().f();
            let mut new_e = self.listener.exit_e(CtxE::F { f: new_f });
            let r = match factor_id {
                4 => RecItem { val: new_e, ty: RecE::E_1_Dum },
                5 => RecItem { val: new_e, ty: RecE::E_1_Exp },
                6 => RecItem { val: new_e, ty: RecE::E_1_Div },
                7 => RecItem { val: new_e, ty: RecE::E_1_Mul },
                8 => RecItem { val: new_e, ty: RecE::E_1_Sub },
                9 => RecItem { val: new_e, ty: RecE::E_1_Add },
                _ => panic!()
            };
            self.rec_stack.push((r, priority, is_left_assoc));
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        vars: HashMap<String, i64>,
        result: Option<i64>,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { vars: HashMap::new(), result: None, verbose }
        }
    }

    fn factor_str(factor_id: VarId, nt: bool) -> String {
        match factor_id {
             0 => if nt { "E -> F E_1"     } else { "F E_1"   },
             1 => if nt { "F -> ( E )"     } else { "( E )"   },
             2 => if nt { "F -> N"         } else { "N"       },
             3 => if nt { "F -> I"         } else { "I"       },
             4 => if nt { "E_1 -> : F E_1" } else { ": F E_1" },
             5 => if nt { "E_1 -> ^ F E_1" } else { "^ F E_1" },
             6 => if nt { "E_1 -> / F E_1" } else { "/ F E_1" },
             7 => if nt { "E_1 -> * F E_1" } else { "* F E_1" },
             8 => if nt { "E_1 -> - F E_1" } else { "- F E_1" },
             9 => if nt { "E_1 -> + F E_1" } else { "+ F E_1" },
            10 => if nt { "E_1 -> ε"       } else { "ε"       },
            _ => panic!()
        }.to_string()
    }

    impl ExprListenerTrait for TestListener {

        fn init_e(&mut self) {
            if self.verbose {
                println!("► E");
            }
            self.result = None;
        }

        fn init_f(&mut self, factor_id: VarId) {
            if self.verbose { println!("► F -> {}", factor_str(factor_id, false)); }
        }

        fn exit_e(&mut self, ctx: CtxE) -> SynE {
            let value = match &ctx {
                CtxE::Dum { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        Some(i64::max(*e0, *e1))
                    } else {
                        None
                    }
                }
                CtxE::Exp { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        if *e1 <= u32::MAX as i64 {
                            e0.checked_pow(*e1 as u32)
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }
                CtxE::Div { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_div(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Mul { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_mul(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Sub { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_sub(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Add { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_add(*e1)
                    } else {
                        None
                    }
                }
                CtxE::F { f } => *f,
            };
            if self.verbose {
                let output = match ctx {
                    CtxE::Dum { e } => format!("◄ E={:?} : {:?}={value:?}", e[0], e[1]),
                    CtxE::Exp { e } => format!("◄ E={:?} ^ {:?}={value:?}", e[0], e[1]),
                    CtxE::Div { e } => format!("◄ E={:?} / {:?}={value:?}", e[0], e[1]),
                    CtxE::Mul { e } => format!("◄ E={:?} * {:?}={value:?}", e[0], e[1]),
                    CtxE::Sub { e } => format!("◄ E={:?} - {:?}={value:?}", e[0], e[1]),
                    CtxE::Add { e } => format!("◄ E={:?} + {:?}={value:?}", e[0], e[1]),
                    CtxE::F { f } => format!("◄ E=F={value:?}"),
                };
                println!("{output}");
            }
            self.result = value;
            value
        }

        fn exit_f(&mut self, ctx: CtxF) -> SynE {
            let value = match &ctx {
                CtxF::E { e } => *e,
                CtxF::Num(s) => i64::from_str(s).ok(),
                CtxF::Id(s) => self.vars.get(s).cloned(),
            };
            if self.verbose {
                let output = match ctx {
                    CtxF::E { .. } => format!("◄ F=E={value:?}"),
                    CtxF::Num(n) => format!("◄ F=NUM #{n}={value:?}"),
                    CtxF::Id(i) => format!("◄ F=ID '{i}'={value:?}"),
                };
                println!("{output}");
            }
            value
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // left
            ("2+3*4*5", true, Some(62)),    // priority high-low-high (reconstruction)
            ("1+2+3+4+5+6+7+8+9", true, Some(45)),  // parser stack accumulation
            ("2*3+4*5", true, Some(26)),    // priority high-low-high (reconstruction)
            ("2+3*4+5", true, Some(19)),    // priority low-high-low (reconstruction)
            ("a+2*b", true, Some(50)),
            ("a*(4+5)", true, Some(90)),
            ("1*2*3*4", true, Some(24)),
            ("1+2+3+4", true, Some(10)),
            ("(1)", true, Some(1)),
            ("((5))", true, Some(5)),
            // right
            ("2^3", true, Some(8)),
            ("4^3^2", true, Some(262144)),
            // both left and right
            ("5+3*2^8-3-2+1", true, Some(769)),
            ("5:3:2^2", true, Some(25)),
            ("5:(2^4-3*(3))", true, Some(7)),
            // undef
            ("z", true, None),
            ("5*z+y", true, None),
            // errors
            ("a*(4+5", false, None),
            ("a b", false, None),
            ("a++", false, None),
        ];
        const VERBOSE: bool = false;
        const VERBOSE_LISTENER: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let mut listener = TestListener::new(VERBOSE_LISTENER);
            listener.vars.extend([
                ("a".to_string(), 10),
                ("b".to_string(), 20),
                ("c".to_string(), 30),
            ]);
            let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            if VERBOSE {
                println!("max stack: {}\nmax rec stack: {}", wrapper.max_stack, wrapper.max_rec_stack);
                println!("listener stack: {:?}", wrapper.stack);
                println!("listener rec stack: {:?}", wrapper.rec_stack);
            }
            let listener = wrapper.listener();
            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {:?}", listener.result); }
            if success {
                assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
            }
        }
    }
}

#[cfg(disabled)]
mod listener3 {

    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{Symbol, VarId};
    use rlexer::parser::{Call, Listener, Parser};
    use rlexer::symbol_table::SymbolTable;
    use crate::CollectJoin;

    const PARSER_NUM_T: usize = 6;
    const PARSER_NUM_NT: usize = 2;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("struct", Some("struct")), ("{", Some("{")), ("}", Some("}")), (":", Some(":")), (";", Some(";")), ("id", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["STRUCT", "LIST"];
    const SYMBOLS_NAMES: [(&str, VarId); 0] = [];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 3] = [(0, &[Symbol::T(0), Symbol::T(5), Symbol::T(1), Symbol::NT(1)]), (1, &[Symbol::T(5), Symbol::T(3), Symbol::T(5), Symbol::T(4), Symbol::NT(1)]), (1, &[Symbol::T(2)])];
    const PARSING_TABLE: [VarId; 14] = [0, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 1, 3];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, Vec<Symbol>)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, s.to_vec())).collect();
        let table: Vec<VarId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table
        };
        Parser::new(parsing_table, symbol_table, START_SYMBOL)
    }

    // -------------------------------------------------------------------------

    // - 0: STRUCT -> struct id { LIST
    // - 1: LIST -> id : id ; LIST
    // - 2: LIST -> }

    type SynStruct = usize;
    type SynList = Vec<(String, String)>;

    #[derive(Debug)]
    enum SynValue { Struct, List }

    #[derive(Debug)]
    struct RecItem { }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        rec_stack: Vec<(RecItem, u16, bool)>, // item, priority, is_left_assoc
        max_stack: usize,
        max_rec_stack: usize,
    }

    pub trait ExprListenerTrait {
        fn init_decl(&mut self) {}
        fn exit_decl(&mut self) {}
        fn init_vars(&mut self) {}
        fn iter_vars(&mut self) {}
        fn exit_vars(&mut self) {}
    }

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), rec_stack: Vec::new(), max_stack: 0, max_rec_stack: 0 }
        }

        pub fn listener(self) -> T {
            self.listener
        }
    }

    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, mut t_str: Vec<String>) -> bool {
            let mut rec_required = false;
            match call {
                Call::Enter => {
                    match nt {
                        0 => { /* TODO */ },   // STRUCT
                        1 => { /* TODO */ },   // LIST
                        _ => panic!("unexpected exit non-terminal id: {nt}")
                    }
                }
                Call::Exit => {
                    match factor_id {
                        0 => { /* TODO */ },   // - 0: STRUCT -> struct id { LIST
                        1 => { /* TODO */ },   // - 1: LIST -> id : id ; LIST
                        2 => { /* TODO */ },   // - 2: LIST -> }
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::Rec => {
                    match factor_id {
                        _ => panic!("unexpected rec factor id: {factor_id}")
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            self.max_rec_stack = std::cmp::max(self.max_rec_stack, self.rec_stack.len());
            if self.verbose {
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                println!("> rec stack: {}", self.rec_stack.iter().map(|(it, p, l)| format!("{it:?}/{p}/{}", if *l { "L" } else { "R" })).join(", "));
            }
            rec_required
        }
    }

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        /* TODO */
    }

    // User code -----------------------------------------------------

    struct TestListener {
        verbose: bool
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            ("2+3*4*5", true, Some(62)), // TODO: change
        ];
        const VERBOSE: bool = true;
        const VERBOSE_LISTENER: bool = true;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    // TODO: change
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let mut listener = TestListener::new(VERBOSE_LISTENER);
            let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            if VERBOSE {
                println!("max stack: {}\nmax rec stack: {}", wrapper.max_stack, wrapper.max_rec_stack);
                println!("listener stack: {:?}", wrapper.stack);
                println!("listener rec stack: {:?}", wrapper.rec_stack);
            }
            let listener = wrapper.listener();
            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {:?}", listener.result); }
            if success {
                assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
            }
        }
    }

}