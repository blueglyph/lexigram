// Copyright 2023 Redglyph
//
// Integration tests: tests that all the functionalities are accessible and work as expected.

#![cfg(test)]

mod listener {
    use std::collections::HashMap;
    use rlexer::dfa::TokenId;
    use rlexer::grammar::{Symbol, VarId};
    use rlexer::parser::{Call, Listener, Parser};
    use rlexer::symbol_table::SymbolTable;

    // Code generated by rparser -------------------------------------

    const SYMBOLS_T: [(&str, Option<&str>); 8] = [("PLUS", Some("+")), ("MINUS", Some("-")), ("MUL", Some("*")), ("DIV", Some("/")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None)];
    const SYMBOLS_NT: [&str; 5] = ["E", "T", "F", "E_1", "T_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("E_1", 3), ("T_1", 4)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(3)]), (1, &[Symbol::NT(2), Symbol::NT(4)]), (2, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (2, &[Symbol::T(6)]), (2, &[Symbol::T(7)]), (3, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::Empty]), (4, &[Symbol::T(2), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::T(3), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::Empty])];
    const PARSING_TABLE: [VarId; 45] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 1, 11, 1, 1, 11, 11, 11, 11, 11, 2, 11, 3, 4, 11, 5, 6, 11, 11, 11, 7, 11, 11, 7, 10, 10, 8, 9, 11, 10, 11, 11, 10];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, Vec<Symbol>)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, s.to_vec())).collect();
        let table: Vec<VarId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: 5,
            num_t: 9,
            factors,
            table
        };
        Parser::new(parsing_table, symbol_table, START_SYMBOL)
    }

    // - 0: E -> T E_1
    // - 1: T -> F T_1
    // - 2: F -> ( E )
    // - 3: F -> NUM
    // - 4: F -> ID
    // - 5: E_1 -> + T E_1
    // - 6: E_1 -> - T E_1
    // - 7: E_1 -> ε
    // - 8: T_1 -> * F T_1
    // - 9: T_1 -> / F T_1
    // - 10: T_1 -> ε
    pub enum CtxF { LpRp, Num(String), Id(String) }
    pub enum CtxE1 { Add, Sub, Empty }
    pub enum CtxT1 { Mul, Div, Empty }

    pub trait ExprListenerTrait {
        fn enter_e(&mut self) {}
        fn enter_t(&mut self) {}
        fn enter_f(&mut self) {}
        fn enter_e_1(&mut self) {}
        fn enter_t_1(&mut self) {}
        fn exit_e(&mut self) {}
        fn exit_t(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) {}
        fn exit_e_1(&mut self, _ctx: CtxE1) {}
        fn exit_t_1(&mut self, _ctx: CtxT1) {}
    }

    struct ListenerWrapper<T>(T);

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T) -> Self {
            Self(listener)
        }

        pub fn listener(self) -> T {
            self.0
        }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, mut t_str: Vec<String>) {
            if let Call::Enter = call {
                match nt {
                    0 => self.0.enter_e(),
                    1 => self.0.enter_t(),
                    2 => self.0.enter_f(),
                    3 => self.0.enter_e_1(),
                    4 => self.0.enter_t_1(),
                    _ => panic!("unexpected nt exit value: {nt}")
                }
            } else {
                match factor_id {
                    0 => self.0.exit_e(),
                    1 => self.0.exit_t(),
                    2 => self.0.exit_f(CtxF::LpRp),
                    3 => self.0.exit_f(CtxF::Num(t_str.pop().unwrap())),
                    4 => self.0.exit_f(CtxF::Id(t_str.pop().unwrap())),
                    5 => self.0.exit_e_1(CtxE1::Add),
                    6 => self.0.exit_e_1(CtxE1::Sub),
                    7 => self.0.exit_e_1(CtxE1::Empty),
                    8 => self.0.exit_t_1(CtxT1::Mul),
                    9 => self.0.exit_t_1(CtxT1::Div),
                    10 => self.0.exit_t_1(CtxT1::Empty),
                    _ => panic!("unexpected nt exit factor id: {nt}")
                }
            }
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        result: Vec<String>,
        level: usize,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { result: Vec::new(), level: 0, verbose }
        }
    }

    impl ExprListenerTrait for TestListener {
        fn enter_e(&mut self) {
            if self.verbose { println!("{: <1$}(E", "", self.level * 4); }
            self.result.push("(E".to_string());
            self.level += 1;
        }

        fn enter_t(&mut self) {
            if self.verbose { println!("{: <1$}(T", "", self.level * 4); }
            self.result.push("(T".to_string());
            self.level += 1;
        }

        fn enter_f(&mut self) {
            if self.verbose { println!("{: <1$}(F", "", self.level * 4); }
            self.result.push("(F".to_string());
            self.level += 1;
        }

        // we're not interested in enter_e_1

        fn enter_t_1(&mut self) {
            if self.verbose { println!("{: <1$}(T_1", "", self.level * 4); }
            self.result.push("(T_1".to_string());
            self.level += 1;
        }

        fn exit_e(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} E)", "", self.level * 4); }
            self.result.push("E)".to_string());
        }

        fn exit_t(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T)", "", self.level * 4); }
            self.result.push("T)".to_string());
        }

        fn exit_f(&mut self, ctx: CtxF) {
            self.level -= 1;
            let output = match ctx {
                CtxF::LpRp => format!("F)"),
                CtxF::Num(n) => format!("F)=#{n}"),
                CtxF::Id(i) => format!("F)='{i}'"),
            };
            if self.verbose { println!("{: <1$} {output}", "", self.level * 4); }
            self.result.push(output);
        }

        // we're not interested in exit_e_1

        fn exit_t_1(&mut self, _ctx: CtxT1) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T_1)", "", self.level * 4); }
            self.result.push("T_1)".to_string());
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // E -> T E_1
            // T -> F T_1
            // F -> ( E ) | NUM | ID
            // E_1 -> + T E_1 | - T E_1 | ε
            // T_1 -> * F T_1 | / F T_1 | ε
            ("a+2*b", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "T_1)", "T)", "(T", "(F", "F)=#2",
                "(T_1", "(F", "F)='b'", "(T_1", "T_1)", "T_1)", "T)", "E)"]),
            ("a*(4+5)", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "(F", "(E", "(T", "(F", "F)=#4", "(T_1", "T_1)", "T)", "(T",
                "(F", "F)=#5", "(T_1", "T_1)", "T)", "E)", "F)", "(T_1", "T_1)", "T_1)", "T)", "E)"]),
        ];
        const VERBOSE: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let listener = TestListener::new(VERBOSE);
            let mut wrapper = ListenerWrapper::new(listener);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            let listener = wrapper.listener();

            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {}", listener.result.join(" -> ")); }
            assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
        }
    }
}

mod listener2 {
    use std::collections::HashMap;
    use rlexer::dfa::TokenId;
    use rlexer::grammar::{Symbol, VarId};
    use rlexer::parser::{Call, Listener, Parser};
    use rlexer::symbol_table::SymbolTable;

    // Code generated by rparser -------------------------------------

    const SYMBOLS_T: [(&str, Option<&str>); 8] = [("ADD", Some("+")), ("SUB", Some("-")), ("MUL", Some("*")), ("DIV", Some("/")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None)];
    const SYMBOLS_NT: [&str; 3] = ["E", "F", "E_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 7] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (1, &[Symbol::T(6)]), (1, &[Symbol::T(7)]), (2, &[Symbol::T(2), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [VarId; 27] = [7, 7, 7, 7, 0, 7, 0, 0, 7, 7, 7, 7, 7, 1, 7, 2, 3, 7, 5, 7, 4, 7, 7, 6, 7, 7, 6];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, Vec<Symbol>)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, s.to_vec())).collect();
        let table: Vec<VarId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: 5,
            num_t: 9,
            factors,
            table
        };
        Parser::new(parsing_table, symbol_table, START_SYMBOL)
    }

    // E -> F E_1
    // F -> ( E ) | N | I
    // E_1 -> * F E_1 | + F E_1 | ε
    // - 0: E -> F E_1
    // - 1: F -> ( E )
    // - 2: F -> N
    // - 3: F -> I
    // - 4: E_1 -> * F E_1
    // - 5: E_1 -> + F E_1
    // - 6: E_1 -> ε

// ----------------------------------------------------------------------------------------- ADAPT CODE BELOW

    pub enum CtxF { LpRp, Num(String), Id(String) }
    pub enum CtxE1 { Add, Mul, Empty }

    pub trait ExprListenerTrait {
        fn enter_e(&mut self) {}
        fn enter_f(&mut self) {}
        fn enter_e_1(&mut self) {}
        fn exit_e(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) {}
        fn exit_e_1(&mut self, _ctx: CtxE1) {}
    }

    struct ListenerWrapper<T>(T);

    impl<T: ExprListenerTrait> ListenerWrapper<T> {
        pub fn new(listener: T) -> Self {
            Self(listener)
        }

        pub fn listener(self) -> T {
            self.0
        }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    impl<T: ExprListenerTrait> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, mut t_str: Vec<String>) {
            if let Call::Enter = call {
                match nt {
                    0 => self.0.enter_e(),
                    1 => self.0.enter_t(),
                    2 => self.0.enter_f(),
                    3 => self.0.enter_e_1(),
                    4 => self.0.enter_t_1(),
                    _ => panic!("unexpected nt exit value: {nt}")
                }
            } else {
                match factor_id {
                    0 => self.0.exit_e(),
                    1 => self.0.exit_t(),
                    2 => self.0.exit_f(CtxF::LpRp),
                    3 => self.0.exit_f(CtxF::Num(t_str.pop().unwrap())),
                    4 => self.0.exit_f(CtxF::Id(t_str.pop().unwrap())),
                    5 => self.0.exit_e_1(CtxE1::Add),
                    6 => self.0.exit_e_1(CtxE1::Sub),
                    7 => self.0.exit_e_1(CtxE1::Empty),
                    8 => self.0.exit_t_1(CtxT1::Mul),
                    9 => self.0.exit_t_1(CtxT1::Div),
                    10 => self.0.exit_t_1(CtxT1::Empty),
                    _ => panic!("unexpected nt exit factor id: {nt}")
                }
            }
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        result: Vec<String>,
        level: usize,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { result: Vec::new(), level: 0, verbose }
        }
    }

    impl ExprListenerTrait for TestListener {
        fn enter_e(&mut self) {
            if self.verbose { println!("{: <1$}(E", "", self.level * 4); }
            self.result.push("(E".to_string());
            self.level += 1;
        }

        fn enter_t(&mut self) {
            if self.verbose { println!("{: <1$}(T", "", self.level * 4); }
            self.result.push("(T".to_string());
            self.level += 1;
        }

        fn enter_f(&mut self) {
            if self.verbose { println!("{: <1$}(F", "", self.level * 4); }
            self.result.push("(F".to_string());
            self.level += 1;
        }

        // we're not interested in enter_e_1

        fn enter_t_1(&mut self) {
            if self.verbose { println!("{: <1$}(T_1", "", self.level * 4); }
            self.result.push("(T_1".to_string());
            self.level += 1;
        }

        fn exit_e(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} E)", "", self.level * 4); }
            self.result.push("E)".to_string());
        }

        fn exit_t(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T)", "", self.level * 4); }
            self.result.push("T)".to_string());
        }

        fn exit_f(&mut self, ctx: CtxF) {
            self.level -= 1;
            let output = match ctx {
                CtxF::LpRp => format!("F)"),
                CtxF::Num(n) => format!("F)=#{n}"),
                CtxF::Id(i) => format!("F)='{i}'"),
            };
            if self.verbose { println!("{: <1$} {output}", "", self.level * 4); }
            self.result.push(output);
        }

        // we're not interested in exit_e_1

        fn exit_t_1(&mut self, _ctx: CtxT1) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T_1)", "", self.level * 4); }
            self.result.push("T_1)".to_string());
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // E -> T E_1
            // T -> F T_1
            // F -> ( E ) | NUM | ID
            // E_1 -> + T E_1 | - T E_1 | ε
            // T_1 -> * F T_1 | / F T_1 | ε
            ("a+2*b", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "T_1)", "T)", "(T", "(F", "F)=#2",
                "(T_1", "(F", "F)='b'", "(T_1", "T_1)", "T_1)", "T)", "E)"]),
            ("a*(4+5)", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "(F", "(E", "(T", "(F", "F)=#4", "(T_1", "T_1)", "T)", "(T",
                "(F", "F)=#5", "(T_1", "T_1)", "T)", "E)", "F)", "(T_1", "T_1)", "T_1)", "T)", "E)"]),
        ];
        const VERBOSE: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let listener = TestListener::new(VERBOSE);
            let mut wrapper = ListenerWrapper::new(listener);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            let listener = wrapper.listener();

            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {}", listener.result.join(" -> ")); }
            assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
        }
    }
}