#![cfg(test)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

// The code below is generated by parsergen::tests::wrapper_source::build_items

// ================================================================================
// Test 0: rules PRS(34) #1, start 0:
/*
before, NT with value: S, VAL
after,  NT with value: S, VAL
            // NT flags:
            //  - (nothing)
            // parents:
            //  - (nothing)
            (PRS(34), 0, btreemap![
                0 => "SynS".to_string(),
                1 => "SynVal".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1],               //  0: S -> id = VAL   | ◄0 ►VAL = id!  | id VAL
                1 => symbols![],                        //  1: S -> exit       | ◄1 exit        |
                2 => symbols![nt 1],                    //  2: S -> return VAL | ◄2 ►VAL return | VAL
                3 => symbols![t 0],                     //  3: VAL -> id       | ◄3 id!         | id
                4 => symbols![t 1],                     //  4: VAL -> num      | ◄4 num!        | num
            ], Set(symbols![nt 0, nt 1, t 0, t 1]), btreemap![0 => vec![0, 1, 2], 1 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_34_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(34) #1, start S]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_34_1::*;

    #[derive(Debug)]
    pub enum CtxS {
        /// `S -> id = VAL`
        S1 { id: String, val: SynVal },
        /// `S -> exit`
        S2,
        /// `S -> return VAL`
        S3 { val: SynVal },
    }
    #[derive(Debug)]
    pub enum CtxVal {
        /// `VAL -> id`
        Val1 { id: String },
        /// `VAL -> num`
        Val2 { num: String },
    }

    // NT types:
    // SynS: User-defined type for `S`
    // SynVal: User-defined type for `VAL`

    #[derive(Debug)]
    enum SynValue { S(SynS), Val(SynVal) }

    impl SynValue {
        fn get_s(self) -> SynS {
            if let SynValue::S(val) = self { val } else { panic!() }
        }
        fn get_val(self) -> SynVal {
            if let SynValue::Val(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _s: SynS) {}
        fn init_s(&mut self) {}
        fn exit_s(&mut self, _ctx: CtxS) -> SynS;
        fn init_val(&mut self) {}
        fn exit_val(&mut self, _ctx: CtxVal) -> SynVal;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_s(),                // S
                        1 => self.listener.init_val(),              // VAL
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // S -> id = VAL
                        1 |                                         // S -> exit
                        2 => self.exit_s(factor_id),                // S -> return VAL
                        3 |                                         // VAL -> id
                        4 => self.exit_val(factor_id),              // VAL -> num
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let s = self.stack.pop().unwrap().get_s();
            self.listener.exit(s);
        }

        fn exit_s(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let val = self.stack.pop().unwrap().get_val();
                    let id = self.stack_t.pop().unwrap();
                    CtxS::S1 { id, val }
                }
                1 => {
                    CtxS::S2
                }
                2 => {
                    let val = self.stack.pop().unwrap().get_val();
                    CtxS::S3 { val }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_s")
            };
            let val = self.listener.exit_s(ctx);
            self.stack.push(SynValue::S(val));
        }

        fn exit_val(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxVal::Val1 { id }
                }
                4 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxVal::Val2 { num }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_val")
            };
            let val = self.listener.exit_val(ctx);
            self.stack.push(SynValue::Val(val));
        }
    }

    // [wrapper source for rule PRS(34) #1, start S]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 1: rules RTS(21) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(21), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![nt 1, t 1],               //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | A_1 b
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_21_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(21) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_21_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]* c`
        A { a: String, star: SynA1, c: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[b]*` array in `A -> a  ► [b]* ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]* c
                        1 => self.exit_a1(),                        // [b]* item in A -> a  ► [b]* ◄  c
                        2 => {}                                     // end of [b]* items in A -> a  ► [b]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule RTS(21) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 2: rules RTS(21) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(21), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a c
                1 => symbols![],                        //  1: A_1 -> b A_1 | ●A_1 ◄1 b     |
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_21_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(21) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_21_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]* c`
        A { a: String, c: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]* c
                        1 |                                         // [b]* item in A -> a  ► [b]* ◄  c
                        2 => {}                                     // end of [b]* items in A -> a  ► [b]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(21) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 3: rules RTS(22) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b!    | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_22_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter, b: String },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynAIter: User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 4: rules RTS(22) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a c
                1 => symbols![],                        //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     |
                2 => symbols![],                        //  2: AIter1 -> ε        | ◄2               |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_22_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1,
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2,
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) {}
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.listener.init_aiter1(),           // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    CtxAiter1::Aiter1_1
                }
                2 => {
                    CtxAiter1::Aiter1_2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            self.listener.exit_aiter1(ctx);
        }
    }

    // [wrapper source for rule RTS(22) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 5: rules RTS(22) #3, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1],                    //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     | AIter1
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], Set(symbols![nt 0, nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #3, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_22_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynAIter: User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 6: rules RTS(22) #4, start 0:
/*
before, NT with value: AIter1
after,  NT with value: AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1],                    //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     | AIter1
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], Set(symbols![nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_4 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #4, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_22_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types:
    // SynAIter: User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
    // Top non-terminal A has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { Aiter1(SynAIter) }

    impl SynValue {
        fn get_aiter1(self) -> SynAIter {
            let SynValue::Aiter1(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, star, c });
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #4, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 7: rules RTS(32) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_left_fact | parent_+_or_* (2080)
            //  - AIter1: child_+_or_* | L-form (129)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> A
            (RTS(32), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1         | ►A_1 a!          |
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b!    | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
                3 => symbols![t 0, t 0, nt 1, t 2],     //  3: A_1 -> a AIter1 c  | ◄3 c! ►AIter1 a! | a a AIter1 c
                4 => symbols![t 0, t 2, nt 1, t 2],     //  4: A_1 -> c AIter1 c  | ◄4 c! ►AIter1 c! | a c AIter1 c
            ], All, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_rts_32_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(32) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_32_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a a (b <L>)* c`
        A1 { a: [String; 2], star: SynAIter, c: String },
        /// `A -> a c (b <L>)* c`
        A2 { a: String, c: [String; 2], star: SynAIter },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a a  ► (b <L>)* ◄  c | ...`
        Aiter1_1 { star_it: SynAIter, b: String },
        /// end of `(b <L>)*` iterations in `A -> a a  ► (b <L>)* ◄  c | ...`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynAIter: User-defined type for `(b <L>)*` iteration in `A -> a a  ► (b <L>)* ◄  c | a c  ► (b <L>)* ◄  c`

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> a a (b <L>)* c
                        4 => self.exit_a(factor_id),                // A -> a c (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a a  ► (b <L>)* ◄  c | ...
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a a  ► (b <L>)* ◄  c | ...
                     /* 0 */                                        // A -> a a (b <L>)* c | a c (b <L>)* c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter1();
                    let a_2 = self.stack_t.pop().unwrap();
                    let a_1 = self.stack_t.pop().unwrap();
                    CtxA::A1 { a: [a_1, a_2], star, c }
                }
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter1();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2], star }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(32) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 8: rules RTS(25) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(25), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a c
                1 => symbols![],                        //  1: A_1 -> # A_1 | ●A_1 ◄1 #     |
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_25_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(25) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_25_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [#]* c`
        A { a: String, c: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [#]* c
                        1 |                                         // [#]* item in A -> a  ► [#]* ◄  c
                        2 => {}                                     // end of [#]* items in A -> a  ► [#]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(25) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 9: rules RTS(23) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(23), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![],                        //  1: A_1 -> b A_2 | ►A_2 b!       |
                2 => symbols![nt 1, t 1],               //  2: A_2 -> A_1   | ●A_1 ◄2       | A_1 b
                3 => symbols![nt 1, t 1],               //  3: A_2 -> ε     | ◄3            | A_1 b
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_23_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(23) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_23_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]+ c`
        A { a: String, plus: SynA1, c: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[b]+` array in `A -> a  ► [b]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]+ c
                        2 |                                         // [b]+ item in A -> a  ► [b]+ ◄  c
                        3 => self.exit_a1(),                        // end of [b]+ items in A -> a  ► [b]+ ◄  c
                     /* 1 */                                        // [b]+ item in A -> a  ► [b]+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }
    }

    // [wrapper source for rule RTS(23) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 10: rules RTS(27) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(27), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![t 1],                     //  1: B -> b       | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B A_2 | ►A_2 ►B       |
                3 => symbols![nt 2, nt 1],              //  3: A_2 -> A_1   | ●A_1 ◄3       | A_1 B
                4 => symbols![nt 2, nt 1],              //  4: A_2 -> ε     | ◄4            | A_1 B
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_27_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(27) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_27_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [B]+ c`
        A { a: String, plus: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynB: User-defined type for `B`
    /// Computed `[B]+` array in `A -> a  ► [B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `B` item in `A -> a  ► [B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { b: SynB }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => {}                                     // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [B]+ c
                        3 |                                         // [B]+ item in A -> a  ► [B]+ ◄  c
                        4 => self.exit_a1(),                        // end of [B]+ items in A -> a  ► [B]+ ◄  c
                     /* 2 */                                        // [B]+ item in A -> a  ► [B]+ ◄  c (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(SynA1Item { b });
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(27) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 11: rules RTS(28) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(28), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, t 2],               //  0: A -> A_1 c     | ◄0 c! ►A_1 | A_1 c
                1 => symbols![t 1],                     //  1: B -> b         | ◄1 b!      | b
                2 => symbols![],                        //  2: A_1 -> a B A_2 | ►A_2 ►B a! |
                3 => symbols![nt 2, t 0, nt 1],         //  3: A_2 -> A_1     | ●A_1 ◄3    | A_1 a B
                4 => symbols![nt 2, t 0, nt 1],         //  4: A_2 -> ε       | ◄4         | A_1 a B
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_28_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(28) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_28_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> [a B]+ c`
        A { plus: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynB: User-defined type for `B`
    /// Computed `[a B]+` array in `A ->  ► [a B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `a B` item in `A ->  ► [a B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { a: String, b: SynB }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => {}                                     // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> [a B]+ c
                        3 |                                         // [a B]+ item in A ->  ► [a B]+ ◄  c
                        4 => self.exit_a1(),                        // end of [a B]+ items in A ->  ► [a B]+ ◄  c
                     /* 2 */                                        // [a B]+ item in A ->  ► [a B]+ ◄  c (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let val = self.listener.exit_a(CtxA::A { plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let a = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(SynA1Item { a, b });
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(28) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 12: rules RTS(24) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b!          |
                2 => symbols![nt 1, t 1],               //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1 b
                3 => symbols![nt 1, t 1],               //  3: A_1 -> ε        | ◄3               | AIter1 b
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_24_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, b: String, last_iteration: bool },
    }

    // NT types:
    // SynMyA: User-defined type for `A`
    // SynMyAIter: User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`

    #[derive(Debug)]
    enum SynValue { A(SynMyA), Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynMyAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, b, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 13: rules RTS(24) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![],                        //  2: A_1 -> AIter1   | ●AIter1 ◄2       |
                3 => symbols![],                        //  3: A_1 -> ε        | ◄3               |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_24_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { last_iteration: bool },
    }

    // NT types:
    // SynMyA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynMyA) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) {}
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.listener.init_aiter1(),           // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            self.listener.exit_aiter1(CtxAiter1::Aiter1 { last_iteration });
        }
    }

    // [wrapper source for rule RTS(24) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 14: rules RTS(24) #3, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![nt 1],                    //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1
                3 => symbols![nt 1],                    //  3: A_1 -> ε        | ◄3               | AIter1
            ], Set(symbols![nt 0, nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #3, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_24_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, last_iteration: bool },
    }

    // NT types:
    // SynMyA: User-defined type for `A`
    // SynMyAIter: User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`

    #[derive(Debug)]
    enum SynValue { A(SynMyA), Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynMyAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 15: rules RTS(24) #4, start 0:
/*
before, NT with value: AIter1
after,  NT with value: AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![nt 1],                    //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1
                3 => symbols![nt 1],                    //  3: A_1 -> ε        | ◄3               | AIter1
            ], Set(symbols![nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_4 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #4, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_24_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, last_iteration: bool },
    }

    // NT types:
    // SynMyAIter: User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
    // Top non-terminal A has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_aiter1(self) -> SynMyAIter {
            let SynValue::Aiter1(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, c });
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #4, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 16: rules RTS(29) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!           | b
                2 => symbols![nt 2, nt 1, t 1],         //  2: A_1 -> B b A_1   | ●A_1 ◄2 b! ►B   | A_1 B b
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, nt 2, t 2],         //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 A_1 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_29_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynB: User-defined type for `B`
    /// Computed `[B b]*` array in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `B b` item in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { b: SynB, b1: String }
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<SynA2Item>);
    /// `[B b]* c` item in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { star: SynA1, c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 => self.exit_a1(),                        // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b1 = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { b, b1 });
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { star, c });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(29) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 17: rules RTS(29) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                0 => "SynA".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![],                        //  1: B -> b           | ◄1 b            |
                2 => symbols![],                        //  2: A_1 -> B b A_1   | ●A_1 ◄2 b ►B    |
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, t 2],               //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], Set(symbols![nt 0, t 0, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_29_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B,
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => {}                                     // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 |                                         // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(c);
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            self.listener.exit_b(CtxB::B);
        }
    }

    // [wrapper source for rule RTS(29) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 18: rules RTS(29) #3, start 0:
/*
before, NT with value:
after,  NT with value: A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!           | b
                2 => symbols![nt 2, t 1],               //  2: A_1 -> B b A_1   | ●A_1 ◄2 b! ►B   | A_1 b
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, nt 2, t 2],         //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 A_1 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], Set(symbols![t 0, t 1, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #3, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    /// Computed `[B b]*` array in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<SynA2Item>);
    /// `[B b]* c` item in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { star: SynA1, c: String }
    // Top non-terminal A has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 => self.exit_a1(),                        // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, star, d });
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { star, c });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule RTS(29) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 19: rules RTS(39) #1, start 0:
/*
before, NT with value: A, AIter2, AIter1
after,  NT with value: A, AIter2, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter2: child_+_or_* | L-form (129)
            //  - AIter1: child_+_or_* | L-form | parent_+_or_* (2177)
            // parents:
            //  - AIter2 -> AIter1
            //  - AIter1 -> A
            (RTS(39), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAiter2".to_string(),
                2 => "SynAiter1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 3],          //  0: A -> a AIter1 d           | ◄0 d! ►AIter1 a!      | a AIter1 d
                1 => symbols![nt 1, t 1],               //  1: AIter2 -> b AIter2        | ●AIter2 ◄1 b!         | AIter2 b
                2 => symbols![nt 1],                    //  2: AIter2 -> ε               | ◄2                    | AIter2
                3 => symbols![nt 2, nt 1, t 2],         //  3: AIter1 -> AIter2 c AIter1 | ●AIter1 ◄3 c! ►AIter2 | AIter1 AIter2 c
                4 => symbols![nt 2],                    //  4: AIter1 -> ε               | ◄4                    | AIter1
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_39_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(39) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_39_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a ((b <L>)* c <L>)* d`
        A { a: String, star: SynAiter1, d: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter2 {
        /// `(b <L>)*` iteration in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
        Aiter2_1 { star_it: SynAiter2, b: String },
        /// end of `(b <L>)*` iterations in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
        Aiter2_2 { star_it: SynAiter2 },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `((b <L>)* c <L>)*` iteration in `A -> a  ► ((b <L>)* c <L>)* ◄  d`
        Aiter1_1 { star_it: SynAiter1, star: SynAiter2, c: String },
        /// end of `((b <L>)* c <L>)*` iterations in `A -> a  ► ((b <L>)* c <L>)* ◄  d`
        Aiter1_2 { star_it: SynAiter1 },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynAiter2: User-defined type for `(b <L>)*` iteration in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
    // SynAiter1: User-defined type for `((b <L>)* c <L>)*` iteration in `A -> a  ► ((b <L>)* c <L>)* ◄  d`

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter2(SynAiter2), Aiter1(SynAiter1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter2(self) -> SynAiter2 {
            if let SynValue::Aiter2(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAiter1 {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter2(&mut self) -> SynAiter2;
        fn exit_aiter2(&mut self, _ctx: CtxAiter2) -> SynAiter2;
        fn init_aiter1(&mut self) -> SynAiter1;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAiter1;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter2(),                    // AIter2
                        2 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a ((b <L>)* c <L>)* d
                        1 |                                         // (b <L>)* iteration in A -> a ( ► (b <L>)* ◄  c <L>)* d
                        2 => self.exit_aiter2(factor_id),           // end of (b <L>)* iterations in A -> a ( ► (b <L>)* ◄  c <L>)* d
                        3 |                                         // ((b <L>)* c <L>)* iteration in A -> a  ► ((b <L>)* c <L>)* ◄  d
                        4 => self.exit_aiter1(factor_id),           // end of ((b <L>)* c <L>)* iterations in A -> a  ► ((b <L>)* c <L>)* ◄  d
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter2(&mut self) {
            let val = self.listener.init_aiter2();
            self.stack.push(SynValue::Aiter2(val));
        }

        fn exit_aiter2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter2();
                    CtxAiter2::Aiter2_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter2();
                    CtxAiter2::Aiter2_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter2")
            };
            let val = self.listener.exit_aiter2(ctx);
            self.stack.push(SynValue::Aiter2(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter2();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, star, c }
                }
                4 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(39) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 20: rules RTS(40) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            //  - A_1: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - AIter1 -> A_1
            //  - A_1 -> A
            (RTS(40), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAiter1".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 3],          //  0: A -> a A_1 d        | ◄0 d! ►A_1 a!      | a A_1 d
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1  | ●AIter1 ◄1 b!      | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε         | ◄2                 | AIter1
                3 => symbols![nt 2, nt 1, t 2],         //  3: A_1 -> AIter1 c A_1 | ●A_1 ◄3 c! ►AIter1 | A_1 AIter1 c
                4 => symbols![],                        //  4: A_1 -> ε            | ◄4                 |
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_40_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(40) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_40_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [(b <L>)* c]* d`
        A { a: String, star: SynA1, d: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a [ ► (b <L>)* ◄  c]* d`
        Aiter1_1 { star_it: SynAiter1, b: String },
        /// end of `(b <L>)*` iterations in `A -> a [ ► (b <L>)* ◄  c]* d`
        Aiter1_2 { star_it: SynAiter1 },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynAiter1: User-defined type for `(b <L>)*` iteration in `A -> a [ ► (b <L>)* ◄  c]* d`
    /// Computed `[(b <L>)* c]*` array in `A -> a  ► [(b <L>)* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `(b <L>)* c` item in `A -> a  ► [(b <L>)* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { star: SynAiter1, c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAiter1), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAiter1 {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAiter1;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAiter1;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => self.init_a1(),                        // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [(b <L>)* c]* d
                        1 |                                         // (b <L>)* iteration in A -> a [ ► (b <L>)* ◄  c]* d
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a [ ► (b <L>)* ◄  c]* d
                        3 => self.exit_a1(),                        // [(b <L>)* c]* item in A -> a  ► [(b <L>)* c]* ◄  d
                        4 => {}                                     // end of [(b <L>)* c]* items in A -> a  ► [(b <L>)* c]* ◄  d
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { star, c });
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule RTS(40) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 21: rules RTS(30) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_3: child_left_fact (64)
            //  - A_4: child_left_fact (64)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            //  - A_3 -> A_1
            //  - A_4 -> A_2
            (RTS(30), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a! | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B b A_3   | ►A_3 b! ►B    |
                3 => symbols![],                        //  3: A_2 -> A_1 c A_4 | ►A_4 c! ►A_1  |
                4 => symbols![nt 2, nt 1, t 1],         //  4: A_3 -> A_1       | ●A_1 ◄4       | A_1 B b
                5 => symbols![nt 2, nt 1, t 1],         //  5: A_3 -> ε         | ◄5            | A_1 B b
                6 => symbols![nt 3, nt 2, t 2],         //  6: A_4 -> A_2       | ●A_2 ◄6       | A_2 A_1 c
                7 => symbols![nt 3, nt 2, t 2],         //  7: A_4 -> ε         | ◄7            | A_2 A_1 c
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_30_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(30) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_30_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]+ c]+ d`
        A { a: String, plus: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    // SynB: User-defined type for `B`
    /// Computed `[B b]+` array in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `B b` item in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { b: SynB, b1: String }
    /// Computed `[[B b]+ c]+` array in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<SynA2Item>);
    /// `[B b]+ c` item in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { plus: SynA1, c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        4 => {}                                     // A_3
                        5 => {}                                     // A_4
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]+ c]+ d
                        4 |                                         // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d
                        5 => self.exit_a1(),                        // end of [B b]+ items in A -> a [ ► [B b]+ ◄  c]+ d
                        6 |                                         // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d
                        7 => self.exit_a2(),                        // end of [[B b]+ c]+ items in A -> a  ► [[B b]+ c]+ ◄  d
                     /* 2 */                                        // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d (never called)
                     /* 3 */                                        // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b1 = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(SynA1Item { b, b1 });
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(SynA2Item { plus, c });
            self.stack.push(SynValue::A2(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(30) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 22: rules RTS(30) #2, start 0:
/*
before, NT with value:
after,  NT with value: A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_3: child_left_fact (64)
            //  - A_4: child_left_fact (64)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            //  - A_3 -> A_1
            //  - A_4 -> A_2
            (RTS(30), 0, btreemap![
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a! | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B b A_3   | ►A_3 b! ►B    |
                3 => symbols![],                        //  3: A_2 -> A_1 c A_4 | ►A_4 c! ►A_1  |
                4 => symbols![nt 2, t 1],               //  4: A_3 -> A_1       | ●A_1 ◄4       | A_1 b
                5 => symbols![nt 2, t 1],               //  5: A_3 -> ε         | ◄5            | A_1 b
                6 => symbols![nt 3, nt 2, t 2],         //  6: A_4 -> A_2       | ●A_2 ◄6       | A_2 A_1 c
                7 => symbols![nt 3, nt 2, t 2],         //  7: A_4 -> ε         | ◄7            | A_2 A_1 c
            ], Set(symbols![t 0, t 1, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_30_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(30) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]+ c]+ d`
        A { a: String, plus: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    /// Computed `[B b]+` array in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);
    /// Computed `[[B b]+ c]+` array in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<SynA2Item>);
    /// `[B b]+ c` item in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { plus: SynA1, c: String }
    // Top non-terminal A has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        4 => {}                                     // A_3
                        5 => {}                                     // A_4
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]+ c]+ d
                        4 |                                         // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d
                        5 => self.exit_a1(),                        // end of [B b]+ items in A -> a [ ► [B b]+ ◄  c]+ d
                        6 |                                         // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d
                        7 => self.exit_a2(),                        // end of [[B b]+ c]+ items in A -> a  ► [[B b]+ c]+ ◄  d
                     /* 2 */                                        // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d (never called)
                     /* 3 */                                        // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, d });
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(SynA2Item { plus, c });
            self.stack.push(SynValue::A2(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule RTS(30) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 23: rules RTS(34) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1, A_2, A_3, A_4, A_5, A_6
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_3: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_4: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_5: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_6: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_7: child_left_fact (64)
            //  - A_8: child_left_fact (64)
            //  - A_9: child_left_fact (64)
            //  - A_10: child_left_fact (64)
            //  - A_11: child_left_fact (64)
            //  - A_12: child_left_fact (64)
            // parents:
            //  - A_1 -> A_3
            //  - A_2 -> A
            //  - A_3 -> A
            //  - A_4 -> A_6
            //  - A_5 -> A
            //  - A_6 -> A
            //  - A_7 -> A_1
            //  - A_8 -> A_2
            //  - A_9 -> A_3
            //  - A_10 -> A_4
            //  - A_11 -> A_5
            //  - A_12 -> A_6
            (RTS(34), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
                2 => "SynA2".to_string(),
                3 => "SynA3".to_string(),
                4 => "SynA4".to_string(),
                5 => "SynA5".to_string(),
                6 => "SynA6".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 2, nt 6, t 3], //  0: A -> a A_3 c A_6 d  | ◄0 d! ►A_6 c! ►A_3 a! | a A_3 c A_6 d
                1 => symbols![],                          //  1: A_1 -> b A_7        | ►A_7 b!               |
                2 => symbols![],                          //  2: A_2 -> b A_8        | ►A_8 b!               |
                3 => symbols![],                          //  3: A_3 -> A_1 A_2 A_9  | ►A_9 ►A_2 ►A_1        |
                4 => symbols![],                          //  4: A_4 -> b A_10       | ►A_10 b!              |
                5 => symbols![],                          //  5: A_5 -> b A_11       | ►A_11 b!              |
                6 => symbols![],                          //  6: A_6 -> A_4 A_5 A_12 | ►A_12 ►A_5 ►A_4       |
                7 => symbols![nt 1, t 1],                 //  7: A_7 -> A_1          | ●A_1 ◄7               | A_1 b
                8 => symbols![nt 1, t 1],                 //  8: A_7 -> ε            | ◄8                    | A_1 b
                9 => symbols![nt 2, t 1],                 //  9: A_8 -> A_2          | ●A_2 ◄9               | A_2 b
                10 => symbols![nt 2, t 1],                // 10: A_8 -> ε            | ◄10                   | A_2 b
                11 => symbols![nt 3, nt 1, nt 2],         // 11: A_9 -> A_3          | ●A_3 ◄11              | A_3 A_1 A_2
                12 => symbols![nt 3, nt 1, nt 2],         // 12: A_9 -> ε            | ◄12                   | A_3 A_1 A_2
                13 => symbols![nt 4, t 1],                // 13: A_10 -> A_4         | ●A_4 ◄13              | A_4 b
                14 => symbols![nt 4, t 1],                // 14: A_10 -> ε           | ◄14                   | A_4 b
                15 => symbols![nt 5, t 1],                // 15: A_11 -> A_5         | ●A_5 ◄15              | A_5 b
                16 => symbols![nt 5, t 1],                // 16: A_11 -> ε           | ◄16                   | A_5 b
                17 => symbols![nt 6, nt 4, nt 5],         // 17: A_12 -> A_6         | ●A_6 ◄17              | A_6 A_4 A_5
                18 => symbols![nt 6, nt 4, nt 5],         // 18: A_12 -> ε           | ◄18                   | A_6 A_4 A_5
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_34_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(34) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_34_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[b]+ [b]+]+ c [[b]+ [b]+]+ d`
        A { a: String, plus: SynA3, c: String, plus1: SynA6, d: String },
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[b]+` array in `A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);
    /// Computed `[b]+` array in `A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(Vec<String>);
    /// Computed `[[b]+ [b]+]+` array in `A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA3(Vec<SynA3Item>);
    /// `[b]+ [b]+` item in `A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA3Item { plus: SynA1, plus1: SynA2 }
    /// Computed `[b]+` array in `A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA4(Vec<String>);
    /// Computed `[b]+` array in `A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA5(Vec<String>);
    /// Computed `[[b]+ [b]+]+` array in `A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA6(Vec<SynA6Item>);
    /// `[b]+ [b]+` item in `A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA6Item { plus: SynA4, plus1: SynA5 }

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1), A2(SynA2), A3(SynA3), A4(SynA4), A5(SynA5), A6(SynA6) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
        fn get_a3(self) -> SynA3 {
            if let SynValue::A3(val) = self { val } else { panic!() }
        }
        fn get_a4(self) -> SynA4 {
            if let SynValue::A4(val) = self { val } else { panic!() }
        }
        fn get_a5(self) -> SynA5 {
            if let SynValue::A5(val) = self { val } else { panic!() }
        }
        fn get_a6(self) -> SynA6 {
            if let SynValue::A6(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => self.init_a2(),                        // A_2
                        3 => self.init_a3(),                        // A_3
                        4 => self.init_a4(),                        // A_4
                        5 => self.init_a5(),                        // A_5
                        6 => self.init_a6(),                        // A_6
                        7 => {}                                     // A_7
                        8 => {}                                     // A_8
                        9 => {}                                     // A_9
                        10 => {}                                    // A_10
                        11 => {}                                    // A_11
                        12 => {}                                    // A_12
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[b]+ [b]+]+ c [[b]+ [b]+]+ d
                        7 |                                         // [b]+ item in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d
                        8 => self.exit_a1(),                        // end of [b]+ items in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d
                        9 |                                         // [b]+ item in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d
                        10 => self.exit_a2(),                       // end of [b]+ items in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d
                        11 |                                        // [[b]+ [b]+]+ item in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d
                        12 => self.exit_a3(),                       // end of [[b]+ [b]+]+ items in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d
                        13 |                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d
                        14 => self.exit_a4(),                       // end of [b]+ items in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d
                        15 |                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d
                        16 => self.exit_a5(),                       // end of [b]+ items in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d
                        17 |                                        // [[b]+ [b]+]+ item in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d
                        18 => self.exit_a6(),                       // end of [[b]+ [b]+]+ items in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d
                     /* 1 */                                        // [b]+ item in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d (never called)
                     /* 2 */                                        // [b]+ item in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d (never called)
                     /* 3 */                                        // [[b]+ [b]+]+ item in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d (never called)
                     /* 4 */                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d (never called)
                     /* 5 */                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d (never called)
                     /* 6 */                                        // [[b]+ [b]+]+ item in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus1 = self.stack.pop().unwrap().get_a6();
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a3();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c, plus1, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(b);
            self.stack.push(SynValue::A2(plus_it));
        }

        fn init_a3(&mut self) {
            let val = SynA3(Vec::new());
            self.stack.push(SynValue::A3(val));
        }

        fn exit_a3(&mut self) {
            let plus1 = self.stack.pop().unwrap().get_a2();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a3();
            plus_it.0.push(SynA3Item { plus, plus1 });
            self.stack.push(SynValue::A3(plus_it));
        }

        fn init_a4(&mut self) {
            let val = SynA4(Vec::new());
            self.stack.push(SynValue::A4(val));
        }

        fn exit_a4(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a4();
            plus_it.0.push(b);
            self.stack.push(SynValue::A4(plus_it));
        }

        fn init_a5(&mut self) {
            let val = SynA5(Vec::new());
            self.stack.push(SynValue::A5(val));
        }

        fn exit_a5(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a5();
            plus_it.0.push(b);
            self.stack.push(SynValue::A5(plus_it));
        }

        fn init_a6(&mut self) {
            let val = SynA6(Vec::new());
            self.stack.push(SynValue::A6(val));
        }

        fn exit_a6(&mut self) {
            let plus1 = self.stack.pop().unwrap().get_a5();
            let plus = self.stack.pop().unwrap().get_a4();
            let mut plus_it = self.stack.pop().unwrap().get_a6();
            plus_it.0.push(SynA6Item { plus, plus1 });
            self.stack.push(SynValue::A6(plus_it));
        }
    }

    // [wrapper source for rule RTS(34) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 24: rules PRS(28) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact (32)
            //  - A_1: parent_left_fact | child_left_fact (96)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (PRS(28), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1   | ►A_1 a! |
                1 => symbols![t 4],                     //  1: A -> e       | ◄1 e!   | e
                2 => symbols![],                        //  2: A_1 -> b A_2 | ►A_2 b! |
                3 => symbols![t 0],                     //  3: A_1 -> ε     | ◄3      | a
                4 => symbols![t 0, t 1, t 2],           //  4: A_2 -> c     | ◄4 c!   | a b c
                5 => symbols![t 0, t 1, t 3],           //  5: A_2 -> d     | ◄5 d!   | a b d
                6 => symbols![t 0, t 1],                //  6: A_2 -> ε     | ◄6      | a b
            ], Default, btreemap![0 => vec![1, 3, 4, 5, 6]]),
*/
pub(crate) mod rules_prs_28_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(28) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_28_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> e`
        A1 { e: String },
        /// `A -> a`
        A2 { a: String },
        /// `A -> a b c`
        A3 { a: String, b: String, c: String },
        /// `A -> a b d`
        A4 { a: String, b: String, d: String },
        /// `A -> a b`
        A5 { a: String, b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        1 |                                         // A -> e
                        3 |                                         // A -> a
                        4 |                                         // A -> a b c
                        5 |                                         // A -> a b d
                        6 => self.exit_a(factor_id),                // A -> a b
                     /* 0 */                                        // A -> a | a b | a b c | a b d (never called)
                     /* 2 */                                        // A -> a b | a b c | a b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    CtxA::A1 { e }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a, b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A4 { a, b, d }
                }
                6 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A5 { a, b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(28) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 25: rules PRS(31) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(31), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!        | id
                2 => symbols![nt 0, t 1],               //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | E id
                3 => symbols![nt 0],                    //  3: E_1 -> ε        | ◄3            | E
            ], Default, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_31_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(31) #1, start E]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_31_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> E . id`
        E2 { e: SynE, id: String },
        /// end of iterations in E -> E . id
        E3 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types:
    // SynE: User-defined type for `E`
    // SynF: User-defined type for `F`

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_e(),                         // E -> F
                        2 |                                         // E -> E . id
                        3 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn init_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, id }
                }
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(31) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 26: rules PRS(31) #2, start 0:
/*
before, NT with value: F
after,  NT with value: F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(31), 0, btreemap![
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!        | id
                2 => symbols![t 1],                     //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | id
                3 => symbols![],                        //  3: E_1 -> ε        | ◄3            |
            ], Set(symbols![nt 1, t 1]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_31_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(31) #2, start E]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_31_2::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> E . id`
        E2 { id: String },
        /// end of iterations in E -> E . id
        E3,
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types:
    // SynF: User-defined type for `F`
    // Top non-terminal E has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynE();

    #[derive(Debug)]
    enum SynValue { F(SynF) }

    impl SynValue {
        fn get_f(self) -> SynF {
            let SynValue::F(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_e(),                         // E -> F
                        2 |                                         // E -> E . id
                        3 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn init_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            self.listener.exit_e(CtxE::E1 { f });
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E2 { id }
                }
                3 => {
                    CtxE::E3
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            self.listener.exit_e(ctx);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(31) #2, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 27: rules PRS(36) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(36), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 2],                     //  1: E -> num E_1    | ►E_1 ◄1 num!  | num
                2 => symbols![t 1],                     //  2: F -> id         | ◄2 id!        | id
                3 => symbols![nt 0, t 1],               //  3: E_1 -> . id E_1 | ●E_1 ◄3 id! . | E id
                4 => symbols![nt 0],                    //  4: E_1 -> ε        | ◄4            | E
            ], Default, btreemap![0 => vec![0, 1], 1 => vec![2]]),
*/
pub(crate) mod rules_prs_36_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(36) #1, start E]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_36_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> num`
        E2 { num: String },
        /// `E -> E . id`
        E3 { e: SynE, id: String },
        /// end of iterations in E -> E . id
        E4 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types:
    // SynE: User-defined type for `E`
    // SynF: User-defined type for `F`

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // E -> F
                        1 => self.init_e(factor_id),                // E -> num
                        3 |                                         // E -> E . id
                        4 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        2 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn init_e(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let f = self.stack.pop().unwrap().get_f();
                    CtxE::E1 { f }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E2 { num }
                }
                _ => panic!("unexpected factor id {factor_id} in fn init_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, id }
                }
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(36) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 28: rules PRS(33) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(33), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(33) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// end of iterations in A -> A a
        A2 { a: SynA },
        /// `A -> b c`
        A3 { b: String, c: String },
        /// `A -> b d`
        A4 { b: String, d: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> b c
                        4 => self.init_a(factor_id),                // A -> b d
                        1 |                                         // A -> A a
                        2 => self.exit_a1(factor_id),               // end of iterations in A -> A a
                     /* 0 */                                        // A -> b c | b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A4 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn init_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                2 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(33) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 29: rules PRS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0, t 1],               //  2: A_1 -> b A_1 | ●A_1 ◄2 b! | A b
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![t 1, t 2],                //  4: A_2 -> c A_1 | ►A_1 ◄4 c! | b c
                5 => symbols![t 1, t 3],                //  5: A_2 -> d A_1 | ►A_1 ◄5 d! | b d
            ], Default, btreemap![0 => vec![4, 5]]),
*/
pub(crate) mod rules_prs_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(38) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// `A -> A b`
        A2 { a: SynA, b: String },
        /// end of iterations in A -> A a | A b
        A3 { a: SynA },
        /// `A -> b c`
        A4 { b: String, c: String },
        /// `A -> b d`
        A5 { b: String, d: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        4 |                                         // A -> b c
                        5 => self.init_a(factor_id),                // A -> b d
                        1 |                                         // A -> A a
                        2 |                                         // A -> A b
                        3 => self.exit_a1(factor_id),               // end of iterations in A -> A a | A b
                     /* 0 */                                        // A -> b c | b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A4 { b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A5 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn init_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, b }
                }
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 30: rules PRS(39) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (PRS(39), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![],                        //  1: A_1 -> a A_3 | ►A_3 a!    |
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
                5 => symbols![nt 0, t 0, t 1],          //  5: A_3 -> b A_1 | ●A_1 ◄5 b! | A a b
                6 => symbols![nt 0, t 0, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A a c
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_39_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(39) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_39_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// end of iterations in A -> A a b | A a c
        A1 { a: SynA },
        /// `A -> b c`
        A2 { b: String, c: String },
        /// `A -> b d`
        A3 { b: String, d: String },
        /// `A -> A a b`
        A4 { a: SynA, a1: String, b: String },
        /// `A -> A a c`
        A5 { a: SynA, a1: String, c: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> b c
                        4 => self.init_a(factor_id),                // A -> b d
                        2 |                                         // end of iterations in A -> A a b | A a c
                        5 |                                         // A -> A a b
                        6 => self.exit_a1(factor_id),               // A -> A a c
                     /* 0 */                                        // A -> b c | b d (never called)
                     /* 1 */                                        // A -> A a b | A a c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A2 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn init_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a }
                }
                5 => {
                    let b = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, a1, b }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a, a1, c }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(39) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 31: rules PRS(32) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec | parent_left_fact (36)
            //  - E_2: child_left_fact (64)
            // parents:
            //  - E_1 -> E
            //  - E_2 -> E_1
            (PRS(32), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F  | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!      | id
                2 => symbols![],                        //  2: E_1 -> . id E_2 | ►E_2 id! .  |
                3 => symbols![nt 0],                    //  3: E_1 -> ε        | ◄3          | E
                4 => symbols![nt 0, t 1],               //  4: E_2 -> ( ) E_1  | ●E_1 ◄4 ) ( | E id
                5 => symbols![nt 0, t 1],               //  5: E_2 -> E_1      | ●E_1 ◄5     | E id
            ], Default, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_32_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(32) #1, start E]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_32_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// end of iterations in E -> E . id ( ) | E . id
        E2 { e: SynE },
        /// `E -> E . id ( )`
        E3 { e: SynE, id: String },
        /// `E -> E . id`
        E4 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types:
    // SynE: User-defined type for `E`
    // SynF: User-defined type for `F`

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        3 => {}                                     // E_2
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_e(),                         // E -> F
                        3 |                                         // end of iterations in E -> E . id ( ) | E . id
                        4 |                                         // E -> E . id ( )
                        5 => self.exit_e1(factor_id),               // E -> E . id
                     /* 2 */                                        // E -> E . id ( ) | E . id (never called)
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn init_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, id }
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e, id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(32) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 32: rules RTS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a!    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b!    |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0, t 0, t 2],          //  4: A_2 -> c A_1 | ●A_1 ◄4 c! | A a c
                5 => symbols![nt 0, t 0],               //  5: A_2 -> A_1   | ●A_1 ◄5    | A a
                6 => symbols![nt 0, t 1, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A b c
                7 => symbols![nt 0, t 1],               //  7: A_3 -> A_1   | ●A_1 ◄7    | A b
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2 { a: SynA },
        /// `A -> A a c`
        A3 { a: SynA, a1: String, c: String },
        /// `A -> A a`
        A4 { a: SynA, a1: String },
        /// `A -> A b c`
        A5 { a: SynA, b: String, c: String },
        /// `A -> A b`
        A6 { a: SynA, b: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_a(),                         // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a, a1, c }
                }
                5 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, a1 }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a, b, c }
                }
                7 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A6 { a, b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 33: rules RTS(38) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a     |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b     |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0],                    //  4: A_2 -> c A_1 | ●A_1 ◄4 c  | A
                5 => symbols![nt 0],                    //  5: A_2 -> A_1   | ●A_1 ◄5    | A
                6 => symbols![nt 0],                    //  6: A_3 -> c A_1 | ●A_1 ◄6 c  | A
                7 => symbols![nt 0],                    //  7: A_3 -> A_1   | ●A_1 ◄7    | A
            ], Set(symbols![nt 0, t 3]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #2, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_38_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2 { a: SynA },
        /// `A -> A a c`
        A3 { a: SynA },
        /// `A -> A a`
        A4 { a: SynA },
        /// `A -> A b c`
        A5 { a: SynA },
        /// `A -> A b`
        A6 { a: SynA },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_a(),                         // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                4 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a }
                }
                6 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a }
                }
                7 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A6 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(38) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 34: rules RTS(38) #3, start 0:
/*
before, NT with value:
after,  NT with value:
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
            ], btreemap![
                0 => symbols![],                        //  0: A -> d A_1   | ►A_1 ◄0 d |
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b    |
                3 => symbols![],                        //  3: A_1 -> ε     | ◄3        |
                4 => symbols![],                        //  4: A_2 -> c A_1 | ●A_1 ◄4 c |
                5 => symbols![],                        //  5: A_2 -> A_1   | ●A_1 ◄5   |
                6 => symbols![],                        //  6: A_3 -> c A_1 | ●A_1 ◄6 c |
                7 => symbols![],                        //  7: A_3 -> A_1   | ●A_1 ◄7   |
            ], Set(symbols![]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #3, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_38_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1,
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2,
        /// `A -> A a c`
        A3,
        /// `A -> A a`
        A4,
        /// `A -> A b c`
        A5,
        /// `A -> A b`
        A6,
    }

    // NT types:
    // Top non-terminal A has no value:
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_a(),                         // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn init_a(&mut self) {
            self.listener.exit_a(CtxA::A1);
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    CtxA::A2
                }
                4 => {
                    CtxA::A3
                }
                5 => {
                    CtxA::A4
                }
                6 => {
                    CtxA::A5
                }
                7 => {
                    CtxA::A6
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            self.listener.exit_a(ctx);
        }
    }

    // [wrapper source for rule RTS(38) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 35: rules PRS(20) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec (2)
            // parents:
            //  - (nothing)
            (PRS(20), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![t 5, t 5, nt 1],          //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id LIST
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_20_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(20) #1, start STRUCT]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_20_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST`
        List1 { id: [String; 2], list: SynList },
        /// `LIST -> }`
        List2,
    }

    // NT types:
    // SynStruct: User-defined type for `STRUCT`
    // SynList: User-defined type for `LIST`

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct1(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _struct1: SynStruct) {}
        fn init_struct1(&mut self) {}
        fn exit_struct1(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct1(),          // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct1(),                   // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST
                        2 => self.exit_list(factor_id),             // LIST -> }
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct1();
            self.listener.exit(struct1);
        }

        fn exit_struct1(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct1(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let list = self.stack.pop().unwrap().get_list();
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2], list }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(20) #1, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 36: rules PRS(20) #2, start 0:
/*
before, NT with value: STRUCT
after,  NT with value: STRUCT
            // NT flags:
            //  - LIST: right_rec (2)
            // parents:
            //  - (nothing)
            (PRS(20), 0, btreemap![
                0 => "SynStruct".to_string(),
            ], btreemap![
                0 => symbols![t 5],                     //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id
                1 => symbols![t 5, t 5],                //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Set(symbols![nt 0, t 5]), btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_20_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(20) #2, start STRUCT]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_20_2::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST`
        List1 { id: [String; 2] },
        /// `LIST -> }`
        List2,
    }

    // NT types:
    // SynStruct: User-defined type for `STRUCT`

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct) }

    impl SynValue {
        fn get_struct1(self) -> SynStruct {
            let SynValue::Struct(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _struct1: SynStruct) {}
        fn init_struct1(&mut self) {}
        fn exit_struct1(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct1(),          // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct1(),                   // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST
                        2 => self.exit_list(factor_id),             // LIST -> }
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct1();
            self.listener.exit(struct1);
        }

        fn exit_struct1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct1(CtxStruct::Struct { id });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2] }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            self.listener.exit_list(ctx);
        }
    }

    // [wrapper source for rule PRS(20) #2, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 37: rules PRS(37) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec | parent_left_fact (34)
            //  - LIST_1: child_left_fact (64)
            // parents:
            //  - LIST_1 -> LIST
            (PRS(37), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![],                        //  1: LIST -> }                  | ◄1 }                  |
                2 => symbols![],                        //  2: LIST -> id LIST_1          | ►LIST_1 id!           |
                3 => symbols![t 5, t 5],                //  3: LIST_1 -> : id ; LIST      | ●LIST ◄3 ; id! :      | id id
                4 => symbols![t 5],                     //  4: LIST_1 -> ; LIST           | ●LIST ◄4 ;            | id
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 3, 4]]),
*/
pub(crate) mod rules_prs_37_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(37) #1, start STRUCT]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_37_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> }`
        List1,
        /// `LIST -> id : id ; LIST`
        List2 { id: [String; 2] },
        /// `LIST -> id ; LIST`
        List3 { id: String },
    }

    // NT types:
    // SynStruct: User-defined type for `STRUCT`
    // SynList: User-defined type for `LIST`

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct1(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _struct1: SynStruct) {}
        fn init_struct1(&mut self) {}
        fn exit_struct1(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct1(),          // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        2 => {}                                     // LIST_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct1(),                   // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> }
                        3 |                                         // LIST -> id : id ; LIST
                        4 => self.exit_list(factor_id),             // LIST -> id ; LIST
                     /* 2 */                                        // LIST -> id : id ; LIST | id ; LIST (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct1();
            self.listener.exit(struct1);
        }

        fn exit_struct1(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct1(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    CtxList::List1
                }
                3 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List2 { id: [id_1, id_2] }
                }
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxList::List3 { id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(37) #1, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 38: rules PRS(30) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec | L-form (130)
            // parents:
            //  - (nothing)
            (PRS(30), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![nt 1, t 5, t 5],          //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | LIST id id
                2 => symbols![nt 1],                    //  2: LIST -> }                  | ◄2 }                  | LIST
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_30_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(30) #1, start STRUCT]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_30_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST <L>`
        List1 { list: SynList, id: [String; 2] },
        /// `LIST -> } <L>`
        List2 { list: SynList },
    }

    // NT types:
    // SynStruct: User-defined type for `STRUCT`
    // SynList: User-defined type for `LIST`

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct1(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _struct1: SynStruct) {}
        fn init_struct1(&mut self) {}
        fn exit_struct1(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) -> SynList;
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct1(),          // STRUCT
                        1 => self.init_list(),                      // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct1(),                   // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST <L>
                        2 => self.exit_list(factor_id),             // LIST -> } <L>
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct1();
            self.listener.exit(struct1);
        }

        fn exit_struct1(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct1(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn init_list(&mut self) {
            let val = self.listener.init_list();
            self.stack.push(SynValue::List(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    let list = self.stack.pop().unwrap().get_list();
                    CtxList::List1 { list, id: [id_1, id_2] }
                }
                2 => {
                    let list = self.stack.pop().unwrap().get_list();
                    CtxList::List2 { list }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(30) #1, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 39: rules PRS(30) #2, start 0:
/*
before, NT with value: STRUCT
after,  NT with value: STRUCT
            // NT flags:
            //  - LIST: right_rec | L-form (130)
            // parents:
            //  - (nothing)
            (PRS(30), 0, btreemap![
                0 => "SynStruct".to_string(),
            ], btreemap![
                0 => symbols![t 5],                     //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id
                1 => symbols![t 5, t 5],                //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | id id
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Set(symbols![nt 0, t 5]), btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_30_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(30) #2, start STRUCT]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_30_2::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST <L>`
        List1 { id: [String; 2] },
        /// `LIST -> } <L>`
        List2,
    }

    // NT types:
    // SynStruct: User-defined type for `STRUCT`

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct) }

    impl SynValue {
        fn get_struct1(self) -> SynStruct {
            let SynValue::Struct(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _struct1: SynStruct) {}
        fn init_struct1(&mut self) {}
        fn exit_struct1(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) {}
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct1(),          // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct1(),                   // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST <L>
                        2 => self.exit_list(factor_id),             // LIST -> } <L>
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct1();
            self.listener.exit(struct1);
        }

        fn exit_struct1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct1(CtxStruct::Struct { id });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2] }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            self.listener.exit_list(ctx);
        }
    }

    // [wrapper source for rule PRS(30) #2, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 40: rules RTS(26) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* (2560)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_left_rec (4)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (RTS(26), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![nt 1, t 2],               //  1: A_1 -> c A_1     | ●A_1 ◄1 c!      | A_1 c
                2 => symbols![],                        //  2: A_1 -> ε         | ◄2              |
                3 => symbols![nt 0, nt 1, t 1],         //  3: A_2 -> A_1 b A_2 | ●A_2 ◄3 b! ►A_1 | A A_1 b
                4 => symbols![nt 0],                    //  4: A_2 -> ε         | ◄4              | A
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_26_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(26) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_26_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A [c]* b`
        A2 { a: SynA, star: SynA1, b: String },
        /// end of iterations in A -> A [c]* b
        A3 { a: SynA },
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[c]*` array in `A -> a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_a(),                         // A -> a
                        1 => self.exit_a1(),                        // [c]* item in A -> A  ► [c]* ◄  b
                        2 => {}                                     // end of [c]* items in A -> A  ► [c]* ◄  b
                        3 |                                         // A -> A [c]* b
                        4 => self.exit_a2(factor_id),               // end of iterations in A -> A [c]* b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(c);
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_a2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, star, b }
                }
                4 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(26) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 41: rules RTS(16) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* | plus (6656)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_rec (4)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (RTS(16), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![],                        //  1: A_1 -> c A_3     | ►A_3 c!         |
                2 => symbols![nt 0, nt 1, t 1],         //  2: A_2 -> A_1 b A_2 | ●A_2 ◄2 b! ►A_1 | A A_1 b
                3 => symbols![nt 0],                    //  3: A_2 -> ε         | ◄3              | A
                4 => symbols![nt 1, t 2],               //  4: A_3 -> A_1       | ●A_1 ◄4         | A_1 c
                5 => symbols![nt 1, t 2],               //  5: A_3 -> ε         | ◄5              | A_1 c
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_16_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(16) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_16_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A [c]+ b`
        A2 { a: SynA, plus: SynA1, b: String },
        /// end of iterations in A -> A [c]+ b
        A3 { a: SynA },
    }

    // NT types:
    // SynA: User-defined type for `A`
    /// Computed `[c]+` array in `A -> a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.init_a(),                         // A -> a
                        4 |                                         // [c]+ item in A -> A  ► [c]+ ◄  b
                        5 => self.exit_a1(),                        // end of [c]+ items in A -> A  ► [c]+ ◄  b
                        2 |                                         // A -> A [c]+ b
                        3 => self.exit_a2(factor_id),               // end of iterations in A -> A [c]+ b
                     /* 1 */                                        // [c]+ item in A -> A  ► [c]+ ◄  b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(c);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, plus, b }
                }
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(16) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 42: rules PRS(35) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact (32)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            (PRS(35), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1 | ►A_1 a!  |
                1 => symbols![t 0, t 1, t 1],           //  1: A_1 -> b b | ◄1 b! b! | a b b
                2 => symbols![t 0, t 2, t 2],           //  2: A_1 -> c c | ◄2 c! c! | a c c
                3 => symbols![t 0],                     //  3: A_1 -> ε   | ◄3       | a
            ], Default, btreemap![0 => vec![1, 2, 3]]),
*/
pub(crate) mod rules_prs_35_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(35) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_prs_35_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a b b`
        A1 { a: String, b: [String; 2] },
        /// `A -> a c c`
        A2 { a: String, c: [String; 2] },
        /// `A -> a`
        A3 { a: String },
    }

    // NT types:
    // SynA: User-defined type for `A`

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        1 |                                         // A -> a b b
                        2 |                                         // A -> a c c
                        3 => self.exit_a(factor_id),                // A -> a
                     /* 0 */                                        // A -> a | a b b | a c c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b_2 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A1 { a, b: [b_1, b_2] }
                }
                2 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2] }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(35) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 43: rules RTS(33) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(33), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, t 1],               //  0: A -> A_1 b     | ◄0 b! ►A_1    | A_1 b
                1 => symbols![t 0],                     //  1: A -> a         | ◄1 a!         | a
                2 => symbols![t 1],                     //  2: B -> b         | ◄2 b!         | b
                3 => symbols![nt 2, nt 1, t 2],         //  3: A_1 -> B c A_1 | ●A_1 ◄3 c! ►B | A_1 B c
                4 => symbols![],                        //  4: A_1 -> ε       | ◄4            |
            ], All, btreemap![0 => vec![0, 1], 1 => vec![2]]),
*/
pub(crate) mod rules_rts_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(33) #1, start A]

    use rlexer::{CollectJoin, grammar::{FactorId, VarId}, parser::{Call, Listener}};
    use super::super::wrapper_code::code_rts_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> [B c]* b`
        A1 { star: SynA1, b: String },
        /// `A -> a`
        A2 { a: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types:
    // SynMyA: User-defined type for `A`
    // SynB: User-defined type for `B`
    /// Computed `[B c]*` array in `A ->  ► [B c]* ◄  b`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(Vec<SynA1Item>);
    /// `B c` item in `A ->  ► [B c]* ◄  b`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { b: SynB, c: String }

    #[derive(Debug)]
    enum SynValue { A(SynMyA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // A -> [B c]* b
                        1 => self.exit_a(factor_id),                // A -> a
                        3 => self.exit_a1(),                        // [B c]* item in A ->  ► [B c]* ◄  b
                        4 => {}                                     // end of [B c]* items in A ->  ► [B c]* ◄  b
                        2 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }
    }

    impl<T: TestListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    CtxA::A1 { star, b }
                }
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { b, c });
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(33) #1, start A]
    // ------------------------------------------------------------
}
