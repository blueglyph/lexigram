// Copyright (c) 2025 Redglyph (@gmail.com). All Rights Reserved.

#![cfg(test)]
//#![allow(non_camel_case_types)]
#![allow(dead_code)]

// Most of the code below is generated by parsergen::tests::wrapper_source::build_items.
// Some of those wrappers are tested in crate::integration::wrappers.

// ================================================================================

pub(crate) mod rules_13_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 13 #1, start s]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_13_1::*;

    #[derive(Debug)]
    pub enum CtxS {
        /// `s -> Id "=" val`
        V1 { id: String, val: SynVal },
        /// `s -> "exit"`
        V2,
        /// `s -> "return" val`
        V3 { val: SynVal },
    }
    #[derive(Debug)]
    pub enum CtxVal {
        /// `val -> Id`
        V1 { id: String },
        /// `val -> Num`
        V2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `s`
    // #[derive(Debug, PartialEq)] pub struct SynS();
    // /// User-defined type for `val`
    // #[derive(Debug, PartialEq)] pub struct SynVal();

    #[derive(Debug)]
    enum SynValue { S(SynS), Val(SynVal) }

    impl SynValue {
        fn get_s(self) -> SynS {
            if let SynValue::S(val) = self { val } else { panic!() }
        }
        fn get_val(self) -> SynVal {
            if let SynValue::Val(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, s: SynS, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_s(&mut self) {}
        fn exit_s(&mut self, ctx: CtxS, spans: Vec<PosSpan>) -> SynS;
        fn init_val(&mut self) {}
        fn exit_val(&mut self, ctx: CtxVal, spans: Vec<PosSpan>) -> SynVal;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_s(),                // s
                        1 => self.listener.init_val(),              // val
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // s -> Id "=" val
                        1 |                                         // s -> "exit"
                        2 => self.exit_s(alt_id),                   // s -> "return" val
                        3 |                                         // val -> Id
                        4 => self.exit_val(alt_id),                 // val -> Num
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_s();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_s(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let val = self.stack.pop().unwrap().get_val();
                    let id = self.stack_t.pop().unwrap();
                    (3, CtxS::V1 { id, val })
                }
                1 => {
                    (1, CtxS::V2)
                }
                2 => {
                    let val = self.stack.pop().unwrap().get_val();
                    (2, CtxS::V3 { val })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_s")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_s(ctx, spans);
            self.stack.push(SynValue::S(val));
        }

        fn exit_val(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxVal::V1 { id })
                }
                4 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxVal::V2 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_val")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_val(ctx, spans);
            self.stack.push(SynValue::Val(val));
        }
    }

    // [wrapper source for rule 13 #1, start s]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_14_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 14 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_14_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> b c`
        V1 { b: SynB, c: SynC },
        /// `a -> c`
        V2 { c: SynC },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> Op c`
        V1 { op: String, c: SynC },
    }
    #[derive(Debug)]
    pub enum CtxC {
        /// `c -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    // /// User-defined type for `c`
    // #[derive(Debug, PartialEq)] pub struct SynC();

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), C(SynC) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_c(self) -> SynC {
            if let SynValue::C(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
        fn init_c(&mut self) {}
        fn exit_c(&mut self, ctx: CtxC, spans: Vec<PosSpan>) -> SynC;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_b(),                // b
                        2 => self.listener.init_c(),                // c
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> b c
                        1 => self.exit_a(alt_id),                   // a -> c
                        2 => self.exit_b(),                         // b -> Op c
                        3 => self.exit_c(),                         // c -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let c = self.stack.pop().unwrap().get_c();
                    let b = self.stack.pop().unwrap().get_b();
                    (2, CtxA::V1 { b, c })
                }
                1 => {
                    let c = self.stack.pop().unwrap().get_c();
                    (1, CtxA::V2 { c })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let c = self.stack.pop().unwrap().get_c();
            let op = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { op, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }

        fn exit_c(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxC::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_c(ctx, spans);
            self.stack.push(SynValue::C(val));
        }
    }

    // [wrapper source for rule 14 #1, start a]
    // ------------------------------------------------------------
}

pub(crate) mod rules_14_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 14 #2, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_14_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> b c`
        V1 { b: SynB },
        /// `a -> c`
        V2,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> Op c`
        V1 { op: String },
    }
    #[derive(Debug)]
    pub enum CtxC {
        /// `c -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
        fn init_c(&mut self) {}
        #[allow(unused_variables)]
        fn exit_c(&mut self, ctx: CtxC, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_b(),                // b
                        2 => self.listener.init_c(),                // c
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> b c
                        1 => self.exit_a(alt_id),                   // a -> c
                        2 => self.exit_b(),                         // b -> Op c
                        3 => self.exit_c(),                         // c -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let b = self.stack.pop().unwrap().get_b();
                    (2, CtxA::V1 { b })
                }
                1 => {
                    (1, CtxA::V2)
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let op = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { op };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }

        fn exit_c(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxC::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_c(ctx, spans);
        }
    }

    // [wrapper source for rule 14 #2, start a]
    // ------------------------------------------------------------
}

pub(crate) mod rules_14_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 14 #3, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_14_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> b c`
        V1 { c: SynC },
        /// `a -> c`
        V2 { c: SynC },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> Op c`
        V1 { op: String, c: SynC },
    }
    #[derive(Debug)]
    pub enum CtxC {
        /// `c -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `c`
    // #[derive(Debug, PartialEq)] pub struct SynC();

    #[derive(Debug)]
    enum SynValue { A(SynA), C(SynC) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_c(self) -> SynC {
            if let SynValue::C(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
        fn init_c(&mut self) {}
        fn exit_c(&mut self, ctx: CtxC, spans: Vec<PosSpan>) -> SynC;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_b(),                // b
                        2 => self.listener.init_c(),                // c
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> b c
                        1 => self.exit_a(alt_id),                   // a -> c
                        2 => self.exit_b(),                         // b -> Op c
                        3 => self.exit_c(),                         // c -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let c = self.stack.pop().unwrap().get_c();
                    (2, CtxA::V1 { c })
                }
                1 => {
                    let c = self.stack.pop().unwrap().get_c();
                    (1, CtxA::V2 { c })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let c = self.stack.pop().unwrap().get_c();
            let op = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { op, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }

        fn exit_c(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxC::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_c(ctx, spans);
            self.stack.push(SynValue::C(val));
        }
    }

    // [wrapper source for rule 14 #3, start a]
    // ------------------------------------------------------------
}

pub(crate) mod rules_14_4 {
    // ------------------------------------------------------------
    // [wrapper source for rule 14 #4, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_14_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> b c`
        V1,
        /// `a -> c`
        V2,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> Op c`
        V1 { op: String },
    }
    #[derive(Debug)]
    pub enum CtxC {
        /// `c -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
        fn init_c(&mut self) {}
        #[allow(unused_variables)]
        fn exit_c(&mut self, ctx: CtxC, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_b(),                // b
                        2 => self.listener.init_c(),                // c
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> b c
                        1 => self.exit_a(alt_id),                   // a -> c
                        2 => self.exit_b(),                         // b -> Op c
                        3 => self.exit_c(),                         // c -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    (2, CtxA::V1)
                }
                1 => {
                    (1, CtxA::V2)
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let op = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { op };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }

        fn exit_c(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxC::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_c(ctx, spans);
        }
    }

    // [wrapper source for rule 14 #4, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_102_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 102 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_102_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B* C`
        V1 { a: String, star: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B*` array in `a -> A  ►► B* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 => self.exit_a1(),                        // a_1 -> B a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let b = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(b);
        }
    }

    // [wrapper source for rule 102 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_103_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 103 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_103_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B+ C`
        V1 { a: String, plus: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B+` array in `a -> A  ►► B+ ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        2 |                                         // a_2 -> a_1
                        3 => self.exit_a1(),                        // a_2 -> ε
                     /* 1 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let b = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(b);
        }
    }

    // [wrapper source for rule 103 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_104_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 104 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_104_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (b A b B A)*`
        V1 { star: SynA1 },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> C`
        V1 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b A b B A)*` array in `a ->  ►► (b A b B A)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `b A b B A` item in `a -> ( ►► b A b B A ◄◄ )*`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: [SynB; 2], pub a: [String; 2], pub b1: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1
                        2 => self.exit_a1(),                        // a_1 -> b A b B A a_1
                        3 => {}                                     // a_1 -> ε
                        1 => self.exit_b(),                         // b -> C
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let ctx = CtxA::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 6 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a_2 = self.stack_t.pop().unwrap();
            let b1 = self.stack_t.pop().unwrap();
            let b_2 = self.stack.pop().unwrap().get_b();
            let a_1 = self.stack_t.pop().unwrap();
            let b_1 = self.stack.pop().unwrap().get_b();
            let val = SynA1Item { b: [b_1, b_2], a: [a_1, a_2], b1 };
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }

        fn exit_b(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { c };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 104 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_105_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 105 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_105_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (b A b B A)+`
        V1 { plus: SynA1 },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> C`
        V1 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b A b B A)+` array in `a ->  ►► (b A b B A)+ ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `b A b B A` item in `a -> ( ►► b A b B A ◄◄ )+`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: [SynB; 2], pub a: [String; 2], pub b1: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 => {}                                     // a_2
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1
                        3 |                                         // a_2 -> a_1
                        4 => self.exit_a1(),                        // a_2 -> ε
                     /* 2 */                                        // a_1 -> b A b B A a_2 (never called)
                        1 => self.exit_b(),                         // b -> C
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let plus = self.stack.pop().unwrap().get_a1();
            let ctx = CtxA::V1 { plus };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 6 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a_2 = self.stack_t.pop().unwrap();
            let b1 = self.stack_t.pop().unwrap();
            let b_2 = self.stack.pop().unwrap().get_b();
            let a_1 = self.stack_t.pop().unwrap();
            let b_1 = self.stack.pop().unwrap().get_b();
            let val = SynA1Item { b: [b_1, b_2], a: [a_1, a_2], b1 };
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(val);
        }

        fn exit_b(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { c };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 105 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_106_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        V1 { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b ",")*` array in `a -> (A  ►► (b ",")* ◄◄  ";")* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynB>);
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `A (b ",")* ";"` item in `a -> ( ►► A (b ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub a: String, pub star: SynA1 }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2 | 3) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 => self.init_a2(),                        // a_2
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 => self.exit_a1(),                        // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let ctx = CtxA::V1 { star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let b = self.stack.pop().unwrap().get_b();
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(b);
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = SynA2Item { a, star };
            let Some(SynValue::A2(SynA2(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA2 item on wrapper stack");
            };
            star_acc.push(val);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 106 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #2, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_106_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        V1 { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2 | 3) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        3 => self.init_a2(),                        // a_2
                        2 => {}                                     // a_1
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 |                                         // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let ctx = CtxA::V1 { star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a = self.stack_t.pop().unwrap();
            let Some(SynValue::A2(SynA2(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA2 item on wrapper stack");
            };
            star_acc.push(a);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }
    }

    // [wrapper source for rule 106 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_108_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 108 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_108_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A "B"* C`
        V1 { a: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 |                                         // a_1 -> "B" a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 108 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_109_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 109 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_109_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> Id "(" Id ":" type ("," Id ":" type)* ")"`
        V1 { id: String, star: SynA1 },
    }
    #[derive(Debug)]
    pub enum CtxType {
        /// `type -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `type`
    // #[derive(Debug, PartialEq)] pub struct SynType();
    /// Computed `("," Id ":" type)*` array in `a -> Id "(" Id ":" type  ►► ("," Id ":" type)* ◄◄  ")"`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `"," Id ":" type` item in `a -> Id "(" Id ":" type ( ►► "," Id ":" type ◄◄ )* ")"`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub id: String, pub type1: SynType }

    #[derive(Debug)]
    enum SynValue { A(SynA), Type(SynType), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_type(self) -> SynType {
            if let SynValue::Type(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_type(&mut self) {}
        fn exit_type(&mut self, ctx: CtxType, spans: Vec<PosSpan>) -> SynType;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        1 => self.listener.init_type(),             // type
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> Id "(" Id ":" type a_1 ")"
                        2 => self.exit_a1(),                        // a_1 -> "," Id ":" type a_1
                        3 => {}                                     // a_1 -> ε
                        1 => self.exit_type(),                      // type -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { id, star };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let val = SynA1Item { id, type1 };
            self.stack.push(SynValue::A1(SynA1(vec![val])));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 5 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let val = SynA1Item { id, type1 };
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }

        fn exit_type(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxType::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_type(ctx, spans);
            self.stack.push(SynValue::Type(val));
        }
    }

    // [wrapper source for rule 109 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_110_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 110 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_110_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> Id "(" Id ":" type ("," Id ":" type)* ")"`
        V1 { id: String, star: SynA1 },
        /// `a -> Id "(" ")"`
        V2 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxType {
        /// `type -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `type`
    // #[derive(Debug, PartialEq)] pub struct SynType();
    /// Computed `("," Id ":" type)*` array in `a -> Id "(" Id ":" type  ►► ("," Id ":" type)* ◄◄  ")" | Id "(" ")"`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `"," Id ":" type` item in `a -> Id "(" Id ":" type ( ►► "," Id ":" type ◄◄ )* ")" | Id "(" ")"`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub id: String, pub type1: SynType }

    #[derive(Debug)]
    enum SynValue { A(SynA), Type(SynType), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_type(self) -> SynType {
            if let SynValue::Type(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_type(&mut self) {}
        fn exit_type(&mut self, ctx: CtxType, spans: Vec<PosSpan>) -> SynType;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 => {}                                     // a_2
                        1 => self.listener.init_type(),             // type
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        4 |                                         // a_2 -> Id ":" type a_1 ")"
                        5 => self.exit_a(alt_id),                   // a_2 -> ")"
                        2 => self.exit_a1(),                        // a_1 -> "," Id ":" type a_1
                        3 => {}                                     // a_1 -> ε
                     /* 0 */                                        // a -> Id "(" a_2 (never called)
                        1 => self.exit_type(),                      // type -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let star = self.stack.pop().unwrap().get_a1();
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxA::V1 { id, star })
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    (3, CtxA::V2 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let val = SynA1Item { id, type1 };
            self.stack.push(SynValue::A1(SynA1(vec![val])));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 5 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let val = SynA1Item { id, type1 };
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }

        fn exit_type(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxType::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_type(ctx, spans);
            self.stack.push(SynValue::Type(val));
        }
    }

    // [wrapper source for rule 110 #1, start a]
}

// ================================================================================

pub(crate) mod rules_150_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 150 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_150_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A | B)*`
        V1 { star: SynA1 },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(A | B)*` array in `a ->  ►► (A | B)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        /// `A` item in `a -> ( ►► A ◄◄  | B)*`
        V1 { a: String },
        /// `B` item in `a -> (A |  ►► B ◄◄ )*`
        V2 { b: String },
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1
                        1 |                                         // a_1 -> A a_1
                        2 => self.exit_a1(alt_id),                  // a_1 -> B a_1
                        3 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let ctx = CtxA::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, val) = match alt_id {
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V1 { a })
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V2 { b })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1"),
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }
    }

    // [wrapper source for rule 150 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_152_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 152 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_152_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (B | b C b B C | E)* F`
        V1 { a: String, star: SynA1, f: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> D`
        V1 { d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(B | b C b B C | E)*` array in `a -> A  ►► (B | b C b B C | E)* ◄◄  F`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        /// `B` item in `a -> A ( ►► B ◄◄  | b C b B C | E)* F`
        V1 { b: String },
        /// `b C b B C` item in `a -> A (B |  ►► b C b B C ◄◄  | E)* F`
        V2 { b: [SynB; 2], c: [String; 2], b1: String },
        /// `E` item in `a -> A (B | b C b B C |  ►► E ◄◄ )* F`
        V3 { e: String },
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 F
                        2 |                                         // a_1 -> B a_1
                        3 |                                         // a_1 -> b C b B C a_1
                        4 => self.exit_a1(alt_id),                  // a_1 -> E a_1
                        5 => {}                                     // a_1 -> ε
                        1 => self.exit_b(),                         // b -> D
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let f = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, star, f };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, val) = match alt_id {
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V1 { b })
                }
                3 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let b1 = self.stack_t.pop().unwrap();
                    let b_2 = self.stack.pop().unwrap().get_b();
                    let c_1 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack.pop().unwrap().get_b();
                    (6, SynA1Item::V2 { b: [b_1, b_2], c: [c_1, c_2], b1 })
                }
                4 => {
                    let e = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V3 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1"),
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }

        fn exit_b(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { d };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 152 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_153_1 {

    /// User-defined type for `a`
    #[derive(Debug, PartialEq)] pub struct SynA(pub Vec<String>);
    /// User-defined type for `b`
    #[derive(Debug, PartialEq)] pub struct SynB(pub String);

    // ------------------------------------------------------------
    // [wrapper source for rule 153 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 6;
    const PARSER_NUM_NT: usize = 6;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("A", None), ("B", None), ("C", None), ("E", None), ("F", None), ("D", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["a", "b", "a_1", "a_2", "a_3", "a_4"];
    static ALT_VAR: [VarId; 11] = [0, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5];
    static ALTERNATIVES: [&[Symbol]; 11] = [&[Symbol::T(0), Symbol::NT(2), Symbol::T(4)], &[Symbol::T(5)], &[Symbol::T(1), Symbol::NT(3)], &[Symbol::T(3), Symbol::NT(4)], &[Symbol::NT(1), Symbol::T(2), Symbol::NT(1), Symbol::T(1), Symbol::T(2), Symbol::NT(5)], &[Symbol::NT(2)], &[Symbol::Empty], &[Symbol::NT(2)], &[Symbol::Empty], &[Symbol::NT(2)], &[Symbol::Empty]];
    static PARSING_TABLE: [AltId; 42] = [0, 11, 11, 11, 11, 11, 12, 11, 12, 12, 11, 11, 1, 11, 11, 2, 11, 3, 12, 4, 11, 11, 5, 11, 5, 6, 5, 11, 11, 7, 11, 7, 8, 7, 11, 11, 9, 11, 9, 10, 9, 11];
    static OPCODES: [&[OpCode]; 11] = [&[OpCode::Exit(0), OpCode::T(4), OpCode::NT(2), OpCode::T(0)], &[OpCode::Exit(1), OpCode::T(5)], &[OpCode::NT(3), OpCode::T(1)], &[OpCode::NT(4), OpCode::T(3)], &[OpCode::NT(5), OpCode::T(2), OpCode::T(1), OpCode::NT(1), OpCode::T(2), OpCode::NT(1)], &[OpCode::Loop(2), OpCode::Exit(5)], &[OpCode::Exit(6)], &[OpCode::Loop(2), OpCode::Exit(7)], &[OpCode::Exit(8)], &[OpCode::Loop(2), OpCode::Exit(9)], &[OpCode::Exit(10)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (B | b C b B C | E)+ F`
        V1 { a: String, plus: SynA1, f: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> D`
        V1 { d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(B | b C b B C | E)+` array in `a -> A  ►► (B | b C b B C | E)+ ◄◄  F`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        /// `B` item in `a -> A ( ►► B ◄◄  | b C b B C | E)+ F`
        V1 { b: String },
        /// `b C b B C` item in `a -> A (B |  ►► b C b B C ◄◄  | E)+ F`
        V2 { b: [SynB; 2], c: [String; 2], b1: String },
        /// `E` item in `a -> A (B | b C b B C |  ►► E ◄◄ )+ F`
        V3 { e: String },
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 ..= 5 => {}                               // a_2, a_3, a_4
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 F
                        5 |                                         // a_2 -> a_1
                        6 |                                         // a_2 -> ε
                        7 |                                         // a_3 -> a_1
                        8 |                                         // a_3 -> ε
                        9 |                                         // a_4 -> a_1
                        10 => self.exit_a1(alt_id),                 // a_4 -> ε
                     /* 2 */                                        // a_1 -> B a_2 (never called)
                     /* 3 */                                        // a_1 -> E a_3 (never called)
                     /* 4 */                                        // a_1 -> b C b B C a_4 (never called)
                        1 => self.exit_b(),                         // b -> D
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let f = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, f };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, val) = match alt_id {
                5 | 6 => {
                    let b = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V1 { b })
                }
                9 | 10 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let b1 = self.stack_t.pop().unwrap();
                    let b_2 = self.stack.pop().unwrap().get_b();
                    let c_1 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack.pop().unwrap().get_b();
                    (6, SynA1Item::V2 { b: [b_1, b_2], c: [c_1, c_2], b1 })
                }
                7 | 8 => {
                    let e = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V3 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1"),
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(val);
        }

        fn exit_b(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { d };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 153 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_200_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_200_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        V1 { a: String, star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        V1 { star_acc: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, b };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }
    }

    // [wrapper source for rule 200 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_200_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #2, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_200_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        V1 { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxI::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_i(ctx, spans);
        }
    }

    // [wrapper source for rule 200 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_201_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        V1 { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        V1 { plus_acc: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();

    #[derive(Debug)]
    enum SynValue { A(SynMyA), I(SynMyI) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynMyI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynMyA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynMyA;
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // i_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // i_1 -> i
                        3 => self.exit_i(alt_id),                   // i_1 -> ε
                     /* 1 */                                        // i -> <L> B i_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { plus_acc, b, last_iteration };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #2, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_201_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        V1 { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        V1 { b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();

    #[derive(Debug)]
    enum SynValue { A(SynMyA) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynMyA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynMyA;
        fn init_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => {}                                     // i_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // i_1 -> i
                        3 => self.exit_i(alt_id),                   // i_1 -> ε
                     /* 1 */                                        // i -> <L> B i_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxI::V1 { b, last_iteration };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_i(ctx, spans);
        }
    }

    // [wrapper source for rule 201 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #3, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_201_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        V1 { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        V1 { plus_acc: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { I(SynMyI) }

    impl SynValue {
        fn get_i(self) -> SynMyI {
            let SynValue::I(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        #[allow(unused_variables)]
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) {}
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // i_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // i_1 -> i
                        3 => self.exit_i(alt_id),                   // i_1 -> ε
                     /* 1 */                                        // i -> <L> B i_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_a(ctx, spans);
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { plus_acc, b, last_iteration };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_202_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 202 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_202_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> b A b B A)*`
        V1 { star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> b A b B A` iteration in `a -> ( ►► <L> b A b B A ◄◄ )*`
        V1 { star_acc: SynI, b: [SynB; 2], a: [String; 2], b1: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> C`
        V1 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> b A b B A` iteration in `a -> ( ►► <L> b A b B A ◄◄ )*`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        1 => self.exit_i(),                         // i -> <L> b A b B A i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_b(),                         // b -> C
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let a_2 = self.stack_t.pop().unwrap();
            let b1 = self.stack_t.pop().unwrap();
            let b_2 = self.stack.pop().unwrap().get_b();
            let a_1 = self.stack_t.pop().unwrap();
            let b_1 = self.stack.pop().unwrap().get_b();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, b: [b_1, b_2], a: [a_1, a_2], b1 };
            let spans = self.stack_span.drain(self.stack_span.len() - 6 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn exit_b(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { c };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 202 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_206_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 206 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_206_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (<L> B ",")* ";")* C`
        V1 { star: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
        V1 { star_acc: SynAiter, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynAiter();
    /// Computed `(A (<L> B ",")* ";")*` array in `a ->  ►► (A (<L> B ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `A (<L> B ",")* ";"` item in `a -> ( ►► A (<L> B ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub a: String, pub star: SynAiter }

    #[derive(Debug)]
    enum SynValue { A(SynA), J(SynAiter), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynAiter {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_j(&mut self) -> SynAiter;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynAiter;
        #[allow(unused_variables)]
        fn exitloop_j(&mut self, star_acc: &mut SynAiter) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_j(),                         // j
                        2 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1 C
                        1 => self.exit_j(),                         // j -> <L> B "," j
                        2 => self.exitloop_j(),                     // j -> <L> ε
                        3 => self.exit_a1(),                        // a_1 -> A j ";" a_1
                        4 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let ctx = CtxA::V1 { star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_j();
            let ctx = CtxJ::V1 { star_acc, b };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_acc);
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let val = SynA1Item { a, star };
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(val);
        }
    }

    // [wrapper source for rule 206 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_208_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        V1 { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        V1 { star_acc: SynI, a: String, star: SynJ },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        V1 { star_acc: SynJ, b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynJ();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynJ;
        #[allow(unused_variables)]
        fn exitloop_j(&mut self, star_acc: &mut SynJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => self.exitloop_j(),                     // j -> <L> ε
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, a, star };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let star_acc = self.stack.pop().unwrap().get_j();
            let ctx = CtxJ::V1 { star_acc, b };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_acc);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 208 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #2, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_208_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        V1 { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        V1 { star_acc: SynI, a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        V1,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_j(&mut self) {}
        #[allow(unused_variables)]
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) {}
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, a };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn exit_j(&mut self) {
            let ctx = CtxJ::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_j(ctx, spans);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }
    }

    // [wrapper source for rule 208 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #3, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_208_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        V1 { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        V1 { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        V1,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) {}
        fn init_j(&mut self) {}
        #[allow(unused_variables)]
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) {}
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxI::V1 { a };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_i(ctx, spans);
        }

        fn exit_j(&mut self) {
            let ctx = CtxJ::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_j(ctx, spans);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }
    }

    // [wrapper source for rule 208 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_4 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #4, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_208_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        V1 { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        V1 { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        V1,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        V1 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        #[allow(unused_variables)]
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) {}
        fn init_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) {}
        fn init_j(&mut self) {}
        #[allow(unused_variables)]
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) {}
        fn init_b(&mut self) {}
        #[allow(unused_variables)]
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { c };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_a(ctx, spans);
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxI::V1 { a };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_i(ctx, spans);
        }

        fn exit_j(&mut self) {
            let ctx = CtxJ::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_j(ctx, spans);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_b(ctx, spans);
        }
    }

    // [wrapper source for rule 208 #4, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_210_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 210 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_210_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> "B")* C`
        V1 { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> "B"` iteration in `a -> A ( ►► <L> "B" ◄◄ )* C`
        V1,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> "B" i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let ctx = CtxI::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_i(ctx, spans);
        }
    }

    // [wrapper source for rule 210 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_211_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 211 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_211_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A A (B <L>)* C`
        V1 { a: [String; 2], star: SynI, c: String },
        /// `a -> A C (B <L>)* C`
        V2 { a: String, c: [String; 2], star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
        V1 { star_acc: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // a_1 -> A i C
                        4 => self.exit_a(alt_id),                   // a_1 -> C i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let a_2 = self.stack_t.pop().unwrap();
                    let a_1 = self.stack_t.pop().unwrap();
                    (4, CtxA::V1 { a: [a_1, a_2], star, c })
                }
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    (4, CtxA::V2 { a, c: [c_1, c_2], star })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, b };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }
    }

    // [wrapper source for rule 211 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_212_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 212 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_212_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> Id "(" Id ":" type (<L> "<" ">" Id ":" type)* ")"`
        V1 { id: String, star: SynI },
    }
    #[derive(Debug)]
    pub enum InitCtxI {
        /// value of `Id type` before `<L> "<" ">" Id ":" type` iteration in `a -> Id "(" Id ":" type ( ►► <L> "<" ">" Id ":" type ◄◄ )* ")"`
        V1 { id: String, type1: SynType },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> "<" ">" Id ":" type` iteration in `a -> Id "(" Id ":" type ( ►► <L> "<" ">" Id ":" type ◄◄ )* ")"`
        V1 { star_acc: SynI, id: String, type1: SynType },
    }
    #[derive(Debug)]
    pub enum CtxType {
        /// `type -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> "<" ">" Id ":" type` iteration in `a -> Id "(" Id ":" type ( ►► <L> "<" ">" Id ":" type ◄◄ )* ")"`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `type`
    // #[derive(Debug, PartialEq)] pub struct SynType();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), Type(SynType) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_type(self) -> SynType {
            if let SynValue::Type(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self, ctx: InitCtxI, spans: Vec<PosSpan>) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_type(&mut self) {}
        fn exit_type(&mut self, ctx: CtxType, spans: Vec<PosSpan>) -> SynType;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.listener.init_type(),             // type
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> Id "(" Id ":" type i ")"
                        1 => self.exit_i(),                         // i -> <L> "<" ">" Id ":" type i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_type(),                      // type -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_i();
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { id, star };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let ctx = InitCtxI::V1 { id, type1 };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.init_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let type1 = self.stack.pop().unwrap().get_type();
            let id = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_i();
            let ctx = CtxI::V1 { star_acc, id, type1 };
            let spans = self.stack_span.drain(self.stack_span.len() - 6 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn exit_type(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxType::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_type(ctx, spans);
            self.stack.push(SynValue::Type(val));
        }
    }

    // [wrapper source for rule 212 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_250_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 250 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_250_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | B)*`
        V1 { star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)*`
        V1 { star_acc: SynI, a: String },
        /// `B` iteration in `a -> (<L> A |  ►► B ◄◄ )*`
        V2 { star_acc: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)*`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        1 |                                         // i -> <L> A i
                        2 => self.exit_i(alt_id),                   // i -> <L> B i
                        3 => self.exitloop_i(),                     // i -> <L> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V1 { star_acc, a })
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V2 { star_acc, b })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }
    }

    // [wrapper source for rule 250 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_251_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 251 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_251_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | B)+`
        V1 { plus: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)+`
        V1 { plus_acc: SynI, a: String, last_iteration: bool },
        /// `B` iteration in `a -> (<L> A |  ►► B ◄◄ )+`
        V2 { plus_acc: SynI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)+`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 | 3 => {}                                 // i_1, i_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        3 |                                         // i_1 -> i
                        4 |                                         // i_1 -> ε
                        5 |                                         // i_2 -> i
                        6 => self.exit_i(alt_id),                   // i_2 -> ε
                     /* 1 */                                        // i -> <L> A i_1 (never called)
                     /* 2 */                                        // i -> <L> B i_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let plus = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { plus };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                3 | 4 => {
                    let last_iteration = alt_id == 4;
                    let a = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V1 { plus_acc, a, last_iteration })
                }
                5 | 6 => {
                    let last_iteration = alt_id == 6;
                    let b = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V2 { plus_acc, b, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 251 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_252_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 252 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_252_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A ((<L> b C b B C | D)+ E | F)+ G`
        V1 { a: String, plus: SynA1, g: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b C b B C` iteration in `a -> A (( ►► <L> b C b B C ◄◄  | D)+ E | F)+ G`
        V1 { plus_acc: SynJ, b: [SynB; 2], c: [String; 2], b1: String, last_iteration: bool },
        /// `D` iteration in `a -> A ((<L> b C b B C |  ►► D ◄◄ )+ E | F)+ G`
        V2 { plus_acc: SynJ, d: String, last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> H`
        V1 { h: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `D` iteration in `a -> A ((<L> b C b B C |  ►► D ◄◄ )+ E | F)+ G`
    // #[derive(Debug, PartialEq)] pub struct SynJ();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `((<L> b C b B C | D)+ E | F)+` array in `a -> A  ►► ((<L> b C b B C | D)+ E | F)+ ◄◄  G`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        /// `(<L> b C b B C | D)+ E` item in `a -> A ( ►► (<L> b C b B C | D)+ E ◄◄  | F)+ G`
        V1 { plus: SynJ, e: String },
        /// `F` item in `a -> A ((<L> b C b B C | D)+ E |  ►► F ◄◄ )+ G`
        V2 { f: String },
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), J(SynJ), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynJ;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 3) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_j(),                         // j
                        3 => self.init_a1(),                        // a_1
                        4 ..= 7 => {}                               // j_1, j_2, a_2, a_3
                        2 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 G
                        6 |                                         // j_1 -> j
                        7 |                                         // j_1 -> ε
                        8 |                                         // j_2 -> j
                        9 => self.exit_j(alt_id),                   // j_2 -> ε
                        10 |                                        // a_2 -> a_1
                        11 |                                        // a_2 -> ε
                        12 |                                        // a_3 -> a_1
                        13 => self.exit_a1(alt_id),                 // a_3 -> ε
                     /* 1 */                                        // j -> <L> D j_1 (never called)
                     /* 2 */                                        // j -> <L> b C b B C j_2 (never called)
                     /* 4 */                                        // a_1 -> F a_2 (never called)
                     /* 5 */                                        // a_1 -> j E a_3 (never called)
                        3 => self.exit_b(),                         // b -> H
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let g = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, g };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                6 | 7 => {
                    let last_iteration = alt_id == 7;
                    let d = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V2 { plus_acc, d, last_iteration })
                }
                8 | 9 => {
                    let last_iteration = alt_id == 9;
                    let c_2 = self.stack_t.pop().unwrap();
                    let b1 = self.stack_t.pop().unwrap();
                    let b_2 = self.stack.pop().unwrap().get_b();
                    let c_1 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack.pop().unwrap().get_b();
                    let plus_acc = self.stack.pop().unwrap().get_j();
                    (6, CtxJ::V1 { plus_acc, b: [b_1, b_2], c: [c_1, c_2], b1, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_j")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, val) = match alt_id {
                12 | 13 => {
                    let e = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_j();
                    (3, SynA1Item::V1 { plus, e })
                }
                10 | 11 => {
                    let f = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V2 { f })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1"),
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(val);
        }

        fn exit_b(&mut self) {
            let h = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { h };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 252 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_253_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 253 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_253_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> (b C b B C | D)+ E | F)+ G`
        V1 { a: String, plus: SynI, g: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> (b C b B C | D)+ E` iteration in `a -> A ( ►► <L> (b C b B C | D)+ E ◄◄  | F)+ G`
        V1 { plus_acc: SynI, plus: SynA1, e: String, last_iteration: bool },
        /// `F` iteration in `a -> A (<L> (b C b B C | D)+ E |  ►► F ◄◄ )+ G`
        V2 { plus_acc: SynI, f: String, last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> H`
        V1 { h: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `F` iteration in `a -> A (<L> (b C b B C | D)+ E |  ►► F ◄◄ )+ G`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b C b B C | D)+` array in `a -> A (<L>  ►► (b C b B C | D)+ ◄◄  E | F)+ G`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        /// `b C b B C` item in `a -> A (<L> ( ►► b C b B C ◄◄  | D)+ E | F)+ G`
        V1 { b: [SynB; 2], c: [String; 2], b1: String },
        /// `D` item in `a -> A (<L> (b C b B C |  ►► D ◄◄ )+ E | F)+ G`
        V2 { d: String },
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 3) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        3 => self.init_a1(),                        // a_1
                        4 ..= 7 => {}                               // i_1, i_2, a_2, a_3
                        2 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i G
                        6 |                                         // i_1 -> i
                        7 |                                         // i_1 -> ε
                        8 |                                         // i_2 -> i
                        9 => self.exit_i(alt_id),                   // i_2 -> ε
                        10 |                                        // a_2 -> a_1
                        11 |                                        // a_2 -> ε
                        12 |                                        // a_3 -> a_1
                        13 => self.exit_a1(alt_id),                 // a_3 -> ε
                     /* 1 */                                        // i -> <L> F i_1 (never called)
                     /* 2 */                                        // i -> <L> a_1 E i_2 (never called)
                     /* 4 */                                        // a_1 -> D a_2 (never called)
                     /* 5 */                                        // a_1 -> b C b B C a_3 (never called)
                        3 => self.exit_b(),                         // b -> H
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let g = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, g };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                6 | 7 => {
                    let last_iteration = alt_id == 7;
                    let f = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V2 { plus_acc, f, last_iteration })
                }
                8 | 9 => {
                    let last_iteration = alt_id == 9;
                    let e = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_a1();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V1 { plus_acc, plus, e, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, val) = match alt_id {
                12 | 13 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let b1 = self.stack_t.pop().unwrap();
                    let b_2 = self.stack.pop().unwrap().get_b();
                    let c_1 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack.pop().unwrap().get_b();
                    (6, SynA1Item::V1 { b: [b_1, b_2], c: [c_1, c_2], b1 })
                }
                10 | 11 => {
                    let d = self.stack_t.pop().unwrap();
                    (2, SynA1Item::V2 { d })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1"),
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(val);
        }

        fn exit_b(&mut self) {
            let h = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { h };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 253 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_254_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 254 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_254_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> (<L> b C b B C | D)* E | F)* G`
        V1 { a: String, star: SynI, g: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> (<L> b C b B C | D)* E` iteration in `a -> A ( ►► <L> (<L> b C b B C | D)* E ◄◄  | F)* G`
        V1 { star_acc: SynI, star: SynJ, e: String },
        /// `F` iteration in `a -> A (<L> (<L> b C b B C | D)* E |  ►► F ◄◄ )* G`
        V2 { star_acc: SynI, f: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b C b B C` iteration in `a -> A (<L> ( ►► <L> b C b B C ◄◄  | D)* E | F)* G`
        V1 { star_acc: SynJ, b: [SynB; 2], c: [String; 2], b1: String },
        /// `D` iteration in `a -> A (<L> (<L> b C b B C |  ►► D ◄◄ )* E | F)* G`
        V2 { star_acc: SynJ, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> H`
        V1 { h: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> (<L> b C b B C | D)* E` iteration in `a -> A ( ►► <L> (<L> b C b B C | D)* E ◄◄  | F)* G`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `<L> b C b B C` iteration in `a -> A (<L> ( ►► <L> b C b B C ◄◄  | D)* E | F)* G`
    // #[derive(Debug, PartialEq)] pub struct SynJ();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynJ;
        #[allow(unused_variables)]
        fn exitloop_j(&mut self, star_acc: &mut SynJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i G
                        1 |                                         // i -> <L> j E i
                        2 => self.exit_i(alt_id),                   // i -> <L> F i
                        3 => self.exitloop_i(),                     // i -> <L> ε
                        4 |                                         // j -> <L> b C b B C j
                        5 => self.exit_j(alt_id),                   // j -> <L> D j
                        6 => self.exitloop_j(),                     // j -> <L> ε
                        7 => self.exit_b(),                         // b -> H
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let g = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, star, g };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_j();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V1 { star_acc, star, e })
                }
                2 => {
                    let f = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V2 { star_acc, f })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let b1 = self.stack_t.pop().unwrap();
                    let b_2 = self.stack.pop().unwrap().get_b();
                    let c_1 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack.pop().unwrap().get_b();
                    let star_acc = self.stack.pop().unwrap().get_j();
                    (6, CtxJ::V1 { star_acc, b: [b_1, b_2], c: [c_1, c_2], b1 })
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V2 { star_acc, d })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_j")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_acc);
        }

        fn exit_b(&mut self) {
            let h = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { h };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 254 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_256_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 256 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_256_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B A | B A C b | D)+ E`
        V1 { a: String, plus: SynI, e: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B A` iteration in `a -> A ( ►► <L> B A ◄◄  | B A C b | D)+ E`
        V1 { plus_acc: SynI, b: String, a: String, last_iteration: bool },
        /// `B A C b` iteration in `a -> A (<L> B A |  ►► B A C b ◄◄  | D)+ E`
        V2 { plus_acc: SynI, b: String, a: String, c: String, b1: SynB, last_iteration: bool },
        /// `D` iteration in `a -> A (<L> B A | B A C b |  ►► D ◄◄ )+ E`
        V3 { plus_acc: SynI, d: String, last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> F`
        V1 { f: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B A` iteration in `a -> A ( ►► <L> B A ◄◄  | B A C b | D)+ E`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, ctx: CtxB, spans: Vec<PosSpan>) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        3 ..= 5 => {}                               // i_1, i_2, a_1
                        2 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i E
                        5 |                                         // i_1 -> i
                        6 |                                         // i_1 -> ε
                        7 |                                         // i_2 -> i
                        8 |                                         // i_2 -> ε
                        9 |                                         // a_1 -> i
                        10 => self.exit_i(alt_id),                  // a_1 -> ε
                     /* 1 */                                        // i -> <L> B A i_1 (never called)
                     /* 2 */                                        // i -> <L> D i_2 (never called)
                     /* 4 */                                        // i_1 -> C b a_1 (never called)
                        3 => self.exit_b(),                         // b -> F
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let e = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let ctx = CtxA::V1 { a, plus, e };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                5 | 6 => {
                    let last_iteration = alt_id == 6;
                    let a = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V1 { plus_acc, b, a, last_iteration })
                }
                7 | 8 => {
                    let last_iteration = alt_id == 8;
                    let d = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V3 { plus_acc, d, last_iteration })
                }
                9 | 10 => {
                    let last_iteration = alt_id == 10;
                    let b1 = self.stack.pop().unwrap().get_b();
                    let c = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (5, CtxI::V2 { plus_acc, b, a, c, b1, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exit_b(&mut self) {
            let f = self.stack_t.pop().unwrap();
            let ctx = CtxB::V1 { f };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_b(ctx, spans);
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 256 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_258_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 258 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_258_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | A B | C | D (<L> E | E F | G)*)*`
        V1 { star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | A B | C | D (<L> E | E F | G)*)*`
        V1 { star_acc: SynI, a: String },
        /// `A B` iteration in `a -> (<L> A |  ►► A B ◄◄  | C | D (<L> E | E F | G)*)*`
        V2 { star_acc: SynI, a: String, b: String },
        /// `C` iteration in `a -> (<L> A | A B |  ►► C ◄◄  | D (<L> E | E F | G)*)*`
        V3 { star_acc: SynI, c: String },
        /// `D (<L> E | E F | G)*` iteration in `a -> (<L> A | A B | C |  ►► D (<L> E | E F | G)* ◄◄ )*`
        V4 { star_acc: SynI, d: String, star: SynJ },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> E` iteration in `a -> (<L> A | A B | C | D ( ►► <L> E ◄◄  | E F | G)*)*`
        V1 { star_acc: SynJ, e: String },
        /// `E F` iteration in `a -> (<L> A | A B | C | D (<L> E |  ►► E F ◄◄  | G)*)*`
        V2 { star_acc: SynJ, e: String, f: String },
        /// `G` iteration in `a -> (<L> A | A B | C | D (<L> E | E F |  ►► G ◄◄ )*)*`
        V3 { star_acc: SynJ, g: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `i -> <alt 1 NOT FOUND>`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `j -> <alt 5 NOT FOUND>`
    // #[derive(Debug, PartialEq)] pub struct SynJ();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        #[allow(unused_variables)]
        fn exitloop_i(&mut self, star_acc: &mut SynI) {}
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynJ;
        #[allow(unused_variables)]
        fn exitloop_j(&mut self, star_acc: &mut SynJ) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 | 4 => {}                                 // i_1, j_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        2 |                                         // i -> <L> C i
                        3 |                                         // i -> <L> D j i
                        8 |                                         // i_1 -> B i
                        9 => self.exit_i(alt_id),                   // i_1 -> i
                        4 => self.exitloop_i(),                     // i -> <L> ε
                        6 |                                         // j -> <L> G j
                        10 |                                        // j_1 -> F j
                        11 => self.exit_j(alt_id),                  // j_1 -> j
                        7 => self.exitloop_j(),                     // j -> <L> ε
                     /* 1 */                                        // i -> <L> A i_1 (never called)
                     /* 5 */                                        // j -> <L> E j_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                2 => {
                    let c = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V3 { star_acc, c })
                }
                3 => {
                    let star = self.stack.pop().unwrap().get_j();
                    let d = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V4 { star_acc, d, star })
                }
                8 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V2 { star_acc, a, b })
                }
                9 => {
                    let a = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V1 { star_acc, a })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_acc);
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                6 => {
                    let g = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V3 { star_acc, g })
                }
                10 => {
                    let f = self.stack_t.pop().unwrap();
                    let e = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_j();
                    (3, CtxJ::V2 { star_acc, e, f })
                }
                11 => {
                    let e = self.stack_t.pop().unwrap();
                    let star_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V1 { star_acc, e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_j")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_acc);
        }
    }

    // [wrapper source for rule 258 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_259_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 259 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_259_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | A B | C | D (<L> E | E F | G)+)+`
        V1 { plus: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | A B | C | D (<L> E | E F | G)+)+`
        V1 { plus_acc: SynI, a: String, last_iteration: bool },
        /// `A B` iteration in `a -> (<L> A |  ►► A B ◄◄  | C | D (<L> E | E F | G)+)+`
        V2 { plus_acc: SynI, a: String, b: String, last_iteration: bool },
        /// `C` iteration in `a -> (<L> A | A B |  ►► C ◄◄  | D (<L> E | E F | G)+)+`
        V3 { plus_acc: SynI, c: String, last_iteration: bool },
        /// `D (<L> E | E F | G)+` iteration in `a -> (<L> A | A B | C |  ►► D (<L> E | E F | G)+ ◄◄ )+`
        V4 { plus_acc: SynI, d: String, plus: SynJ, last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> E` iteration in `a -> (<L> A | A B | C | D ( ►► <L> E ◄◄  | E F | G)+)+`
        V1 { plus_acc: SynJ, e: String, last_iteration: bool },
        /// `E F` iteration in `a -> (<L> A | A B | C | D (<L> E |  ►► E F ◄◄  | G)+)+`
        V2 { plus_acc: SynJ, e: String, f: String, last_iteration: bool },
        /// `G` iteration in `a -> (<L> A | A B | C | D (<L> E | E F |  ►► G ◄◄ )+)+`
        V3 { plus_acc: SynJ, g: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | A B | C | D (<L> E | E F | G)+)+`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `<L> E` iteration in `a -> (<L> A | A B | C | D ( ►► <L> E ◄◄  | E F | G)+)+`
    // #[derive(Debug, PartialEq)] pub struct SynJ();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, ctx: CtxI, spans: Vec<PosSpan>) -> SynI;
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, ctx: CtxJ, spans: Vec<PosSpan>) -> SynJ;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 ..= 9 => {}                               // i_1, i_2, i_3, j_1, j_2, a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        7 |                                         // i_1 -> i
                        8 |                                         // i_1 -> ε
                        9 |                                         // i_2 -> i
                        10 |                                        // i_2 -> ε
                        11 |                                        // i_3 -> i
                        12 |                                        // i_3 -> ε
                        18 |                                        // a_1 -> i
                        19 => self.exit_i(alt_id),                  // a_1 -> ε
                        14 |                                        // j_1 -> j
                        15 |                                        // j_1 -> ε
                        16 |                                        // j_2 -> j
                        17 |                                        // j_2 -> ε
                        20 |                                        // a_2 -> j
                        21 => self.exit_j(alt_id),                  // a_2 -> ε
                     /* 1 */                                        // i -> <L> A i_1 (never called)
                     /* 2 */                                        // i -> <L> C i_2 (never called)
                     /* 3 */                                        // i -> <L> D j i_3 (never called)
                     /* 4 */                                        // j -> <L> E j_1 (never called)
                     /* 5 */                                        // j -> <L> G j_2 (never called)
                     /* 6 */                                        // i_1 -> B a_1 (never called)
                     /* 13 */                                       // j_1 -> F a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let plus = self.stack.pop().unwrap().get_i();
            let ctx = CtxA::V1 { plus };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                7 | 8 => {
                    let last_iteration = alt_id == 8;
                    let a = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V1 { plus_acc, a, last_iteration })
                }
                9 | 10 => {
                    let last_iteration = alt_id == 10;
                    let c = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (2, CtxI::V3 { plus_acc, c, last_iteration })
                }
                11 | 12 => {
                    let last_iteration = alt_id == 12;
                    let plus = self.stack.pop().unwrap().get_j();
                    let d = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V4 { plus_acc, d, plus, last_iteration })
                }
                18 | 19 => {
                    let last_iteration = alt_id == 19;
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_i();
                    (3, CtxI::V2 { plus_acc, a, b, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_i(ctx, spans);
            self.stack.push(SynValue::I(val));
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                14 | 15 => {
                    let last_iteration = alt_id == 15;
                    let e = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V1 { plus_acc, e, last_iteration })
                }
                16 | 17 => {
                    let last_iteration = alt_id == 17;
                    let g = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_j();
                    (2, CtxJ::V3 { plus_acc, g, last_iteration })
                }
                20 | 21 => {
                    let last_iteration = alt_id == 21;
                    let f = self.stack_t.pop().unwrap();
                    let e = self.stack_t.pop().unwrap();
                    let plus_acc = self.stack.pop().unwrap().get_j();
                    (3, CtxJ::V2 { plus_acc, e, f, last_iteration })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_j")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_j(ctx, spans);
            self.stack.push(SynValue::J(val));
        }
    }

    // [wrapper source for rule 259 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #1, start expr]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_301_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        V1 { id: String, expr: SynExpr },
        /// `expr -> "(" Num ")"`
        V2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, expr: SynExpr, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_expr();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    let id = self.stack_t.pop().unwrap();
                    (3, CtxExpr::V1 { id, expr })
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    (3, CtxExpr::V2 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_expr(ctx, spans);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 301 #1, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #2, start expr]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_301_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        V1 { id: String },
        /// `expr -> "(" Num ")"`
        V2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_expr(&mut self) {}
        #[allow(unused_variables)]
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    (3, CtxExpr::V1 { id })
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    (3, CtxExpr::V2 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_expr(ctx, spans);
        }
    }

    // [wrapper source for rule 301 #2, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_401_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #1, start expr]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_401_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        V1 { expr: SynExpr, id: String },
        /// `expr -> "(" Num ")"`
        V2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, expr: SynExpr, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 0) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.init_expr(),                      // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_expr();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    (3, CtxExpr::V1 { expr, id })
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    (4, CtxExpr::V2 { expr, num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_expr(ctx, spans);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 401 #1, start expr]
}

// ================================================================================

pub(crate) mod rules_401_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #2, start expr]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_401_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        V1 { id: String },
        /// `expr -> "(" Num ")"`
        V2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_expr(&mut self) {}
        #[allow(unused_variables)]
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    (3, CtxExpr::V1 { id })
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    (4, CtxExpr::V2 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_expr(ctx, spans);
        }
    }

    // [wrapper source for rule 401 #2, start expr]
}

// ================================================================================

pub(crate) mod rules_502_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_502_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        V1 { f: SynF },
        /// `e -> e "." Id`
        V2 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
        #[allow(unused_variables)]
        fn exitloop_e(&mut self, e: &mut SynE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, ctx: CtxF, spans: Vec<PosSpan>) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let ctx = CtxE::V1 { f };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let e = self.stack.pop().unwrap().get_e();
            let ctx = CtxE::V2 { e, id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_e(e);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxF::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_f(ctx, spans);
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_502_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #2, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_502_2::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        V1 { f: SynF },
        /// `e -> e "." Id`
        V2 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        V1 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();
    /// Top non-terminal E (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynE();

    #[derive(Debug)]
    enum SynValue { F(SynF) }

    impl SynValue {
        fn get_f(self) -> SynF {
            let SynValue::F(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        #[allow(unused_variables)]
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, ctx: CtxF, spans: Vec<PosSpan>) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => {}                                     // e_1 -> ε (not used)
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let ctx = CtxE::V1 { f };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_e(ctx, spans);
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxE::V2 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_e(ctx, spans);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxF::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_f(ctx, spans);
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #2, start e]
    // ------------------------------------------------------------
}

// ================================================================================

#[allow(unused)]
pub(crate) mod rules_580_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 580 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_580_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "!"`
        V1 { e: SynE },
        /// `e -> "-" e`
        V2 { e: SynE },
        /// `e -> Num`
        V3 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
        #[allow(unused_variables)]
        fn exitloop_e(&mut self, e: &mut SynE) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 => {}                                     // e_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // e -> "-" e
                        1 => self.inter_e(alt_id),                  // e -> Num e_1
                        2 => self.exit_e1(),                        // e_1 -> "!" e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V3 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_e")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            let ctx = CtxE::V1 { e };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap();
            self.listener.exitloop_e(e);
        }
    }

    // [wrapper source for rule 580 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

#[allow(unused)]
pub(crate) mod rules_600_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 600 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_600_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "+" e`
        V1 { e: [SynE; 2] },
        /// `e -> Num`
        V2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 => self.exit_e1(),                        // e_1 -> "+" e_2 e_1
                        3 => self.exit_e2(),                        // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        2 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self) {
            let e_2 = self.stack.pop().unwrap().get_e();
            let e_1 = self.stack.pop().unwrap().get_e();
            let ctx = CtxE::V1 { e: [e_1, e_2] };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V2 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 600 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

// precedence group:

pub(crate) mod rules_603_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 603 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V2 { e: [SynE; 2] },
        /// `e -> "!" e`
        V3 { e: SynE },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V3 { e })
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 603 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> "!" e`
                    CtxE::V3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}

pub(crate) mod rules_604_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 604 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(2)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> "!" e`
        V2 { e: SynE },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e_2
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 604 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> "!" e`
                    CtxE::V2 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_605_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 605 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(4)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> "!" e`
        V1 { e: SynE },
        /// `e -> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e_4
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V1 { e })
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 605 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> "!" e`
                    CtxE::V1 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> e "*" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_606_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 606 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(0), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V2 { e: [SynE; 2] },
        /// `e -> <R> e "!" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> <R> "!" e e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 606 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> <R> e "!" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_607_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 607 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> <R> e "!" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> <R> "!" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> <R> "!" e_2 e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 607 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <R> e "!" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_608_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 608 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> <R> e "!" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "!" e_4 e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> <R> "!" e_4 e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> <R> "!" e_4 e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 608 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> <R> e "!" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "*" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_609_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 609 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 9, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "!"`
        V3 { e: SynE },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "!" e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V3 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 609 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> e "!"`
                    CtxE::V3 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_610_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 610 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "!"`
        V2 { e: SynE },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "!" e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "!" e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 610 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "!"`
                    CtxE::V2 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_611_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 611 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "!"`
        V1 { e: SynE },
        /// `e -> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "!" e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> "!" e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> "!" e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V1 { e })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 611 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "!"`
                    CtxE::V1 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> e "*" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_612_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 612 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(6), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(6), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::NT(6), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "!" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "!" e_6 e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> "!" e_6 e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> "!" e_6 e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 612 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "!" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "*" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_613_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 613 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 9, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V2 { e: [SynE; 2] },
        /// `e -> <P> e "!" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "!" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 613 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> <P> e "!" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_614_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 614 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> <P> e "!" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V3 { e: [SynE; 2] },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "!" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "!" e_4 e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let ctx = CtxE::V4 { num };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 614 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <P> e "!" e`
                    CtxE::V2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::V3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_630_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 630 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+"`
        V2 { e: SynE },
        /// `e -> "!" e`
        V3 { e: SynE },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_1
                        4 |                                         // e_2 -> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V3 { e })
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 630 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+"`
                    CtxE::V2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> "!" e`
                    CtxE::V3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_631_1 {
    use crate::integration::wrappers::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 631 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> e "+"`
        V2 { e: SynE },
        /// `e -> <R> "!" e`
        V3 { e: SynE },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_1
                        4 |                                         // e_2 -> <R> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V3 { e })
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 631 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+"`
                    CtxE::V2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> <R> "!" e`
                    CtxE::V3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_632_1 {
    use crate::integration::wrappers::precedence_type::{SynE, TestApi};

    // ------------------------------------------------------------
    // [wrapper source for rule 632 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, alt::Alternative, fixed_sym_table::FixedSymTable, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser, Symbol, Terminate}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static INIT_OPCODES: [OpCode; 2] = [OpCode::End, OpCode::NT(0)];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {{
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            INIT_OPCODES.to_vec(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }}

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        V1 { e: [SynE; 2] },
        /// `e -> <R> e "+"`
        V2 { e: SynE },
        /// `e -> "!" e`
        V3 { e: SynE },
        /// `e -> Num`
        V4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> <R> "+" e_1
                        4 |                                         // e_2 -> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V1 { e: [e_1, e_2] })
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V2 { e })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V3 { e })
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxE::V4 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 632 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_core::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::integration::wrappers::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::integration::wrappers::precedence_type::{get_stream, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE, _span: PosSpan) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE, _spans: Vec<PosSpan>) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::V1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <R> e "+"`
                    CtxE::V2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> "!" e`
                    CtxE::V3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::V4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}

// ================================================================================

// #[allow(unused)]
pub(crate) mod rules_640_1 {
    #![allow(unused_imports)]

    use crate::integration::wrappers::level_string::LevelString;

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(pub LevelString);

    // ------------------------------------------------------------
    // [wrapper source for rule 640 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_640_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> "-" e`
        V1 { e: SynE },
        /// `e -> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> e "/" <P> e`
        V3 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V4 { e: [SynE; 2] },
        /// `e -> e "-" <P> e`
        V5 { e: [SynE; 2] },
        /// `e -> Id`
        V6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "/" e_4 e_1
                        3 |                                         // e_1 -> "+" e_2 e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> "-" e_2 e_1
                        7 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> "/" e_4 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V4 { e: [e_1, e_2] })
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V5 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V1 { e })
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxE::V6 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 640 #1, start e]
    // ------------------------------------------------------------
}

pub(crate) mod rules_641_1 {
    #![allow(unused_imports)]

    use crate::integration::wrappers::level_string::LevelString;

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(pub LevelString);

    // ------------------------------------------------------------
    // [wrapper source for rule 641 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_641_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> "-" e`
        V1 { e: SynE },
        /// `e -> <R> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> <R> e "/" <P> e`
        V3 { e: [SynE; 2] },
        /// `e -> <R> e "+" e`
        V4 { e: [SynE; 2] },
        /// `e -> <R> e "-" <P> e`
        V5 { e: [SynE; 2] },
        /// `e -> Id`
        V6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "*" e_2 e_1
                        2 |                                         // e_1 -> <R> "/" e_2 e_1
                        3 |                                         // e_1 -> <R> "+" e e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> <R> "-" e e_1
                        7 => self.exit_e1(1),                       // e_3 -> <R> "*" e_2 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> <R> "/" e_2 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V4 { e: [e_1, e_2] })
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V5 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V1 { e })
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxE::V6 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 641 #1, start e]
    // ------------------------------------------------------------
}

pub(crate) mod rules_642_1 {
    #![allow(unused_imports)]

    use crate::integration::wrappers::level_string::LevelString;

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(pub LevelString);

    // ------------------------------------------------------------
    // [wrapper source for rule 642 #1, start e]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_642_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> "-" e`
        V1 { e: SynE },
        /// `e -> <R> e "*" e`
        V2 { e: [SynE; 2] },
        /// `e -> <R> e "/" <P> e`
        V3 { e: [SynE; 2] },
        /// `e -> e "+" e`
        V4 { e: [SynE; 2] },
        /// `e -> e "-" <P> e`
        V5 { e: [SynE; 2] },
        /// `e -> Id`
        V6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, e: SynE, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, ctx: CtxE, spans: Vec<PosSpan>) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "*" e_2 e_1
                        2 |                                         // e_1 -> <R> "/" e_2 e_1
                        3 |                                         // e_1 -> "+" e_2 e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> "-" e_2 e_1
                        7 => self.exit_e1(1),                       // e_3 -> <R> "*" e_2 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> <R> "/" e_2 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_e();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V2 { e: [e_1, e_2] })
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V3 { e: [e_1, e_2] })
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V4 { e: [e_1, e_2] })
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    (3, CtxE::V5 { e: [e_1, e_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    (2, CtxE::V1 { e })
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxE::V6 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_e(ctx, spans);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 642 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_650_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 650 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_650_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A a a`
        V1 { a: [SynA; 3], a1: String },
        /// `a -> B`
        V2 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 => self.exit_a1(),                        // a_1 -> A a a_2 a_1
                        3 => self.exit_a2(),                        // a_2 -> B
                        0 => {}                                     // a -> a_2 a_1 (not used)
                        2 => {}                                     // a_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a1(&mut self) {
            let a_3 = self.stack.pop().unwrap().get_a();
            let a_2 = self.stack.pop().unwrap().get_a();
            let a1 = self.stack_t.pop().unwrap();
            let a_1 = self.stack.pop().unwrap().get_a();
            let ctx = CtxA::V1 { a: [a_1, a_2, a_3], a1 };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxA::V2 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 650 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_705_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 705 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_705_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A`
        V1 { a: String },
        /// `a -> A B`
        V2 { a: String, b: String },
        /// `a -> A B C`
        V3 { a: String, b: String, c: String },
        /// `a -> A B D`
        V4 { a: String, b: String, d: String },
        /// `a -> E`
        V5 { e: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // a -> E
                        3 |                                         // a_1 -> ε
                        4 |                                         // a_2 -> C
                        5 |                                         // a_2 -> D
                        6 => self.exit_a(alt_id),                   // a_2 -> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                     /* 2 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    (1, CtxA::V5 { e })
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    (1, CtxA::V1 { a })
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    (3, CtxA::V3 { a, b, c })
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    (3, CtxA::V4 { a, b, d })
                }
                6 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    (2, CtxA::V2 { a, b })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 705 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_810_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 810 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_810_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A* B a`
        V1 { star: SynA1, b: String, a: SynA },
        /// `a -> C`
        V2 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A*` array in `a ->  ►► A* ◄◄  B a | C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> a_1 B a
                        1 => self.exit_a(alt_id),                   // a -> C
                        2 => self.exit_a1(),                        // a_1 -> A a_1
                        3 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let a = self.stack.pop().unwrap().get_a();
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    (3, CtxA::V1 { star, b, a })
                }
                1 => {
                    let c = self.stack_t.pop().unwrap();
                    (1, CtxA::V2 { c })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(a);
        }
    }

    // [wrapper source for rule 810 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_811_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 811 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_811_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A+ B a`
        V1 { plus: SynA1, b: String, a: SynA },
        /// `a -> C`
        V2 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A+` array in `a ->  ►► A+ ◄◄  B a | C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> a_1 B a
                        1 => self.exit_a(alt_id),                   // a -> C
                        3 |                                         // a_2 -> a_1
                        4 => self.exit_a1(),                        // a_2 -> ε
                     /* 2 */                                        // a_1 -> A a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let a = self.stack.pop().unwrap().get_a();
                    let b = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_a1();
                    (3, CtxA::V1 { plus, b, a })
                }
                1 => {
                    let c = self.stack_t.pop().unwrap();
                    (1, CtxA::V2 { c })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(a);
        }
    }

    // [wrapper source for rule 811 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_820_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 820 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_820_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A* C`
        V1 { a: SynA, star: SynA1, c: String },
        /// `a -> B`
        V2 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A*` array in `a -> a  ►► A* ◄◄  C | B`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        #[allow(unused_variables)]
        fn exitloop_a(&mut self, a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> B a_2
                        1 => self.exit_a1(),                        // a_1 -> A a_1
                        2 => {}                                     // a_1 -> ε
                        3 => self.exit_a2(),                        // a_2 -> a_1 C a_2
                        4 => self.exitloop_a2(),                    // a_2 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxA::V2 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            star_acc.push(a);
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let ctx = CtxA::V1 { a, star, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 820 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_821_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 821 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_821_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A+ C`
        V1 { a: SynA, plus: SynA1, c: String },
        /// `a -> B`
        V2 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A+` array in `a -> a  ►► A+ ◄◄  C | B`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        #[allow(unused_variables)]
        fn exitloop_a(&mut self, a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 | 3 => {}                                 // a_2, a_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> B a_2
                        4 |                                         // a_3 -> a_1
                        5 => self.exit_a1(),                        // a_3 -> ε
                        2 => self.exit_a2(),                        // a_2 -> a_1 C a_2
                        3 => self.exitloop_a2(),                    // a_2 -> ε
                     /* 1 */                                        // a_1 -> A a_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let ctx = CtxA::V2 { b };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let a = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(a);
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let ctx = CtxA::V1 { a, plus, c };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 821 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

#[allow(unused)]
pub(crate) mod rules_835_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 835 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_835_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a "x" a`
        V1 { a: [SynA; 2] },
        /// `a -> a "*" "[" Num+ "]"`
        V2 { a: SynA, plus: SynA1 },
        /// `a -> "-" a`
        V3 { a: SynA },
        /// `a -> Id`
        V4 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `Num+` array in `a -> a "x" a | a "*" "["  ►► Num+ ◄◄  "]" | "-" a | Id`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 ..= 4 => {}                               // a_2, a_3, a_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        7 |                                         // a_4 -> a_1
                        8 => self.exit_a1(),                        // a_4 -> ε
                        2 |                                         // a_2 -> "x" a_3 a_2
                        3 => self.exit_a2(alt_id),                  // a_2 -> "*" "[" a_1 "]" a_2
                        5 |                                         // a_3 -> "-" a
                        6 => self.exit_a3(alt_id),                  // a_3 -> Id
                        0 => {}                                     // a -> a_3 a_2 (not used)
                     /* 1 */                                        // a_1 -> Num a_4 (never called)
                        4 => {}                                     // a_2 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let num = self.stack_t.pop().unwrap();
            let Some(SynValue::A1(SynA1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_acc.push(num);
        }

        fn exit_a2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                2 => {
                    let a_2 = self.stack.pop().unwrap().get_a();
                    let a_1 = self.stack.pop().unwrap().get_a();
                    (3, CtxA::V1 { a: [a_1, a_2] })
                }
                3 => {
                    let plus = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    (5, CtxA::V2 { a, plus })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a3(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    (2, CtxA::V3 { a })
                }
                6 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxA::V4 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a3")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 835 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_862_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 862 #1, start expr]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_862_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Num "^" expr`
        V1 { expr: SynExpr, num: String },
        /// `expr -> Num`
        V2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, expr: SynExpr, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 0) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.init_expr(),                      // expr
                        1 => {}                                     // expr_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // expr_1 -> "^" expr
                        2 => self.exit_expr(alt_id),                // expr_1 -> ε
                     /* 0 */                                        // expr -> <L> Num expr_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_expr();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    (3, CtxExpr::V1 { expr, num })
                }
                2 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    (2, CtxExpr::V2 { expr, num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_expr(ctx, spans);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 862 #1, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_870_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 870 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_870_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A`
        V1 { a: SynA, a1: String },
        /// `a -> B C`
        V2 { b: String, c: String },
        /// `a -> B D`
        V3 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        #[allow(unused_variables)]
        fn exitloop_a(&mut self, a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // a_2 -> C a_1
                        4 => self.inter_a(alt_id),                  // a_2 -> D a_1
                        1 => self.exit_a1(),                        // a_1 -> A a_1
                        2 => self.exitloop_a1(),                    // a_1 -> ε
                     /* 0 */                                        // a -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    (2, CtxA::V2 { b, c })
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    (2, CtxA::V3 { b, d })
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_a")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self) {
            let a1 = self.stack_t.pop().unwrap();
            let a = self.stack.pop().unwrap().get_a();
            let ctx = CtxA::V1 { a, a1 };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 870 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_871_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 871 #1, start a]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_871_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A B`
        V1 { a: SynA, a1: String, b: String },
        /// `a -> a A C`
        V2 { a: SynA, a1: String, c: String },
        /// `a -> D`
        V3 { d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, a: SynA, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, ctx: CtxA, spans: Vec<PosSpan>) -> SynA;
        #[allow(unused_variables)]
        fn exitloop_a(&mut self, a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> D a_1
                        3 |                                         // a_2 -> B a_1
                        4 => self.exit_a1(alt_id),                  // a_2 -> C a_1
                        2 => self.exitloop_a1(),                    // a_1 -> ε
                     /* 1 */                                        // a_1 -> A a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_a();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let ctx = CtxA::V3 { d };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                3 => {
                    let b = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    (3, CtxA::V1 { a, a1, b })
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    (3, CtxA::V2 { a, a1, c })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_a(ctx, spans);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 871 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 44: rules RTS(100) #1, start 0:

pub(crate) mod rules_901_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 901 #1, start file]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_901_1::*;

    #[derive(Debug)]
    pub enum CtxFile {
        /// `file -> header file_item*`
        V1 { header: SynHeader, star: SynFile1 },
        /// `file -> file_item*`
        V2 { star: SynFile1 },
    }
    #[derive(Debug)]
    pub enum CtxFileItem {
        /// `file_item -> option`
        V1 { option: SynOption },
        /// `file_item -> declaration`
        V2 { declaration: SynDeclaration },
        /// `file_item -> rule`
        V3 { rule: SynRule },
    }
    #[derive(Debug)]
    pub enum CtxHeader {
        /// `header -> "lexicon" Id ";"`
        V1 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxDeclaration {
        /// `declaration -> "mode" Id ";"`
        V1 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxOption {
        /// `option -> "channels" "{" Id ("," Id)* "}"`
        V1 { star: SynOption1 },
    }
    #[derive(Debug)]
    pub enum CtxRule {
        /// `rule -> "fragment" Id ":" match ";"`
        V1 { id: String, match1: SynMatch },
        /// `rule -> Id ":" match "->" actions ";"`
        V2 { id: String, match1: SynMatch, actions: SynActions },
        /// `rule -> Id ":" match ";"`
        V3 { id: String, match1: SynMatch },
    }
    #[derive(Debug)]
    pub enum CtxActions {
        /// `actions -> action ("," action)*`
        V1 { star: SynActions1 },
    }
    #[derive(Debug)]
    pub enum CtxAction {
        /// `action -> "mode" "(" Id ")"`
        V1 { id: String },
        /// `action -> "push" "(" Id ")"`
        V2 { id: String },
        /// `action -> "pop"`
        V3,
        /// `action -> "skip"`
        V4,
        /// `action -> "more"`
        V5,
        /// `action -> "type" "(" Id ")"`
        V6 { id: String },
        /// `action -> "channel" "(" Id ")"`
        V7 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxMatch {
        /// `match -> alt_items`
        V1 { alt_items: SynAltItems },
    }
    #[derive(Debug)]
    pub enum CtxAltItems {
        /// `alt_items -> alt_item ("|" alt_item)*`
        V1 { star: SynAltItems1 },
    }
    #[derive(Debug)]
    pub enum CtxAltItem {
        /// `alt_item -> repeat_item+`
        V1 { plus: SynAltItem1 },
    }
    #[derive(Debug)]
    pub enum CtxRepeatItem {
        /// `repeat_item -> item "*" "?"`
        V1 { item: SynItem },
        /// `repeat_item -> item "*"`
        V2 { item: SynItem },
        /// `repeat_item -> item "+" "?"`
        V3 { item: SynItem },
        /// `repeat_item -> item "+"`
        V4 { item: SynItem },
        /// `repeat_item -> item "?"`
        V5 { item: SynItem },
        /// `repeat_item -> item`
        V6 { item: SynItem },
    }
    #[derive(Debug)]
    pub enum CtxItem {
        /// `item -> Id`
        V1 { id: String },
        /// `item -> CharLit ".." CharLit`
        V2 { charlit: [String; 2] },
        /// `item -> CharLit`
        V3 { charlit: String },
        /// `item -> StrLit`
        V4 { strlit: String },
        /// `item -> char_set`
        V5 { char_set: SynCharSet },
        /// `item -> "(" alt_items ")"`
        V6 { alt_items: SynAltItems },
        /// `item -> "~" item`
        V7 { item: SynItem },
    }
    #[derive(Debug)]
    pub enum CtxCharSet {
        /// `char_set -> "[" char_set_one+ "]"`
        V1 { plus: SynCharSet1 },
        /// `char_set -> "."`
        V2,
        /// `char_set -> FixedSet`
        V3 { fixedset: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSetOne {
        /// `char_set_one -> SetChar "-" SetChar`
        V1 { setchar: [String; 2] },
        /// `char_set_one -> SetChar`
        V2 { setchar: String },
        /// `char_set_one -> FixedSet`
        V3 { fixedset: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `file`
    // #[derive(Debug, PartialEq)] pub struct SynFile();
    // /// User-defined type for `file_item`
    // #[derive(Debug, PartialEq)] pub struct SynFileItem();
    // /// User-defined type for `header`
    // #[derive(Debug, PartialEq)] pub struct SynHeader();
    // /// User-defined type for `declaration`
    // #[derive(Debug, PartialEq)] pub struct SynDeclaration();
    // /// User-defined type for `option`
    // #[derive(Debug, PartialEq)] pub struct SynOption();
    // /// User-defined type for `rule`
    // #[derive(Debug, PartialEq)] pub struct SynRule();
    // /// User-defined type for `actions`
    // #[derive(Debug, PartialEq)] pub struct SynActions();
    // /// User-defined type for `action`
    // #[derive(Debug, PartialEq)] pub struct SynAction();
    // /// User-defined type for `match`
    // #[derive(Debug, PartialEq)] pub struct SynMatch();
    // /// User-defined type for `alt_items`
    // #[derive(Debug, PartialEq)] pub struct SynAltItems();
    // /// User-defined type for `alt_item`
    // #[derive(Debug, PartialEq)] pub struct SynAltItem();
    // /// User-defined type for `repeat_item`
    // #[derive(Debug, PartialEq)] pub struct SynRepeatItem();
    // /// User-defined type for `item`
    // #[derive(Debug, PartialEq)] pub struct SynItem();
    // /// User-defined type for `char_set`
    // #[derive(Debug, PartialEq)] pub struct SynCharSet();
    // /// User-defined type for `char_set_one`
    // #[derive(Debug, PartialEq)] pub struct SynCharSetOne();
    /// Computed `file_item*` array in `file -> header  ►► file_item* ◄◄  |  ►► file_item* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynFile1(pub Vec<SynFileItem>);
    /// Computed `("," Id)*` array in `option -> "channels" "{" Id  ►► ("," Id)* ◄◄  "}"`
    #[derive(Debug, PartialEq)]
    pub struct SynOption1(pub Vec<String>);
    /// Computed `("," action)*` array in `actions -> action  ►► ("," action)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynActions1(pub Vec<SynAction>);
    /// Computed `("|" alt_item)*` array in `alt_items -> alt_item  ►► ("|" alt_item)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItems1(pub Vec<SynAltItem>);
    /// Computed `repeat_item+` array in `alt_item ->  ►► repeat_item+ ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItem1(pub Vec<SynRepeatItem>);
    /// Computed `char_set_one+` array in `char_set -> "["  ►► char_set_one+ ◄◄  "]" | "." | FixedSet`
    #[derive(Debug, PartialEq)]
    pub struct SynCharSet1(pub Vec<SynCharSetOne>);

    #[derive(Debug)]
    enum SynValue { File(SynFile), FileItem(SynFileItem), Header(SynHeader), Declaration(SynDeclaration), Option(SynOption), Rule(SynRule), Actions(SynActions), Action(SynAction), Match(SynMatch), AltItems(SynAltItems), AltItem(SynAltItem), RepeatItem(SynRepeatItem), Item(SynItem), CharSet(SynCharSet), CharSetOne(SynCharSetOne), File1(SynFile1), Option1(SynOption1), Actions1(SynActions1), AltItems1(SynAltItems1), AltItem1(SynAltItem1), CharSet1(SynCharSet1) }

    impl SynValue {
        fn get_file(self) -> SynFile {
            if let SynValue::File(val) = self { val } else { panic!() }
        }
        fn get_file_item(self) -> SynFileItem {
            if let SynValue::FileItem(val) = self { val } else { panic!() }
        }
        fn get_header(self) -> SynHeader {
            if let SynValue::Header(val) = self { val } else { panic!() }
        }
        fn get_declaration(self) -> SynDeclaration {
            if let SynValue::Declaration(val) = self { val } else { panic!() }
        }
        fn get_option(self) -> SynOption {
            if let SynValue::Option(val) = self { val } else { panic!() }
        }
        fn get_rule(self) -> SynRule {
            if let SynValue::Rule(val) = self { val } else { panic!() }
        }
        fn get_actions(self) -> SynActions {
            if let SynValue::Actions(val) = self { val } else { panic!() }
        }
        fn get_action(self) -> SynAction {
            if let SynValue::Action(val) = self { val } else { panic!() }
        }
        fn get_match(self) -> SynMatch {
            if let SynValue::Match(val) = self { val } else { panic!() }
        }
        fn get_alt_items(self) -> SynAltItems {
            if let SynValue::AltItems(val) = self { val } else { panic!() }
        }
        fn get_alt_item(self) -> SynAltItem {
            if let SynValue::AltItem(val) = self { val } else { panic!() }
        }
        fn get_repeat_item(self) -> SynRepeatItem {
            if let SynValue::RepeatItem(val) = self { val } else { panic!() }
        }
        fn get_item(self) -> SynItem {
            if let SynValue::Item(val) = self { val } else { panic!() }
        }
        fn get_char_set(self) -> SynCharSet {
            if let SynValue::CharSet(val) = self { val } else { panic!() }
        }
        fn get_char_set_one(self) -> SynCharSetOne {
            if let SynValue::CharSetOne(val) = self { val } else { panic!() }
        }
        fn get_file1(self) -> SynFile1 {
            if let SynValue::File1(val) = self { val } else { panic!() }
        }
        fn get_option1(self) -> SynOption1 {
            if let SynValue::Option1(val) = self { val } else { panic!() }
        }
        fn get_actions1(self) -> SynActions1 {
            if let SynValue::Actions1(val) = self { val } else { panic!() }
        }
        fn get_alt_items1(self) -> SynAltItems1 {
            if let SynValue::AltItems1(val) = self { val } else { panic!() }
        }
        fn get_alt_item1(self) -> SynAltItem1 {
            if let SynValue::AltItem1(val) = self { val } else { panic!() }
        }
        fn get_char_set1(self) -> SynCharSet1 {
            if let SynValue::CharSet1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, file: SynFile, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_file(&mut self) {}
        fn exit_file(&mut self, ctx: CtxFile, spans: Vec<PosSpan>) -> SynFile;
        fn init_file_item(&mut self) {}
        fn exit_file_item(&mut self, ctx: CtxFileItem, spans: Vec<PosSpan>) -> SynFileItem;
        fn init_header(&mut self) {}
        fn exit_header(&mut self, ctx: CtxHeader, spans: Vec<PosSpan>) -> SynHeader;
        fn init_declaration(&mut self) {}
        fn exit_declaration(&mut self, ctx: CtxDeclaration, spans: Vec<PosSpan>) -> SynDeclaration;
        fn init_option(&mut self) {}
        fn exit_option(&mut self, ctx: CtxOption, spans: Vec<PosSpan>) -> SynOption;
        fn init_rule(&mut self) {}
        fn exit_rule(&mut self, ctx: CtxRule, spans: Vec<PosSpan>) -> SynRule;
        fn init_actions(&mut self) {}
        fn exit_actions(&mut self, ctx: CtxActions, spans: Vec<PosSpan>) -> SynActions;
        fn init_action(&mut self) {}
        fn exit_action(&mut self, ctx: CtxAction, spans: Vec<PosSpan>) -> SynAction;
        fn init_match(&mut self) {}
        fn exit_match(&mut self, ctx: CtxMatch, spans: Vec<PosSpan>) -> SynMatch;
        fn init_alt_items(&mut self) {}
        fn exit_alt_items(&mut self, ctx: CtxAltItems, spans: Vec<PosSpan>) -> SynAltItems;
        fn init_alt_item(&mut self) {}
        fn exit_alt_item(&mut self, ctx: CtxAltItem, spans: Vec<PosSpan>) -> SynAltItem;
        fn init_repeat_item(&mut self) {}
        fn exit_repeat_item(&mut self, ctx: CtxRepeatItem, spans: Vec<PosSpan>) -> SynRepeatItem;
        fn init_item(&mut self) {}
        fn exit_item(&mut self, ctx: CtxItem, spans: Vec<PosSpan>) -> SynItem;
        fn init_char_set(&mut self) {}
        fn exit_char_set(&mut self, ctx: CtxCharSet, spans: Vec<PosSpan>) -> SynCharSet;
        fn init_char_set_one(&mut self) {}
        fn exit_char_set_one(&mut self, ctx: CtxCharSetOne, spans: Vec<PosSpan>) -> SynCharSetOne;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 15 | 19 | 20) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_file(),             // file
                        15 => self.init_file1(),                    // file_1
                        1 => self.listener.init_file_item(),        // file_item
                        2 => self.listener.init_header(),           // header
                        3 => self.listener.init_declaration(),      // declaration
                        4 => self.listener.init_option(),           // option
                        16 => self.init_option1(),                  // option_1
                        5 => self.listener.init_rule(),             // rule
                        21 => {}                                    // rule_1
                        6 => self.listener.init_actions(),          // actions
                        17 => self.init_actions1(),                 // actions_1
                        7 => self.listener.init_action(),           // action
                        8 => self.listener.init_match(),            // match
                        9 => self.listener.init_alt_items(),        // alt_items
                        18 => self.init_alt_items1(),               // alt_items_1
                        10 => self.listener.init_alt_item(),        // alt_item
                        19 => self.init_alt_item1(),                // alt_item_1
                        25 => {}                                    // alt_item_2
                        11 => self.listener.init_repeat_item(),     // repeat_item
                        22 => {}                                    // repeat_item_1
                        27 | 28 => {}                               // repeat_item_2, repeat_item_3
                        12 => self.listener.init_item(),            // item
                        23 => {}                                    // item_1
                        13 => self.listener.init_char_set(),        // char_set
                        20 => self.init_char_set1(),                // char_set_1
                        26 => {}                                    // char_set_2
                        14 => self.listener.init_char_set_one(),    // char_set_one
                        24 => {}                                    // char_set_one_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // file -> header file_1
                        1 => self.exit_file(alt_id),                // file -> file_1
                        33 => self.exit_file1(),                    // file_1 -> file_item file_1
                        34 => {}                                    // file_1 -> ε
                        2 |                                         // file_item -> option
                        3 |                                         // file_item -> declaration
                        4 => self.exit_file_item(alt_id),           // file_item -> rule
                        5 => self.exit_header(),                    // header -> "lexicon" Id ";"
                        6 => self.exit_declaration(),               // declaration -> "mode" Id ";"
                        7 => self.exit_option(),                    // option -> "channels" "{" Id option_1 "}"
                        35 => self.exit_option1(),                  // option_1 -> "," Id option_1
                        36 => {}                                    // option_1 -> ε
                        8 |                                         // rule -> "fragment" Id ":" match ";"
                        43 |                                        // rule_1 -> "->" actions ";"
                        44 => self.exit_rule(alt_id),               // rule_1 -> ";"
                     /* 9 */                                        // rule -> Id ":" match rule_1 (never called)
                        10 => self.exit_actions(),                  // actions -> action actions_1
                        37 => self.exit_actions1(),                 // actions_1 -> "," action actions_1
                        38 => {}                                    // actions_1 -> ε
                        11 |                                        // action -> "mode" "(" Id ")"
                        12 |                                        // action -> "push" "(" Id ")"
                        13 |                                        // action -> "pop"
                        14 |                                        // action -> "skip"
                        15 |                                        // action -> "more"
                        16 |                                        // action -> "type" "(" Id ")"
                        17 => self.exit_action(alt_id),             // action -> "channel" "(" Id ")"
                        18 => self.exit_match(),                    // match -> alt_items
                        19 => self.exit_alt_items(),                // alt_items -> alt_item alt_items_1
                        39 => self.exit_alt_items1(),               // alt_items_1 -> "|" alt_item alt_items_1
                        40 => {}                                    // alt_items_1 -> ε
                        20 => self.exit_alt_item(),                 // alt_item -> alt_item_1
                        53 |                                        // alt_item_2 -> alt_item_1
                        54 => self.exit_alt_item1(),                // alt_item_2 -> ε
                     /* 41 */                                       // alt_item_1 -> repeat_item alt_item_2 (never called)
                        46 |                                        // repeat_item_1 -> "?"
                        48 |                                        // repeat_item_1 -> ε
                        57 |                                        // repeat_item_2 -> "?"
                        58 |                                        // repeat_item_2 -> ε
                        59 |                                        // repeat_item_3 -> "?"
                        60 => self.exit_repeat_item(alt_id),        // repeat_item_3 -> ε
                     /* 21 */                                       // repeat_item -> item repeat_item_1 (never called)
                     /* 45 */                                       // repeat_item_1 -> "+" repeat_item_2 (never called)
                     /* 47 */                                       // repeat_item_1 -> "*" repeat_item_3 (never called)
                        22 |                                        // item -> "(" alt_items ")"
                        23 |                                        // item -> "~" item
                        24 |                                        // item -> Id
                        26 |                                        // item -> StrLit
                        27 |                                        // item -> char_set
                        49 |                                        // item_1 -> ".." CharLit
                        50 => self.exit_item(alt_id),               // item_1 -> ε
                     /* 25 */                                       // item -> CharLit item_1 (never called)
                        28 |                                        // char_set -> "[" char_set_1 "]"
                        29 |                                        // char_set -> "."
                        30 => self.exit_char_set(alt_id),           // char_set -> FixedSet
                        55 |                                        // char_set_2 -> char_set_1
                        56 => self.exit_char_set1(),                // char_set_2 -> ε
                     /* 42 */                                       // char_set_1 -> char_set_one char_set_2 (never called)
                        31 |                                        // char_set_one -> FixedSet
                        51 |                                        // char_set_one_1 -> "-" SetChar
                        52 => self.exit_char_set_one(alt_id),       // char_set_one_1 -> ε
                     /* 32 */                                       // char_set_one -> SetChar char_set_one_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_file();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_file(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                0 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    let header = self.stack.pop().unwrap().get_header();
                    (2, CtxFile::V1 { header, star })
                }
                1 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    (1, CtxFile::V2 { star })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_file(ctx, spans);
            self.stack.push(SynValue::File(val));
        }

        fn init_file1(&mut self) {
            let val = SynFile1(Vec::new());
            self.stack.push(SynValue::File1(val));
        }

        fn exit_file1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let file_item = self.stack.pop().unwrap().get_file_item();
            let Some(SynValue::File1(SynFile1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynFile1 item on wrapper stack");
            };
            star_acc.push(file_item);
        }

        fn exit_file_item(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                2 => {
                    let option = self.stack.pop().unwrap().get_option();
                    (1, CtxFileItem::V1 { option })
                }
                3 => {
                    let declaration = self.stack.pop().unwrap().get_declaration();
                    (1, CtxFileItem::V2 { declaration })
                }
                4 => {
                    let rule = self.stack.pop().unwrap().get_rule();
                    (1, CtxFileItem::V3 { rule })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file_item")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_file_item(ctx, spans);
            self.stack.push(SynValue::FileItem(val));
        }

        fn exit_header(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxHeader::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_header(ctx, spans);
            self.stack.push(SynValue::Header(val));
        }

        fn exit_declaration(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxDeclaration::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_declaration(ctx, spans);
            self.stack.push(SynValue::Declaration(val));
        }

        fn exit_option(&mut self) {
            let star = self.stack.pop().unwrap().get_option1();
            let ctx = CtxOption::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 4 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_option(ctx, spans);
            self.stack.push(SynValue::Option(val));
        }

        fn init_option1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let id = self.stack_t.pop().unwrap();
            self.stack.push(SynValue::Option1(SynOption1(vec![id])));
        }

        fn exit_option1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let id = self.stack_t.pop().unwrap();
            let Some(SynValue::Option1(SynOption1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynOption1 item on wrapper stack");
            };
            star_acc.push(id);
        }

        fn exit_rule(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                8 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    (5, CtxRule::V1 { id, match1 })
                }
                43 => {
                    let actions = self.stack.pop().unwrap().get_actions();
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    (6, CtxRule::V2 { id, match1, actions })
                }
                44 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxRule::V3 { id, match1 })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_rule")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_rule(ctx, spans);
            self.stack.push(SynValue::Rule(val));
        }

        fn exit_actions(&mut self) {
            let star = self.stack.pop().unwrap().get_actions1();
            let ctx = CtxActions::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_actions(ctx, spans);
            self.stack.push(SynValue::Actions(val));
        }

        fn init_actions1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let action = self.stack.pop().unwrap().get_action();
            self.stack.push(SynValue::Actions1(SynActions1(vec![action])));
        }

        fn exit_actions1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let action = self.stack.pop().unwrap().get_action();
            let Some(SynValue::Actions1(SynActions1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynActions1 item on wrapper stack");
            };
            star_acc.push(action);
        }

        fn exit_action(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxAction::V1 { id })
                }
                12 => {
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxAction::V2 { id })
                }
                13 => {
                    (1, CtxAction::V3)
                }
                14 => {
                    (1, CtxAction::V4)
                }
                15 => {
                    (1, CtxAction::V5)
                }
                16 => {
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxAction::V6 { id })
                }
                17 => {
                    let id = self.stack_t.pop().unwrap();
                    (4, CtxAction::V7 { id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_action")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_action(ctx, spans);
            self.stack.push(SynValue::Action(val));
        }

        fn exit_match(&mut self) {
            let alt_items = self.stack.pop().unwrap().get_alt_items();
            let ctx = CtxMatch::V1 { alt_items };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_match(ctx, spans);
            self.stack.push(SynValue::Match(val));
        }

        fn exit_alt_items(&mut self) {
            let star = self.stack.pop().unwrap().get_alt_items1();
            let ctx = CtxAltItems::V1 { star };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_alt_items(ctx, spans);
            self.stack.push(SynValue::AltItems(val));
        }

        fn init_alt_items1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            self.stack.push(SynValue::AltItems1(SynAltItems1(vec![alt_item])));
        }

        fn exit_alt_items1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let Some(SynValue::AltItems1(SynAltItems1(star_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynAltItems1 item on wrapper stack");
            };
            star_acc.push(alt_item);
        }

        fn exit_alt_item(&mut self) {
            let plus = self.stack.pop().unwrap().get_alt_item1();
            let ctx = CtxAltItem::V1 { plus };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_alt_item(ctx, spans);
            self.stack.push(SynValue::AltItem(val));
        }

        fn init_alt_item1(&mut self) {
            let val = SynAltItem1(Vec::new());
            self.stack.push(SynValue::AltItem1(val));
        }

        fn exit_alt_item1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let repeat_item = self.stack.pop().unwrap().get_repeat_item();
            let Some(SynValue::AltItem1(SynAltItem1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynAltItem1 item on wrapper stack");
            };
            plus_acc.push(repeat_item);
        }

        fn exit_repeat_item(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                46 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (2, CtxRepeatItem::V5 { item })
                }
                48 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (1, CtxRepeatItem::V6 { item })
                }
                57 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (3, CtxRepeatItem::V3 { item })
                }
                58 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (2, CtxRepeatItem::V4 { item })
                }
                59 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (3, CtxRepeatItem::V1 { item })
                }
                60 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (2, CtxRepeatItem::V2 { item })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_repeat_item")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_repeat_item(ctx, spans);
            self.stack.push(SynValue::RepeatItem(val));
        }

        fn exit_item(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                22 => {
                    let alt_items = self.stack.pop().unwrap().get_alt_items();
                    (3, CtxItem::V6 { alt_items })
                }
                23 => {
                    let item = self.stack.pop().unwrap().get_item();
                    (2, CtxItem::V7 { item })
                }
                24 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxItem::V1 { id })
                }
                26 => {
                    let strlit = self.stack_t.pop().unwrap();
                    (1, CtxItem::V4 { strlit })
                }
                27 => {
                    let char_set = self.stack.pop().unwrap().get_char_set();
                    (1, CtxItem::V5 { char_set })
                }
                49 => {
                    let charlit_2 = self.stack_t.pop().unwrap();
                    let charlit_1 = self.stack_t.pop().unwrap();
                    (3, CtxItem::V2 { charlit: [charlit_1, charlit_2] })
                }
                50 => {
                    let charlit = self.stack_t.pop().unwrap();
                    (1, CtxItem::V3 { charlit })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_item")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_item(ctx, spans);
            self.stack.push(SynValue::Item(val));
        }

        fn exit_char_set(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                28 => {
                    let plus = self.stack.pop().unwrap().get_char_set1();
                    (3, CtxCharSet::V1 { plus })
                }
                29 => {
                    (1, CtxCharSet::V2)
                }
                30 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    (1, CtxCharSet::V3 { fixedset })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_char_set(ctx, spans);
            self.stack.push(SynValue::CharSet(val));
        }

        fn init_char_set1(&mut self) {
            let val = SynCharSet1(Vec::new());
            self.stack.push(SynValue::CharSet1(val));
        }

        fn exit_char_set1(&mut self) {
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let char_set_one = self.stack.pop().unwrap().get_char_set_one();
            let Some(SynValue::CharSet1(SynCharSet1(plus_acc))) = self.stack.last_mut() else {
                panic!("unexpected SynCharSet1 item on wrapper stack");
            };
            plus_acc.push(char_set_one);
        }

        fn exit_char_set_one(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                31 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    (1, CtxCharSetOne::V3 { fixedset })
                }
                51 => {
                    let setchar_2 = self.stack_t.pop().unwrap();
                    let setchar_1 = self.stack_t.pop().unwrap();
                    (3, CtxCharSetOne::V1 { setchar: [setchar_1, setchar_2] })
                }
                52 => {
                    let setchar = self.stack_t.pop().unwrap();
                    (1, CtxCharSetOne::V2 { setchar })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set_one")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_char_set_one(ctx, spans);
            self.stack.push(SynValue::CharSetOne(val));
        }
    }

    // [wrapper source for rule 901 #1, start file]
    // ------------------------------------------------------------
}

pub(crate) mod rules_902_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 902 #1, start program]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_902_1::*;

    #[derive(Debug)]
    pub enum CtxProgram {
        /// `program -> (<L> decl)* (<L> inst)+`
        V1 { star: SynDeclI, plus: SynInstI },
    }
    #[derive(Debug)]
    pub enum CtxDeclI {
        /// `<L> decl` iteration in `program -> ( ►► <L> decl ◄◄ )* (<L> inst)+`
        V1 { star_acc: SynDeclI, decl: SynDecl },
    }
    #[derive(Debug)]
    pub enum CtxInstI {
        /// `<L> inst` iteration in `program -> (<L> decl)* ( ►► <L> inst ◄◄ )+`
        V1 { plus_acc: SynInstI, inst: SynInst, last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxDecl {
        /// `decl -> Type Id (<L> "," Id)* ";"`
        V1 { type1: String, star: SynIdI },
        /// `decl -> "typedef" Type Id ";"`
        V2 { type1: String, id: String },
    }
    #[derive(Debug)]
    pub enum InitCtxIdI {
        /// value of `Id` before `<L> "," Id` iteration in `decl -> Type Id ( ►► <L> "," Id ◄◄ )* ";" | "typedef" Type Id ";"`
        V1 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxIdI {
        /// `<L> "," Id` iteration in `decl -> Type Id ( ►► <L> "," Id ◄◄ )* ";" | "typedef" Type Id ";"`
        V1 { star_acc: SynIdI, id: String },
    }
    #[derive(Debug)]
    pub enum CtxInst {
        /// `inst -> "let" Id "=" expr ";"`
        V1 { id: String, expr: SynExpr },
        /// `inst -> "print" expr ";"`
        V2 { expr: SynExpr },
    }
    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> "-" expr`
        V1 { expr: SynExpr },
        /// `expr -> expr "+" expr`
        V2 { expr: [SynExpr; 2] },
        /// `expr -> expr <P> "-" expr`
        V3 { expr: [SynExpr; 2] },
        /// `expr -> Id`
        V4 { id: String },
        /// `expr -> Num`
        V5 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `program`
    // #[derive(Debug, PartialEq)] pub struct SynProgram();
    // /// User-defined type for `<L> decl` iteration in `program -> ( ►► <L> decl ◄◄ )* (<L> inst)+`
    // #[derive(Debug, PartialEq)] pub struct SynDeclI();
    // /// User-defined type for `<L> inst` iteration in `program -> (<L> decl)* ( ►► <L> inst ◄◄ )+`
    // #[derive(Debug, PartialEq)] pub struct SynInstI();
    // /// User-defined type for `decl`
    // #[derive(Debug, PartialEq)] pub struct SynDecl();
    // /// User-defined type for `<L> "," Id` iteration in `decl -> Type Id ( ►► <L> "," Id ◄◄ )* ";" | "typedef" Type Id ";"`
    // #[derive(Debug, PartialEq)] pub struct SynIdI();
    // /// User-defined type for `inst`
    // #[derive(Debug, PartialEq)] pub struct SynInst();
    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Program(SynProgram), DeclI(SynDeclI), InstI(SynInstI), Decl(SynDecl), IdI(SynIdI), Inst(SynInst), Expr(SynExpr) }

    impl SynValue {
        fn get_program(self) -> SynProgram {
            if let SynValue::Program(val) = self { val } else { panic!() }
        }
        fn get_decl_i(self) -> SynDeclI {
            if let SynValue::DeclI(val) = self { val } else { panic!() }
        }
        fn get_inst_i(self) -> SynInstI {
            if let SynValue::InstI(val) = self { val } else { panic!() }
        }
        fn get_decl(self) -> SynDecl {
            if let SynValue::Decl(val) = self { val } else { panic!() }
        }
        fn get_id_i(self) -> SynIdI {
            if let SynValue::IdI(val) = self { val } else { panic!() }
        }
        fn get_inst(self) -> SynInst {
            if let SynValue::Inst(val) = self { val } else { panic!() }
        }
        fn get_expr(self) -> SynExpr {
            if let SynValue::Expr(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, program: SynProgram, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_program(&mut self) {}
        fn exit_program(&mut self, ctx: CtxProgram, spans: Vec<PosSpan>) -> SynProgram;
        fn init_decl_i(&mut self) -> SynDeclI;
        fn exit_decl_i(&mut self, ctx: CtxDeclI, spans: Vec<PosSpan>) -> SynDeclI;
        #[allow(unused_variables)]
        fn exitloop_decl_i(&mut self, star_acc: &mut SynDeclI) {}
        fn init_inst_i(&mut self) -> SynInstI;
        fn exit_inst_i(&mut self, ctx: CtxInstI, spans: Vec<PosSpan>) -> SynInstI;
        fn init_decl(&mut self) {}
        fn exit_decl(&mut self, ctx: CtxDecl, spans: Vec<PosSpan>) -> SynDecl;
        fn init_id_i(&mut self, ctx: InitCtxIdI, spans: Vec<PosSpan>) -> SynIdI;
        fn exit_id_i(&mut self, ctx: CtxIdI, spans: Vec<PosSpan>) -> SynIdI;
        #[allow(unused_variables)]
        fn exitloop_id_i(&mut self, star_acc: &mut SynIdI) {}
        fn init_inst(&mut self) {}
        fn exit_inst(&mut self, ctx: CtxInst, spans: Vec<PosSpan>) -> SynInst;
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_program(),          // program
                        1 => self.init_decl_i(),                    // decl_i
                        2 => self.init_inst_i(),                    // inst_i
                        9 => {}                                     // inst_i_1
                        3 => self.listener.init_decl(),             // decl
                        4 => self.init_id_i(),                      // id_i
                        5 => self.listener.init_inst(),             // inst
                        6 => self.listener.init_expr(),             // expr
                        7 | 8 => {}                                 // expr_1, expr_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_program(),                   // program -> decl_i inst_i
                        1 => self.exit_decl_i(),                    // decl_i -> <L> decl decl_i
                        2 => self.exitloop_decl_i(),                // decl_i -> <L> ε
                        17 |                                        // inst_i_1 -> inst_i
                        18 => self.exit_inst_i(alt_id),             // inst_i_1 -> ε
                     /* 3 */                                        // inst_i -> <L> inst inst_i_1 (never called)
                        4 |                                         // decl -> Type Id id_i ";"
                        5 => self.exit_decl(alt_id),                // decl -> "typedef" Type Id ";"
                        6 => self.exit_id_i(),                      // id_i -> <L> "," Id id_i
                        7 => self.exitloop_id_i(),                  // id_i -> <L> ε
                        8 |                                         // inst -> "let" Id "=" expr ";"
                        9 => self.exit_inst(alt_id),                // inst -> "print" expr ";"
                        11 |                                        // expr_1 -> "+" expr_2 expr_1
                        12 => self.exit_expr1(alt_id),              // expr_1 -> "-" expr_2 expr_1
                        14 |                                        // expr_2 -> "-" expr_2
                        15 |                                        // expr_2 -> Id
                        16 => self.exit_expr2(alt_id),              // expr_2 -> Num
                        10 => {}                                    // expr -> expr_2 expr_1 (not used)
                        13 => {}                                    // expr_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let val = self.stack.pop().unwrap().get_program();
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(val, span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_program(&mut self) {
            let plus = self.stack.pop().unwrap().get_inst_i();
            let star = self.stack.pop().unwrap().get_decl_i();
            let ctx = CtxProgram::V1 { star, plus };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_program(ctx, spans);
            self.stack.push(SynValue::Program(val));
        }

        fn init_decl_i(&mut self) {
            let val = self.listener.init_decl_i();
            self.stack.push(SynValue::DeclI(val));
        }

        fn exit_decl_i(&mut self) {
            let decl = self.stack.pop().unwrap().get_decl();
            let star_acc = self.stack.pop().unwrap().get_decl_i();
            let ctx = CtxDeclI::V1 { star_acc, decl };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_decl_i(ctx, spans);
            self.stack.push(SynValue::DeclI(val));
        }

        fn exitloop_decl_i(&mut self) {
            let SynValue::DeclI(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_decl_i(star_acc);
        }

        fn init_inst_i(&mut self) {
            let val = self.listener.init_inst_i();
            self.stack.push(SynValue::InstI(val));
        }

        fn exit_inst_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 18;
            let inst = self.stack.pop().unwrap().get_inst();
            let plus_acc = self.stack.pop().unwrap().get_inst_i();
            let ctx = CtxInstI::V1 { plus_acc, inst, last_iteration };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_inst_i(ctx, spans);
            self.stack.push(SynValue::InstI(val));
        }

        fn exit_decl(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let star = self.stack.pop().unwrap().get_id_i();
                    let type1 = self.stack_t.pop().unwrap();
                    (3, CtxDecl::V1 { type1, star })
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    let type1 = self.stack_t.pop().unwrap();
                    (4, CtxDecl::V2 { type1, id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_decl")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_decl(ctx, spans);
            self.stack.push(SynValue::Decl(val));
        }

        fn init_id_i(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = InitCtxIdI::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 1 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.init_id_i(ctx, spans);
            self.stack.push(SynValue::IdI(val));
        }

        fn exit_id_i(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let star_acc = self.stack.pop().unwrap().get_id_i();
            let ctx = CtxIdI::V1 { star_acc, id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_id_i(ctx, spans);
            self.stack.push(SynValue::IdI(val));
        }

        fn exitloop_id_i(&mut self) {
            let SynValue::IdI(star_acc) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_id_i(star_acc);
        }

        fn exit_inst(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                8 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    let id = self.stack_t.pop().unwrap();
                    (5, CtxInst::V1 { id, expr })
                }
                9 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    (3, CtxInst::V2 { expr })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_inst")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_inst(ctx, spans);
            self.stack.push(SynValue::Inst(val));
        }

        fn exit_expr1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                11 => {
                    let expr_2 = self.stack.pop().unwrap().get_expr();
                    let expr_1 = self.stack.pop().unwrap().get_expr();
                    (3, CtxExpr::V2 { expr: [expr_1, expr_2] })
                }
                12 => {
                    let expr_2 = self.stack.pop().unwrap().get_expr();
                    let expr_1 = self.stack.pop().unwrap().get_expr();
                    (3, CtxExpr::V3 { expr: [expr_1, expr_2] })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_expr(ctx, spans);
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                14 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    (2, CtxExpr::V1 { expr })
                }
                15 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxExpr::V4 { id })
                }
                16 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxExpr::V5 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            let val = self.listener.exit_expr(ctx, spans);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 902 #1, start program]
    // ------------------------------------------------------------
}

#[allow(unused)]
pub(crate) mod rules_902_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 902 #2, start program]

    use lexigram_lib::{AltId, TokenId, VarId, lexer::PosSpan, log::Logger, parser::{Call, ListenerWrapper, Terminate}};
    use super::super::wrapper_code::code_902_2::*;

    #[derive(Debug)]
    pub enum CtxProgram {
        /// `program -> (<L> decl)* (<L> inst)+`
        V1,
    }
    #[derive(Debug)]
    pub enum CtxDeclI {
        /// `<L> decl` iteration in `program -> ( ►► <L> decl ◄◄ )* (<L> inst)+`
        V1,
    }
    #[derive(Debug)]
    pub enum CtxInstI {
        /// `<L> inst` iteration in `program -> (<L> decl)* ( ►► <L> inst ◄◄ )+`
        V1 { last_iteration: bool },
    }
    #[derive(Debug)]
    pub enum CtxDecl {
        /// `decl -> Type Id (<L> "," Id)* ";"`
        V1 { type1: String, id: String },
        /// `decl -> "typedef" Type Id ";"`
        V2 { type1: String, id: String },
    }
    #[derive(Debug)]
    pub enum CtxIdI {
        /// `<L> "," Id` iteration in `decl -> Type Id ( ►► <L> "," Id ◄◄ )* ";" | "typedef" Type Id ";"`
        V1 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxInst {
        /// `inst -> "let" Id "=" expr ";"`
        V1 { id: String },
        /// `inst -> "print" expr ";"`
        V2,
    }
    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> "-" expr`
        V1,
        /// `expr -> expr "+" expr`
        V2,
        /// `expr -> expr <P> "-" expr`
        V3,
        /// `expr -> Id`
        V4 { id: String },
        /// `expr -> Num`
        V5 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Program (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynProgram();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> Terminate { Terminate::None }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        #[allow(unused_variables)]
        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId { token }
        #[allow(unused_variables)]
        fn exit(&mut self, span: PosSpan) {}
        #[allow(unused_variables)]
        fn abort(&mut self, terminate: Terminate) {}
        fn init_program(&mut self) {}
        #[allow(unused_variables)]
        fn exit_program(&mut self, ctx: CtxProgram, spans: Vec<PosSpan>) {}
        fn init_decl_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_decl_i(&mut self, ctx: CtxDeclI, spans: Vec<PosSpan>) {}
        fn init_inst_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_inst_i(&mut self, ctx: CtxInstI, spans: Vec<PosSpan>) {}
        fn init_decl(&mut self) {}
        #[allow(unused_variables)]
        fn exit_decl(&mut self, ctx: CtxDecl, spans: Vec<PosSpan>) {}
        fn init_id_i(&mut self) {}
        #[allow(unused_variables)]
        fn exit_id_i(&mut self, ctx: CtxIdI, spans: Vec<PosSpan>) {}
        fn init_inst(&mut self) {}
        #[allow(unused_variables)]
        fn exit_inst(&mut self, ctx: CtxInst, spans: Vec<PosSpan>) {}
        fn init_expr(&mut self) {}
        #[allow(unused_variables)]
        fn exit_expr(&mut self, ctx: CtxExpr, spans: Vec<PosSpan>) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
        stack_span: Vec<PosSpan>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    if matches!(nt, 1 | 2 | 4) {
                        self.stack_span.push(PosSpan::empty());
                    }
                    match nt {
                        0 => self.listener.init_program(),          // program
                        1 => self.listener.init_decl_i(),           // decl_i
                        2 => self.listener.init_inst_i(),           // inst_i
                        9 => {}                                     // inst_i_1
                        3 => self.listener.init_decl(),             // decl
                        4 => self.listener.init_id_i(),             // id_i
                        5 => self.listener.init_inst(),             // inst
                        6 => self.listener.init_expr(),             // expr
                        7 | 8 => {}                                 // expr_1, expr_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_program(),                   // program -> decl_i inst_i
                        1 => self.exit_decl_i(),                    // decl_i -> <L> decl decl_i
                        17 |                                        // inst_i_1 -> inst_i
                        18 => self.exit_inst_i(alt_id),             // inst_i_1 -> ε
                        2 => {}                                     // decl_i -> <L> ε (not used)
                     /* 3 */                                        // inst_i -> <L> inst inst_i_1 (never called)
                        4 |                                         // decl -> Type Id id_i ";"
                        5 => self.exit_decl(alt_id),                // decl -> "typedef" Type Id ";"
                        6 => self.exit_id_i(),                      // id_i -> <L> "," Id id_i
                        7 => {}                                     // id_i -> <L> ε (not used)
                        8 |                                         // inst -> "let" Id "=" expr ";"
                        9 => self.exit_inst(alt_id),                // inst -> "print" expr ";"
                        11 |                                        // expr_1 -> "+" expr_2 expr_1
                        12 => self.exit_expr1(alt_id),              // expr_1 -> "-" expr_2 expr_1
                        14 |                                        // expr_2 -> "-" expr_2
                        15 |                                        // expr_2 -> Id
                        16 => self.exit_expr2(alt_id),              // expr_2 -> Num
                        10 => {}                                    // expr -> expr_2 expr_1 (not used)
                        13 => {}                                    // expr_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End(terminate) => {
                    match terminate {
                        Terminate::None => {
                            let span = self.stack_span.pop().unwrap();
                            self.listener.exit(span);
                        }
                        Terminate::Abort | Terminate::Conclude => self.listener.abort(terminate),
                    }
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).collect::<Vec<_>>().join(", "));
            }
        }

        fn check_abort_request(&self) -> Terminate {
            self.listener.check_abort_request()
        }

        fn abort(&mut self) {
            self.stack.clear();
            self.stack_span.clear();
            self.stack_t.clear();
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }

        fn push_span(&mut self, span: PosSpan) {
            self.stack_span.push(span);
        }

        fn is_stack_empty(&self) -> bool {
            self.stack.is_empty()
        }

        fn is_stack_t_empty(&self) -> bool {
            self.stack_t.is_empty()
        }

        fn is_stack_span_empty(&self) -> bool {
            self.stack_span.is_empty()
        }

        fn intercept_token(&mut self, token: TokenId, text: &str, span: &PosSpan) -> TokenId {
            self.listener.intercept_token(token, text, span)
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new(), stack_span: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_program(&mut self) {
            let ctx = CtxProgram::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_program(ctx, spans);
        }

        fn exit_decl_i(&mut self) {
            let ctx = CtxDeclI::V1;
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_decl_i(ctx, spans);
        }

        fn exit_inst_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 18;
            let ctx = CtxInstI::V1 { last_iteration };
            let spans = self.stack_span.drain(self.stack_span.len() - 2 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_inst_i(ctx, spans);
        }

        fn exit_decl(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    let type1 = self.stack_t.pop().unwrap();
                    (4, CtxDecl::V1 { type1, id })
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    let type1 = self.stack_t.pop().unwrap();
                    (4, CtxDecl::V2 { type1, id })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_decl")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_decl(ctx, spans);
        }

        fn exit_id_i(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let ctx = CtxIdI::V1 { id };
            let spans = self.stack_span.drain(self.stack_span.len() - 3 ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_id_i(ctx, spans);
        }

        fn exit_inst(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                8 => {
                    let id = self.stack_t.pop().unwrap();
                    (5, CtxInst::V1 { id })
                }
                9 => {
                    (3, CtxInst::V2)
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_inst")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_inst(ctx, spans);
        }

        fn exit_expr1(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                11 => {
                    (3, CtxExpr::V2)
                }
                12 => {
                    (3, CtxExpr::V3)
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr1")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_expr(ctx, spans);
        }

        fn exit_expr2(&mut self, alt_id: AltId) {
            let (n, ctx) = match alt_id {
                14 => {
                    (2, CtxExpr::V1)
                }
                15 => {
                    let id = self.stack_t.pop().unwrap();
                    (1, CtxExpr::V4 { id })
                }
                16 => {
                    let num = self.stack_t.pop().unwrap();
                    (1, CtxExpr::V5 { num })
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr2")
            };
            let spans = self.stack_span.drain(self.stack_span.len() - n ..).collect::<Vec<_>>();
            self.stack_span.push(spans.iter().fold(PosSpan::empty(), |acc, sp| acc + sp));
            self.listener.exit_expr(ctx, spans);
        }
    }

    // [wrapper source for rule 902 #2, start program]
    // ------------------------------------------------------------
}

