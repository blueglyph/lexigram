// Copyright (c) 2025 Redglyph (@gmail.com). All Rights Reserved.

#![cfg(test)]
//#![allow(non_camel_case_types)]
#![allow(dead_code)]

// The code below is generated by parsergen::tests::wrapper_source::build_items

// ================================================================================

pub(crate) mod rules_13_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 13 #1, start s]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_13_1::*;

    #[derive(Debug)]
    pub enum CtxS {
        /// `s -> Id "=" val`
        S1 { id: String, val: SynVal },
        /// `s -> "exit"`
        S2,
        /// `s -> "return" val`
        S3 { val: SynVal },
    }
    #[derive(Debug)]
    pub enum CtxVal {
        /// `val -> Id`
        Val1 { id: String },
        /// `val -> Num`
        Val2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `s`
    // #[derive(Debug, PartialEq)] pub struct SynS();
    // /// User-defined type for `val`
    // #[derive(Debug, PartialEq)] pub struct SynVal();

    #[derive(Debug)]
    enum SynValue { S(SynS), Val(SynVal) }

    impl SynValue {
        fn get_s(self) -> SynS {
            if let SynValue::S(val) = self { val } else { panic!() }
        }
        fn get_val(self) -> SynVal {
            if let SynValue::Val(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _s: SynS) {}
        fn init_s(&mut self) {}
        fn exit_s(&mut self, _ctx: CtxS) -> SynS;
        fn init_val(&mut self) {}
        fn exit_val(&mut self, _ctx: CtxVal) -> SynVal;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_s(),                // s
                        1 => self.listener.init_val(),              // val
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // s -> Id "=" val
                        1 |                                         // s -> "exit"
                        2 => self.exit_s(alt_id),                   // s -> "return" val
                        3 |                                         // val -> Id
                        4 => self.exit_val(alt_id),                 // val -> Num
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let s = self.stack.pop().unwrap().get_s();
            self.listener.exit(s);
        }

        fn exit_s(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let val = self.stack.pop().unwrap().get_val();
                    let id = self.stack_t.pop().unwrap();
                    CtxS::S1 { id, val }
                }
                1 => {
                    CtxS::S2
                }
                2 => {
                    let val = self.stack.pop().unwrap().get_val();
                    CtxS::S3 { val }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_s")
            };
            let val = self.listener.exit_s(ctx);
            self.stack.push(SynValue::S(val));
        }

        fn exit_val(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxVal::Val1 { id }
                }
                4 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxVal::Val2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_val")
            };
            let val = self.listener.exit_val(ctx);
            self.stack.push(SynValue::Val(val));
        }
    }

    // [wrapper source for rule 13 #1, start s]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_102_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 102 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_102_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B* C`
        A { a: String, star: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B*` array in `a -> A  ►► B* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 => self.exit_a1(),                        // a_1 -> B a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 102 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_108_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 108 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_108_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A "B"* C`
        A { a: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 |                                         // a_1 -> "B" a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 108 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_200_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_200_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        A { a: String, star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        I { star_it: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, b });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }
    }

    // [wrapper source for rule 200 #1, start a]
    // ------------------------------------------------------------

    #[test]
    fn test() {
        println!("compiles");
    }
}

// ================================================================================

pub(crate) mod rules_200_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_200_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        I { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { b });
        }
    }

    // [wrapper source for rule 200 #2, start a]
    // ------------------------------------------------------------
}

pub(crate) mod rules_210_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 210 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_210_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> "B")* C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> "B"` iteration in `a -> A ( ►► <L> "B" ◄◄ )* C`
        I,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> "B" i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            self.listener.exit_i(CtxI::I);
        }
    }

    // [wrapper source for rule 210 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_211_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 211 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_211_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A A (B <L>)* C`
        A1 { a: [String; 2], star: SynI, c: String },
        /// `a -> A C (B <L>)* C`
        A2 { a: String, c: [String; 2], star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
        I { star_it: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // a_1 -> A i C
                        4 => self.exit_a(alt_id),                   // a_1 -> C i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let a_2 = self.stack_t.pop().unwrap();
                    let a_1 = self.stack_t.pop().unwrap();
                    CtxA::A1 { a: [a_1, a_2], star, c }
                }
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2], star }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, b });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }
    }

    // [wrapper source for rule 211 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_103_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 103 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_103_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B+ C`
        A { a: String, plus: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B+` array in `a -> A  ►► B+ ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        2 |                                         // a_2 -> a_1
                        3 => self.exit_a1(),                        // a_2 -> ε
                     /* 1 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }
    }

    // [wrapper source for rule 103 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `a -> <L> B`
        I { plus_it: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();

    #[derive(Debug)]
    enum SynValue { A(SynMyA), I(SynMyI) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynMyI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { plus_it, b, last_iteration });
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `a -> <L> B`
        I { b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();

    #[derive(Debug)]
    enum SynValue { A(SynMyA) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { b, last_iteration });
        }
    }

    // [wrapper source for rule 201 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #3, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `a -> <L> B`
        I { plus_it: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { I(SynMyI) }

    impl SynValue {
        fn get_i(self) -> SynMyI {
            let SynValue::I(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, c });
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { plus_it, b, last_iteration });
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_106_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        A { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b ",")*` array in `a -> (A  ►► (b ",")* ◄◄  ";")* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynB>);
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `A (b ",")* ";"` item in `a -> ( ►► A (b ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub a: String, pub star: SynA1 }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 => self.init_a2(),                        // a_2
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 => self.exit_a1(),                        // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { a, star });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 106 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_106_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        A { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        3 => self.init_a2(),                        // a_2
                        2 => {}                                     // a_1
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 |                                         // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(a);
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 106 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { star_it: SynI, a: String, star: SynJ },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J { star_it: SynJ, b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynJ();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, _ctx: CtxJ) -> SynJ;
        fn exitloop_j(&mut self, _star_it: &mut SynJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => self.exitloop_j(),                     // j -> <L> ε
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, a, star });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let star_it = self.stack.pop().unwrap().get_j();
            let val = self.listener.exit_j(CtxJ::J { star_it, b });
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_it);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 208 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { star_it: SynI, a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, a });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #3, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { a });
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_4 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #4, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { c });
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { a });
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #4, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_206_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 206 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_206_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (<L> B ",")* ";")* C`
        A { star: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
        J { star_it: SynAiter, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynAiter();
    /// Computed `(A (<L> B ",")* ";")*` array in `a ->  ►► (A (<L> B ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `A (<L> B ",")* ";"` item in `a -> ( ►► A (<L> B ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub a: String, pub star: SynAiter }

    #[derive(Debug)]
    enum SynValue { A(SynA), J(SynAiter), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynAiter {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_j(&mut self) -> SynAiter;
        fn exit_j(&mut self, _ctx: CtxJ) -> SynAiter;
        fn exitloop_j(&mut self, _star_it: &mut SynAiter) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_j(),                         // j
                        2 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1 C
                        1 => self.exit_j(),                         // j -> <L> B "," j
                        2 => self.exitloop_j(),                     // j -> <L> ε
                        3 => self.exit_a1(),                        // a_1 -> A j ";" a_1
                        4 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_j();
            let val = self.listener.exit_j(CtxJ::J { star_it, b });
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_it);
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { a, star });
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 206 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_301_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        Expr1 { id: String, expr: SynExpr },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id, expr }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 301 #1, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #2, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_301_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        Expr1 { id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            self.listener.exit_expr(ctx);
        }
    }

    // [wrapper source for rule 301 #2, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_401_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_401_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        Expr1 { expr: SynExpr, id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_expr(),                      // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr1 { expr, id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr2 { expr, num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 401 #1, start expr]
}

// ================================================================================

pub(crate) mod rules_401_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #2, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_401_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        Expr1 { id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            self.listener.exit_expr(ctx);
        }
    }

    // [wrapper source for rule 401 #2, start expr]
}

// ================================================================================

pub(crate) mod rules_862_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 862 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_862_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Num "^" expr`
        Expr1 { expr: SynExpr, num: String },
        /// `expr -> Num`
        Expr2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_expr(),                      // expr
                        1 => {}                                     // expr_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // expr_1 -> "^" expr
                        2 => self.exit_expr(alt_id),                // expr_1 -> ε
                     /* 0 */                                        // expr -> <L> Num expr_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr1 { expr, num }
                }
                2 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr2 { expr, num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 862 #1, start expr]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::BufLog;
        use crate::integration::parser_examples::listener20::build_parser;
        use super::*;

        struct ExprListener {
            log: BufLog,
            result: Option<String>,
        }

        impl ExprListener {
            fn new() -> Self {
                ExprListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for ExprListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, expr: SynExpr) {
                let SynExpr(mut result) = expr;
                while result.len() > 1 {
                    let r = result.pop().unwrap();
                    let l = result.pop().unwrap();
                    result.push(if result.len() > 0 { format!("({l} ^ {r})") } else { format!("{l} ^ {r}") });
                }
                self.result = result.pop();
            }

            fn init_expr(&mut self) -> SynExpr {
                self.result = None;
                SynExpr(vec![])
            }

            fn exit_expr(&mut self, ctx: CtxExpr) -> SynExpr {
                let (mut e, num) = match ctx {
                    // expr -> <L> Num "^" expr
                    CtxExpr::Expr1 { expr: SynExpr(e), num } => (e, num),
                    // expr -> Num
                    CtxExpr::Expr2 { expr: SynExpr(e), num } => (e, num),
                };
                e.push(num);
                SynExpr(e)
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // expr -> <L=expr> Num "^" expr | Num
                ("1", Some("1")),
                ("1 ^ 2", Some("1 ^ 2")),
                ("1 ^ 2 ^ 3", Some("1 ^ (2 ^ 3)")),
                ("1 ^ 2 ^ 3 ^ 4", Some("1 ^ (2 ^ (3 ^ 4))")),
                ("", None),
                ("^ 1", None),
                ("1 ^", None),
                ("1 ^ ^", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let num_id = 0;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            println!("symbols = {symbols:?}");
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            (num_id, w.to_string(), 1, i)
                        } else {
                            panic!("'{w}' input not recognized")
                        }
                    }
                });
                let listener = ExprListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let result = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        wrapper.listener.result.take()
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        None
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.to_string();
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let expected_result = expected_result.map(|s| s.to_string());
                assert_eq!(result, expected_result, "test failed for input: {input}");
            }
        }
    }
}

// ================================================================================

pub(crate) mod rules_502_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_502_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        E1 { f: SynF },
        /// `e -> e "." Id`
        E2 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E2 { e, id });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_e(e);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_502_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #2, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_502_2::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        E1 { f: SynF },
        /// `e -> e "." Id`
        E2 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();
    /// Top non-terminal E (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynE();

    #[derive(Debug)]
    enum SynValue { F(SynF) }

    impl SynValue {
        fn get_f(self) -> SynF {
            let SynValue::F(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => {}                                     // e_1 -> ε (not used)
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            self.listener.exit_e(CtxE::E1 { f });
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            self.listener.exit_e(CtxE::E2 { id });
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #2, start e]
    // ------------------------------------------------------------
}

// ================================================================================

// Test 28: rules PRS(33) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(33), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(33) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// `A -> b c`
        A2 { b: String, c: String },
        /// `A -> b d`
        A3 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 | 2 => {}                                 // A_1, A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // A_2 -> c A_1
                        4 => self.inter_a(alt_id),               // A_2 -> d A_1
                        1 => self.exit_a1(),                        // A_1 -> a A_1
                        2 => self.exitloop_a1(),                    // A_1 -> ε
                     /* 0 */                                        // A -> b A_2 (never called)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A2 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, d }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self) {
            let a1 = self.stack_t.pop().unwrap();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A1 { a, a1 });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule PRS(33) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 29: rules PRS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0, t 1],               //  2: A_1 -> b A_1 | ●A_1 ◄2 b! | A b
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![t 1, t 2],                //  4: A_2 -> c A_1 | ►A_1 ◄4 c! | b c
                5 => symbols![t 1, t 3],                //  5: A_2 -> d A_1 | ►A_1 ◄5 d! | b d
            ], Default, btreemap![0 => vec![4, 5]]),
*/
pub(crate) mod rules_prs_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(38) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// `A -> A b`
        A2 { a: SynA, b: String },
        /// `A -> b c`
        A3 { b: String, c: String },
        /// `A -> b d`
        A4 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 | 2 => {}                                 // A_1, A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        4 |                                         // A_2 -> c A_1
                        5 => self.inter_a(alt_id),               // A_2 -> d A_1
                        1 |                                         // A_1 -> a A_1
                        2 => self.exit_a1(alt_id),               // A_1 -> b A_1
                        3 => self.exitloop_a1(),                    // A_1 -> ε
                     /* 0 */                                        // A -> b A_2 (never called)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A4 { b, d }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, b }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule PRS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 30: rules PRS(39) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (PRS(39), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![],                        //  1: A_1 -> a A_3 | ►A_3 a!    |
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
                5 => symbols![nt 0, t 0, t 1],          //  5: A_3 -> b A_1 | ●A_1 ◄5 b! | A a b
                6 => symbols![nt 0, t 0, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A a c
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_39_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(39) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_39_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> b c`
        A1 { b: String, c: String },
        /// `A -> b d`
        A2 { b: String, d: String },
        /// `A -> A a b`
        A3 { a: SynA, a1: String, b: String },
        /// `A -> A a c`
        A4 { a: SynA, a1: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 ..= 3 => {}                               // A_1, A_2, A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // A_2 -> c A_1
                        4 => self.inter_a(alt_id),               // A_2 -> d A_1
                        5 |                                         // A_3 -> b A_1
                        6 => self.exit_a1(alt_id),               // A_3 -> c A_1
                        2 => self.exitloop_a1(),                    // A_1 -> ε
                     /* 0 */                                        // A -> b A_2 (never called)
                     /* 1 */                                        // A_1 -> a A_3 (never called)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A1 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A2 { b, d }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                5 => {
                    let b = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a, a1, b }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, a1, c }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule PRS(39) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 31: rules PRS(32) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec | parent_left_fact (36)
            //  - E_2: child_left_fact (64)
            // parents:
            //  - E_1 -> E
            //  - E_2 -> E_1
            (PRS(32), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F  | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!      | id
                2 => symbols![],                        //  2: E_1 -> . id E_2 | ►E_2 id! .  |
                3 => symbols![nt 0],                    //  3: E_1 -> ε        | ◄3          | E
                4 => symbols![nt 0, t 1],               //  4: E_2 -> ( ) E_1  | ●E_1 ◄4 ) ( | E id
                5 => symbols![nt 0, t 1],               //  5: E_2 -> E_1      | ●E_1 ◄5     | E id
            ], Default, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_32_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(32) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_32_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> E . id ( )`
        E2 { e: SynE, id: String },
        /// `E -> E . id`
        E3 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `F`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 | 3 => {}                                 // E_1, E_2
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // E -> F E_1
                        4 |                                         // E_2 -> ( ) E_1
                        5 => self.exit_e1(alt_id),               // E_2 -> E_1
                        3 => self.exitloop_e1(),                    // E_1 -> ε
                     /* 2 */                                        // E_1 -> . id E_2 (never called)
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, id }
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_e(e);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(32) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 32: rules RTS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a!    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b!    |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0, t 0, t 2],          //  4: A_2 -> c A_1 | ●A_1 ◄4 c! | A a c
                5 => symbols![nt 0, t 0],               //  5: A_2 -> A_1   | ●A_1 ◄5    | A a
                6 => symbols![nt 0, t 1, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A b c
                7 => symbols![nt 0, t 1],               //  7: A_3 -> A_1   | ●A_1 ◄7    | A b
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// `A -> A a c`
        A2 { a: SynA, a1: String, c: String },
        /// `A -> A a`
        A3 { a: SynA, a1: String },
        /// `A -> A b c`
        A4 { a: SynA, b: String, c: String },
        /// `A -> A b`
        A5 { a: SynA, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 ..= 3 => {}                               // A_1, A_2, A_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // A -> d A_1
                        4 |                                         // A_2 -> c A_1
                        5 |                                         // A_2 -> A_1
                        6 |                                         // A_3 -> c A_1
                        7 => self.exit_a1(alt_id),                  // A_3 -> A_1
                        3 => self.exitloop_a1(),                    // A_1 -> ε
                     /* 1 */                                        // A_1 -> a A_2 (never called)
                     /* 2 */                                        // A_1 -> b A_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, a1, c }
                }
                5 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a, a1 }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, b, c }
                }
                7 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a, b }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule RTS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 33: rules RTS(38) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a     |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b     |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0],                    //  4: A_2 -> c A_1 | ●A_1 ◄4 c  | A
                5 => symbols![nt 0],                    //  5: A_2 -> A_1   | ●A_1 ◄5    | A
                6 => symbols![nt 0],                    //  6: A_3 -> c A_1 | ●A_1 ◄6 c  | A
                7 => symbols![nt 0],                    //  7: A_3 -> A_1   | ●A_1 ◄7    | A
            ], Set(symbols![nt 0, t 3]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #2, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_38_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// `A -> A "a" "c"`
        A2 { a: SynA },
        /// `A -> A "a"`
        A3 { a: SynA },
        /// `A -> A "b" "c"`
        A4 { a: SynA },
        /// `A -> A "b"`
        A5 { a: SynA },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 ..= 3 => {}                               // A_1, A_2, A_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // A -> d A_1
                        4 |                                         // A_2 -> "c" A_1
                        5 |                                         // A_2 -> A_1
                        6 |                                         // A_3 -> "c" A_1
                        7 => self.exit_a1(alt_id),                  // A_3 -> A_1
                        3 => self.exitloop_a1(),                    // A_1 -> ε
                     /* 1 */                                        // A_1 -> "a" A_2 (never called)
                     /* 2 */                                        // A_1 -> "b" A_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                6 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a }
                }
                7 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule RTS(38) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 34: rules RTS(38) #3, start 0:
/*
before, NT with value:
after,  NT with value:
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
            ], btreemap![
                0 => symbols![],                        //  0: A -> d A_1   | ►A_1 ◄0 d |
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b    |
                3 => symbols![],                        //  3: A_1 -> ε     | ◄3        |
                4 => symbols![],                        //  4: A_2 -> c A_1 | ●A_1 ◄4 c |
                5 => symbols![],                        //  5: A_2 -> A_1   | ●A_1 ◄5   |
                6 => symbols![],                        //  6: A_3 -> c A_1 | ●A_1 ◄6 c |
                7 => symbols![],                        //  7: A_3 -> A_1   | ●A_1 ◄7   |
            ], Set(symbols![]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #3, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> "d"`
        A1,
        /// `A -> A "a" "c"`
        A2,
        /// `A -> A "a"`
        A3,
        /// `A -> A "b" "c"`
        A4,
        /// `A -> A "b"`
        A5,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 ..= 3 => {}                               // A_1, A_2, A_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // A -> "d" A_1
                        4 |                                         // A_2 -> "c" A_1
                        5 |                                         // A_2 -> A_1
                        6 |                                         // A_3 -> "c" A_1
                        7 => self.exit_a1(alt_id),                  // A_3 -> A_1
                     /* 1 */                                        // A_1 -> "a" A_2 (never called)
                     /* 2 */                                        // A_1 -> "b" A_3 (never called)
                        3 => {}                                     // A_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self) {
            self.listener.exit_a(CtxA::A1);
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    CtxA::A2
                }
                5 => {
                    CtxA::A3
                }
                6 => {
                    CtxA::A4
                }
                7 => {
                    CtxA::A5
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            self.listener.exit_a(ctx);
        }
    }

    // [wrapper source for rule RTS(38) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 40: rules RTS(26) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* (2560)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_left_rec (4)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (RTS(26), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![nt 1, t 2],               //  1: A_1 -> c A_1     | ●A_1 ◄1 c!      | A_1 c
                2 => symbols![],                        //  2: A_1 -> ε         | ◄2              |
                3 => symbols![nt 0, nt 1, t 1],         //  3: A_2 -> A_1 b A_2 | ●A_2 ◄3 b! ►A_1 | A A_1 b
                4 => symbols![nt 0],                    //  4: A_2 -> ε         | ◄4              | A
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_26_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(26) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_26_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A c* b`
        A2 { a: SynA, star: SynA1, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `c*` array in `A -> A  ►► c* ◄◄  b | a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // A -> a A_2
                        1 => self.exit_a1(),                        // A_1 -> c A_1
                        2 => {}                                     // A_1 -> ε
                        3 => self.exit_a2(),                        // A_2 -> A_1 b A_2
                        4 => self.exitloop_a2(),                    // A_2 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(c);
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A2 { a, star, b });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule RTS(26) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 41: rules RTS(16) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* | plus (6656)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_rec (4)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (RTS(16), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![],                        //  1: A_1 -> c A_3     | ►A_3 c!         |
                2 => symbols![nt 0, nt 1, t 1],         //  2: A_2 -> A_1 b A_2 | ●A_2 ◄2 b! ►A_1 | A A_1 b
                3 => symbols![nt 0],                    //  3: A_2 -> ε         | ◄3              | A
                4 => symbols![nt 1, t 2],               //  4: A_3 -> A_1       | ●A_1 ◄4         | A_1 c
                5 => symbols![nt 1, t 2],               //  5: A_3 -> ε         | ◄5              | A_1 c
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_16_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(16) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_16_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A c+ b`
        A2 { a: SynA, plus: SynA1, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `c+` array in `A -> A  ►► c+ ◄◄  b | a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 | 3 => {}                                 // A_2, A_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // A -> a A_2
                        4 |                                         // A_3 -> A_1
                        5 => self.exit_a1(),                        // A_3 -> ε
                        2 => self.exit_a2(),                        // A_2 -> A_1 b A_2
                        3 => self.exitloop_a2(),                    // A_2 -> ε
                     /* 1 */                                        // A_1 -> c A_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(c);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A2 { a, plus, b });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule RTS(16) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_705_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 705 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_705_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> E`
        A1 { e: String },
        /// `a -> A`
        A2 { a: String },
        /// `a -> A B C`
        A3 { a: String, b: String, c: String },
        /// `a -> A B D`
        A4 { a: String, b: String, d: String },
        /// `a -> A B`
        A5 { a: String, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // a -> E
                        3 |                                         // a_1 -> ε
                        4 |                                         // a_2 -> C
                        5 |                                         // a_2 -> D
                        6 => self.exit_a(alt_id),                   // a_2 -> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                     /* 2 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    CtxA::A1 { e }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a, b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A4 { a, b, d }
                }
                6 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A5 { a, b }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 705 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

// Test 42: rules PRS(35) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact (32)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            (PRS(35), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1 | ►A_1 a!  |
                1 => symbols![t 0, t 1, t 1],           //  1: A_1 -> b b | ◄1 b! b! | a b b
                2 => symbols![t 0, t 2, t 2],           //  2: A_1 -> c c | ◄2 c! c! | a c c
                3 => symbols![t 0],                     //  3: A_1 -> ε   | ◄3       | a
            ], Default, btreemap![0 => vec![1, 2, 3]]),
*/
pub(crate) mod rules_prs_35_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(35) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_35_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a b b`
        A1 { a: String, b: [String; 2] },
        /// `A -> a c c`
        A2 { a: String, c: [String; 2] },
        /// `A -> a`
        A3 { a: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // A_1 -> b b
                        2 |                                         // A_1 -> c c
                        3 => self.exit_a(alt_id),                // A_1 -> ε
                     /* 0 */                                        // A -> a A_1 (never called)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let b_2 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A1 { a, b: [b_1, b_2] }
                }
                2 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2] }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(35) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 43: rules RTS(33) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(33), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, t 1],               //  0: A -> A_1 b     | ◄0 b! ►A_1    | A_1 b
                1 => symbols![t 0],                     //  1: A -> a         | ◄1 a!         | a
                2 => symbols![t 1],                     //  2: B -> b         | ◄2 b!         | b
                3 => symbols![nt 2, nt 1, t 2],         //  3: A_1 -> B c A_1 | ●A_1 ◄3 c! ►B | A_1 B c
                4 => symbols![],                        //  4: A_1 -> ε       | ◄4            |
            ], All, btreemap![0 => vec![0, 1], 1 => vec![2]]),
*/
pub(crate) mod rules_rts_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(33) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> (B c)* b`
        A1 { star: SynA1, b: String },
        /// `A -> a`
        A2 { a: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(B c)*` array in `A ->  ►► (B c)* ◄◄  b | a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B c` item in `A -> ( ►► B c ◄◄ )* b | a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: SynB, pub c: String }

    #[derive(Debug)]
    enum SynValue { A(SynMyA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // A -> A_1 b
                        1 => self.exit_a(alt_id),                   // A -> a
                        3 => self.exit_a1(),                        // A_1 -> B c A_1
                        4 => {}                                     // A_1 -> ε
                        2 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    CtxA::A1 { star, b }
                }
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { b, c });
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(33) #1, start A]
    // ------------------------------------------------------------
}

pub(crate) mod level_string {
    use std::cmp::max;

    #[derive(Debug, PartialEq)]
    pub struct LevelString(pub u32, pub String);

    impl LevelString {
        pub fn get_string(self) -> String {
            self.1
        }
    }

    pub fn par(ls: LevelString) -> String {
        if ls.0 > 0 {
            format!("({})", ls.1)
        } else {
            ls.1
        }
    }

    pub fn ls_prefix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{op} {}", par(ls)))
    }

    pub fn ls_suffix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{} {op}", par(ls)))
    }

    pub fn ls_binary_op(op: &str, lsleft: LevelString, lsright: LevelString) -> LevelString {
        LevelString(max(lsleft.0, lsright.0) + 1, format!("{} {op} {}", par(lsleft), par(lsright)))
    }


}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_58_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule PRS(58) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_58_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> - E`
        E1 { e: SynE },
        /// `E -> 0`
        E2,
        /// `E -> E +`
        E3 { e: SynE },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 => {}                                     // E_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // E -> - E
                        1 => self.inter_e(alt_id),               // E -> 0 E_1
                        2 => self.exit_e1(),                        // E_1 -> + E_1
                        3 => self.exitloop_e1(),                    // E_1 -> ε
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                1 => {
                    CtxE::E2
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E3 { e });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap();
            self.listener.exitloop_e(e);
        }
    }

    // [wrapper source for rule PRS(58) #1, start E]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener16::build_parser;
        use crate::out::wrapper_source::level_string::{ls_prefix_op, ls_suffix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // E -> - E
                    CtxE::E1 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    // E -> 0
                    CtxE::E2 => LevelString(0, "0".to_string()),
                    // E -> E +
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("+", ls),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> E + | - E | 0
                ("- - 0 + +", Some("- (- ((0 +) +))")),
                ("0 +", Some("0 +")),
                ("- 0", Some("- 0")),
                ("0", Some("0")),
                ("- +", None),
                ("-", None),
                ("+", None),
                ("", None),
                ("- 0 0 +", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_60_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(60) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_60_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> - E <L>`
        E1 { e: SynE },
        /// `E -> 0 <L>`
        E2 { e: SynE },
        /// `E -> E +`
        E3 { e: SynE },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) -> SynE;
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_e(),                         // E
                        1 => {}                                     // E_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // E -> <L> - E
                        1 => self.inter_e(alt_id),               // E -> <L> 0 E_1
                        2 => self.exit_e1(),                        // E_1 -> + E_1
                        3 => self.exitloop_e1(),                    // E_1 -> ε
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn init_e(&mut self) {
            let val = self.listener.init_e();
            self.stack.push(SynValue::E(val));
        }

        fn inter_e(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                1 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E3 { e });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap();
            self.listener.exitloop_e(e);
        }
    }

    // [wrapper source for rule PRS(60) #1, start E]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener16::build_parser;
        use crate::out::wrapper_source::level_string::{ls_prefix_op, ls_suffix_op, LevelString};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) -> SynE {
                self.result = None;
                SynE(LevelString(0, "".to_string()))
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // E -> - E <L>
                    CtxE::E1 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    // E -> 0
                    CtxE::E2 { e: SynE(ls) } => LevelString(0, "0".to_string()),
                    // E -> E +
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("+", ls),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> E + | - E | 0
                ("- - 0 + +", Some("- (- ((0 +) +))")),
                ("0 +", Some("0 +")),
                ("- 0", Some("- 0")),
                ("0", Some("0")),
                ("- +", None),
                ("-", None),
                ("+", None),
                ("", None),
                ("- 0 0 +", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_55_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(55) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_55_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E * E`
        E1 { e: [SynE; 2] },
        /// `E -> E --`
        E2 { e: SynE },
        /// `E -> E + E`
        E3 { e: [SynE; 2] },
        /// `E -> ! E`
        E4 { e: SynE },
        /// `E -> ID`
        E5 { id: String },
        /// `E -> NUM`
        E6 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 4 => {}                               // E_1, E_2, E_3, E_4
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // E_1 -> * E_4 E_1
                        2 |                                         // E_1 -> -- E_1
                        3 => self.exit_e1(alt_id),               // E_1 -> + E_2 E_1
                        6 => self.exit_e1(1),                       // E_3 -> * E_4 E_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // E_3 -> -- E_3 (duplicate of 2)
                        9 |                                         // E_4 -> ! E_2
                        10 |                                        // E_4 -> ID
                        11 => self.exit_e4(alt_id),              // E_4 -> NUM
                        0 => {}                                     // E -> E_4 E_1 (not used)
                        4 => {}                                     // E_1 -> ε (not used)
                        5 => {}                                     // E_2 -> E_4 E_3 (not used)
                        8 => {}                                     // E_3 -> ε (not used)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                9 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e }
                }
                10 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E5 { id }
                }
                11 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E6 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule PRS(55) #1, start E]
    // ------------------------------------------------------------
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_66_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(66) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_66_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E --`
        E1 { e: SynE },
        /// `E -> ! E`
        E2 { e: SynE },
        /// `E -> ID`
        E3 { id: String },
        /// `E -> E . * E`
        E4 { e: [SynE; 2] },
        /// `E -> E . + E`
        E5 { e: [SynE; 2] },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 5 => {}                               // E_1, E_2, E_3, E_4, E_5
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        10 |                                        // E_5 -> * E_4 E_1
                        1 |                                         // E_1 -> -- E_1
                        11 => self.exit_e1(alt_id),              // E_5 -> + E_2 E_1
                        5 => self.exit_e1(10),                      // E_3 -> . * E_4 E_3 (duplicate of 10)
                        6 => self.exit_e1(1),                       // E_3 -> -- E_3 (duplicate of 1)
                        8 |                                         // E_4 -> ! E
                        9 => self.exit_e4(alt_id),               // E_4 -> ID
                        0 => {}                                     // E -> E_4 E_1 (not used)
                     /* 2 */                                        // E_1 -> . E_5 (never called)
                        3 => {}                                     // E_1 -> ε (not used)
                        4 => {}                                     // E_2 -> E_4 E_3 (not used)
                        7 => {}                                     // E_3 -> ε (not used)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                1 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                11 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                8 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                9 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E3 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule PRS(66) #1, start E]
    // ------------------------------------------------------------
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_rts_41_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(41) #1, start A]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_41_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A "x" A`
        A1 { a: [SynA; 2] },
        /// `A -> A "*" "[" NUM+ "]"`
        A2 { a: SynA, plus: SynA1 },
        /// `A -> "-" A`
        A3 { a: SynA },
        /// `A -> ID`
        A4 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `NUM+` array in `A -> A "x" A | A "*" "["  ►► NUM+ ◄◄  "]" | "-" A | ID`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 ..= 4 => {}                               // A_2, A_3, A_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        7 |                                         // A_4 -> A_1
                        8 => self.exit_a1(),                        // A_4 -> ε
                        2 |                                         // A_2 -> "x" A_3 A_2
                        3 => self.exit_a2(alt_id),                  // A_2 -> "*" "[" A_1 "]" A_2
                        5 |                                         // A_3 -> "-" A
                        6 => self.exit_a3(alt_id),                  // A_3 -> ID
                        0 => {}                                     // A -> A_3 A_2 (not used)
                     /* 1 */                                        // A_1 -> NUM A_4 (never called)
                        4 => {}                                     // A_2 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(num);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                2 => {
                    let a_2 = self.stack.pop().unwrap().get_a();
                    let a_1 = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a: [a_1, a_2] }
                }
                3 => {
                    let plus = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, plus }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a3(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                6 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxA::A4 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a3")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(41) #1, start A]
    // ------------------------------------------------------------
}

#[cfg(test)]
// #[allow(unused)]
pub(crate) mod rules_rts_42_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule RTS(42) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_42_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E "*" E`
        E1 { e: [SynE; 2] },
        /// `E -> E "/" <P> E`
        E2 { e: [SynE; 2] },
        /// `E -> E "+" E`
        E3 { e: [SynE; 2] },
        /// `E -> E "-" <P> E`
        E4 { e: [SynE; 2] },
        /// `E -> "-" E`
        E5 { e: SynE },
        /// `E -> ID`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 4 => {}                               // E_1, E_2, E_3, E_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // E_1 -> "*" E_4 E_1
                        2 |                                         // E_1 -> "/" E_4 E_1
                        3 |                                         // E_1 -> "+" E_2 E_1
                        4 => self.exit_e1(alt_id),                  // E_1 -> "-" E_2 E_1
                        7 => self.exit_e1(1),                       // E_3 -> "*" E_4 E_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // E_3 -> "/" E_4 E_3 (duplicate of 2)
                        10 |                                        // E_4 -> "-" E_4
                        11 => self.exit_e4(alt_id),                 // E_4 -> ID
                        0 => {}                                     // E -> E_4 E_1 (not used)
                        5 => {}                                     // E_1 -> ε (not used)
                        6 => {}                                     // E_2 -> E_4 E_3 (not used)
                        9 => {}                                     // E_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule RTS(42) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener17::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | E * E | <P> E / E | E + E | <P> E - E | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("((a * b) * c) * d")),
                ("a / b / c / d", Some("((a / b) / c) / d")),
                ("a + b + c + d", Some("((a + b) + c) + d")),
                ("a - b - c - d", Some("((a - b) - c) - d")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("(a + b) - c")),
                ("a - b + c", Some("(a - b) + c")),
                ("a * b / c", Some("(a * b) / c")),
                ("a / b * c", Some("(a / b) * c")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
pub(crate) mod rules_rts_43_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule RTS(43) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_43_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> <R> E "*" E`
        E1 { e: [SynE; 2] },
        /// `E -> <R> E "/" <P> E`
        E2 { e: [SynE; 2] },
        /// `E -> <R> E "+" E`
        E3 { e: [SynE; 2] },
        /// `E -> <R> E "-" <P> E`
        E4 { e: [SynE; 2] },
        /// `E -> "-" E`
        E5 { e: SynE },
        /// `E -> ID`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 4 => {}                               // E_1, E_2, E_3, E_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // E_1 -> <R> "*" E_2 E_1
                        2 |                                         // E_1 -> <R> "/" E_2 E_1
                        3 |                                         // E_1 -> <R> "+" E E_1
                        4 => self.exit_e1(alt_id),                  // E_1 -> <R> "-" E E_1
                        7 => self.exit_e1(1),                       // E_3 -> <R> "*" E_2 E_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // E_3 -> <R> "/" E_2 E_3 (duplicate of 2)
                        10 |                                        // E_4 -> "-" E_4
                        11 => self.exit_e4(alt_id),                 // E_4 -> ID
                        0 => {}                                     // E -> E_4 E_1 (not used)
                        5 => {}                                     // E_1 -> ε (not used)
                        6 => {}                                     // E_2 -> E_4 E_3 (not used)
                        9 => {}                                     // E_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule RTS(43) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener18::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | <R> E * E | <R> E / E <P> | <R> E + E | <R> E - E <P> | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("a * (b * (c * d))")),
                ("a / b / c / d", Some("a / (b / (c / d))")),
                ("a + b + c + d", Some("a + (b + (c + d))")),
                ("a - b - c - d", Some("a - (b - (c - d))")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("a + (b - c)")),
                ("a - b + c", Some("a - (b + c)")),
                ("a * b / c", Some("a * (b / c)")),
                ("a / b * c", Some("a / (b * c)")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("a + ((- b) + c)")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
pub(crate) mod rules_rts_44_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule RTS(44) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_44_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> <R> E "*" E`
        E1 { e: [SynE; 2] },
        /// `E -> <R> E "/" <P> E`
        E2 { e: [SynE; 2] },
        /// `E -> E "+" E`
        E3 { e: [SynE; 2] },
        /// `E -> E "-" <P> E`
        E4 { e: [SynE; 2] },
        /// `E -> "-" E`
        E5 { e: SynE },
        /// `E -> ID`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 4 => {}                               // E_1, E_2, E_3, E_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // E_1 -> <R> "*" E_2 E_1
                        2 |                                         // E_1 -> <R> "/" E_2 E_1
                        3 |                                         // E_1 -> "+" E_2 E_1
                        4 => self.exit_e1(alt_id),                  // E_1 -> "-" E_2 E_1
                        7 => self.exit_e1(1),                       // E_3 -> <R> "*" E_2 E_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // E_3 -> <R> "/" E_2 E_3 (duplicate of 2)
                        10 |                                        // E_4 -> "-" E_4
                        11 => self.exit_e4(alt_id),                 // E_4 -> ID
                        0 => {}                                     // E -> E_4 E_1 (not used)
                        5 => {}                                     // E_1 -> ε (not used)
                        6 => {}                                     // E_2 -> E_4 E_3 (not used)
                        9 => {}                                     // E_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule RTS(44) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener19::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | <R> E * E | <R> E / E <P> | E + E | E - E <P> | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("a * (b * (c * d))")),
                ("a / b / c / d", Some("a / (b / (c / d))")),
                ("a + b + c + d", Some("((a + b) + c) + d")),
                ("a - b - c - d", Some("((a - b) - c) - d")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("(a + b) - c")),
                ("a - b + c", Some("(a - b) + c")),
                ("a * b / c", Some("a * (b / c)")),
                ("a / b * c", Some("a / (b * c)")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_63_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule PRS(63) #1, start E]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_63_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E ^ E <R>`
        E1 { e: [SynE; 2] },
        /// `E -> E * E`
        E2 { e: [SynE; 2] },
        /// `E -> E + E`
        E3 { e: [SynE; 2] },
        /// `E -> - E`
        E4 { e: SynE },
        /// `E -> ID`
        E5 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 ..= 6 => {}                               // E_1, E_2, E_3, E_4, E_5, E_6
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // E_1 -> <R> ^ E_4 E_1
                        2 |                                         // E_1 -> * E_4 E_1
                        3 => self.exit_e1(alt_id),               // E_1 -> + E_2 E_1
                        6 |                                         // E_3 -> <R> ^ E_4 E_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // E_5 -> <R> ^ E_4 E_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // E_3 -> * E_4 E_3 (duplicate of 2)
                        12 |                                        // E_6 -> - E_2
                        13 => self.exit_e6(alt_id),              // E_6 -> ID
                        0 => {}                                     // E -> E_6 E_1 (not used)
                        4 => {}                                     // E_1 -> ε (not used)
                        5 => {}                                     // E_2 -> E_6 E_3 (not used)
                        8 => {}                                     // E_3 -> ε (not used)
                        9 => {}                                     // E_4 -> E_6 E_5 (not used)
                        11 => {}                                    // E_5 -> ε (not used)
                        _ => panic!("unexpected exit alt id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                12 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e }
                }
                13 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E5 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e6")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule PRS(63) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)] pub struct SynE(LevelString);
    /// User-defined type for `E3`
    #[derive(Debug, PartialEq)] pub struct SynE3(LevelString);
    /// User-defined type for `E5`
    #[derive(Debug, PartialEq)] pub struct SynE5(LevelString);
    /// User-defined type for `E6`
    #[derive(Debug, PartialEq)] pub struct SynE6(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener14::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("^", lsleft, lsright),
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    CtxE::E4 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    CtxE::E5 { id } => LevelString(0, id)
                })
            }

        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> <R> E ^ E | E * E | - E | E + E | ID;
                ("a + b + c + d + e", Some("(((a + b) + c) + d) + e")),
                ("a * b", Some("a * b")),
                ("a + b", Some("a + b")),
                ("- a", Some("- a")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a * b * c", Some("(a * b) * c")),
                ("- a * b", Some("- (a * b)")),
                ("a * - b * c", Some("a * (- (b * c))")),   // ! because here p(-) < p(*)
                ("- a + b", Some("(- a) + b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a ^ b", Some("a ^ b")),
                ("a ^ b ^ c ^ d", Some("a ^ (b ^ (c ^ d))")),
                ("a ^ b ^ - c", Some("a ^ (b ^ (- c))")),
                ("a ^ - b ^ c", Some("a ^ (- (b ^ c))")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

// ================================================================================
// Test 44: rules RTS(100) #1, start 0:

pub(crate) mod rules_rts_100_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(100) #1, start file]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_100_1::*;

    #[derive(Debug)]
    pub enum CtxFile {
        /// `file -> header file_item*`
        File1 { header: SynHeader, star: SynFile1 },
        /// `file -> file_item*`
        File2 { star: SynFile1 },
    }
    #[derive(Debug)]
    pub enum CtxFileItem {
        /// `file_item -> option`
        FileItem1 { option: SynOption },
        /// `file_item -> declaration`
        FileItem2 { declaration: SynDeclaration },
        /// `file_item -> rule`
        FileItem3 { rule: SynRule },
    }
    #[derive(Debug)]
    pub enum CtxHeader {
        /// `header -> "lexicon" Id ";"`
        Header { id: String },
    }
    #[derive(Debug)]
    pub enum CtxDeclaration {
        /// `declaration -> "mode" Id ";"`
        Declaration { id: String },
    }
    #[derive(Debug)]
    pub enum CtxOption {
        /// `option -> "channels" "{" Id ("," Id)* "}"`
        Option { id: String, star: SynOption1 },
    }
    #[derive(Debug)]
    pub enum CtxRule {
        /// `rule -> "fragment" Id ":" match ";"`
        Rule1 { id: String, match1: SynMatch },
        /// `rule -> Id ":" match "->" actions ";"`
        Rule2 { id: String, match1: SynMatch, actions: SynActions },
        /// `rule -> Id ":" match ";"`
        Rule3 { id: String, match1: SynMatch },
    }
    #[derive(Debug)]
    pub enum CtxActions {
        /// `actions -> action ("," action)*`
        Actions { action: SynAction, star: SynActions1 },
    }
    #[derive(Debug)]
    pub enum CtxAction {
        /// `action -> "mode" "(" Id ")"`
        Action1 { id: String },
        /// `action -> "push" "(" Id ")"`
        Action2 { id: String },
        /// `action -> "pop"`
        Action3,
        /// `action -> "skip"`
        Action4,
        /// `action -> "more"`
        Action5,
        /// `action -> "type" "(" Id ")"`
        Action6 { id: String },
        /// `action -> "channel" "(" Id ")"`
        Action7 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxMatch {
        /// `match -> alt_items`
        Match { alt_items: SynAltItems },
    }
    #[derive(Debug)]
    pub enum CtxAltItems {
        /// `alt_items -> alt_item ("|" alt_item)*`
        AltItems { alt_item: SynAltItem, star: SynAltItems1 },
    }
    #[derive(Debug)]
    pub enum CtxAltItem {
        /// `alt_item -> repeat_item+`
        AltItem { plus: SynAltItem1 },
    }
    #[derive(Debug)]
    pub enum CtxRepeatItem {
        /// `repeat_item -> item "?"`
        RepeatItem1 { item: SynItem },
        /// `repeat_item -> item`
        RepeatItem2 { item: SynItem },
        /// `repeat_item -> item "+" "?"`
        RepeatItem3 { item: SynItem },
        /// `repeat_item -> item "+"`
        RepeatItem4 { item: SynItem },
        /// `repeat_item -> item "*" "?"`
        RepeatItem5 { item: SynItem },
        /// `repeat_item -> item "*"`
        RepeatItem6 { item: SynItem },
    }
    #[derive(Debug)]
    pub enum CtxItem {
        /// `item -> "(" alt_items ")"`
        Item1 { alt_items: SynAltItems },
        /// `item -> "~" item`
        Item2 { item: SynItem },
        /// `item -> Id`
        Item3 { id: String },
        /// `item -> StrLit`
        Item4 { strlit: String },
        /// `item -> char_set`
        Item5 { char_set: SynCharSet },
        /// `item -> CharLit ".." CharLit`
        Item6 { charlit: [String; 2] },
        /// `item -> CharLit`
        Item7 { charlit: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSet {
        /// `char_set -> "[" char_set_one+ "]"`
        CharSet1 { plus: SynCharSet1 },
        /// `char_set -> "."`
        CharSet2,
        /// `char_set -> FixedSet`
        CharSet3 { fixedset: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSetOne {
        /// `char_set_one -> FixedSet`
        CharSetOne1 { fixedset: String },
        /// `char_set_one -> SetChar "-" SetChar`
        CharSetOne2 { setchar: [String; 2] },
        /// `char_set_one -> SetChar`
        CharSetOne3 { setchar: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `file`
    // #[derive(Debug, PartialEq)] pub struct SynFile();
    // /// User-defined type for `file_item`
    // #[derive(Debug, PartialEq)] pub struct SynFileItem();
    // /// User-defined type for `header`
    // #[derive(Debug, PartialEq)] pub struct SynHeader();
    // /// User-defined type for `declaration`
    // #[derive(Debug, PartialEq)] pub struct SynDeclaration();
    // /// User-defined type for `option`
    // #[derive(Debug, PartialEq)] pub struct SynOption();
    // /// User-defined type for `rule`
    // #[derive(Debug, PartialEq)] pub struct SynRule();
    // /// User-defined type for `actions`
    // #[derive(Debug, PartialEq)] pub struct SynActions();
    // /// User-defined type for `action`
    // #[derive(Debug, PartialEq)] pub struct SynAction();
    // /// User-defined type for `match`
    // #[derive(Debug, PartialEq)] pub struct SynMatch();
    // /// User-defined type for `alt_items`
    // #[derive(Debug, PartialEq)] pub struct SynAltItems();
    // /// User-defined type for `alt_item`
    // #[derive(Debug, PartialEq)] pub struct SynAltItem();
    // /// User-defined type for `repeat_item`
    // #[derive(Debug, PartialEq)] pub struct SynRepeatItem();
    // /// User-defined type for `item`
    // #[derive(Debug, PartialEq)] pub struct SynItem();
    // /// User-defined type for `char_set`
    // #[derive(Debug, PartialEq)] pub struct SynCharSet();
    // /// User-defined type for `char_set_one`
    // #[derive(Debug, PartialEq)] pub struct SynCharSetOne();
    /// Computed `file_item*` array in `file -> header  ►► file_item* ◄◄  |  ►► file_item* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynFile1(pub Vec<SynFileItem>);
    /// Computed `("," Id)*` array in `option -> "channels" "{" Id  ►► ("," Id)* ◄◄  "}"`
    #[derive(Debug, PartialEq)]
    pub struct SynOption1(pub Vec<String>);
    /// Computed `("," action)*` array in `actions -> action  ►► ("," action)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynActions1(pub Vec<SynAction>);
    /// Computed `("|" alt_item)*` array in `alt_items -> alt_item  ►► ("|" alt_item)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItems1(pub Vec<SynAltItem>);
    /// Computed `repeat_item+` array in `alt_item ->  ►► repeat_item+ ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItem1(pub Vec<SynRepeatItem>);
    /// Computed `char_set_one+` array in `char_set -> "["  ►► char_set_one+ ◄◄  "]" | "." | FixedSet`
    #[derive(Debug, PartialEq)]
    pub struct SynCharSet1(pub Vec<SynCharSetOne>);

    #[derive(Debug)]
    enum SynValue { File(SynFile), FileItem(SynFileItem), Header(SynHeader), Declaration(SynDeclaration), Option(SynOption), Rule(SynRule), Actions(SynActions), Action(SynAction), Match(SynMatch), AltItems(SynAltItems), AltItem(SynAltItem), RepeatItem(SynRepeatItem), Item(SynItem), CharSet(SynCharSet), CharSetOne(SynCharSetOne), File1(SynFile1), Option1(SynOption1), Actions1(SynActions1), AltItems1(SynAltItems1), AltItem1(SynAltItem1), CharSet1(SynCharSet1) }

    impl SynValue {
        fn get_file(self) -> SynFile {
            if let SynValue::File(val) = self { val } else { panic!() }
        }
        fn get_file_item(self) -> SynFileItem {
            if let SynValue::FileItem(val) = self { val } else { panic!() }
        }
        fn get_header(self) -> SynHeader {
            if let SynValue::Header(val) = self { val } else { panic!() }
        }
        fn get_declaration(self) -> SynDeclaration {
            if let SynValue::Declaration(val) = self { val } else { panic!() }
        }
        fn get_option(self) -> SynOption {
            if let SynValue::Option(val) = self { val } else { panic!() }
        }
        fn get_rule(self) -> SynRule {
            if let SynValue::Rule(val) = self { val } else { panic!() }
        }
        fn get_actions(self) -> SynActions {
            if let SynValue::Actions(val) = self { val } else { panic!() }
        }
        fn get_action(self) -> SynAction {
            if let SynValue::Action(val) = self { val } else { panic!() }
        }
        fn get_match(self) -> SynMatch {
            if let SynValue::Match(val) = self { val } else { panic!() }
        }
        fn get_alt_items(self) -> SynAltItems {
            if let SynValue::AltItems(val) = self { val } else { panic!() }
        }
        fn get_alt_item(self) -> SynAltItem {
            if let SynValue::AltItem(val) = self { val } else { panic!() }
        }
        fn get_repeat_item(self) -> SynRepeatItem {
            if let SynValue::RepeatItem(val) = self { val } else { panic!() }
        }
        fn get_item(self) -> SynItem {
            if let SynValue::Item(val) = self { val } else { panic!() }
        }
        fn get_char_set(self) -> SynCharSet {
            if let SynValue::CharSet(val) = self { val } else { panic!() }
        }
        fn get_char_set_one(self) -> SynCharSetOne {
            if let SynValue::CharSetOne(val) = self { val } else { panic!() }
        }
        fn get_file1(self) -> SynFile1 {
            if let SynValue::File1(val) = self { val } else { panic!() }
        }
        fn get_option1(self) -> SynOption1 {
            if let SynValue::Option1(val) = self { val } else { panic!() }
        }
        fn get_actions1(self) -> SynActions1 {
            if let SynValue::Actions1(val) = self { val } else { panic!() }
        }
        fn get_alt_items1(self) -> SynAltItems1 {
            if let SynValue::AltItems1(val) = self { val } else { panic!() }
        }
        fn get_alt_item1(self) -> SynAltItem1 {
            if let SynValue::AltItem1(val) = self { val } else { panic!() }
        }
        fn get_char_set1(self) -> SynCharSet1 {
            if let SynValue::CharSet1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _file: SynFile) {}
        fn init_file(&mut self) {}
        fn exit_file(&mut self, _ctx: CtxFile) -> SynFile;
        fn init_file_item(&mut self) {}
        fn exit_file_item(&mut self, _ctx: CtxFileItem) -> SynFileItem;
        fn init_header(&mut self) {}
        fn exit_header(&mut self, _ctx: CtxHeader) -> SynHeader;
        fn init_declaration(&mut self) {}
        fn exit_declaration(&mut self, _ctx: CtxDeclaration) -> SynDeclaration;
        fn init_option(&mut self) {}
        fn exit_option(&mut self, _ctx: CtxOption) -> SynOption;
        fn init_rule(&mut self) {}
        fn exit_rule(&mut self, _ctx: CtxRule) -> SynRule;
        fn init_actions(&mut self) {}
        fn exit_actions(&mut self, _ctx: CtxActions) -> SynActions;
        fn init_action(&mut self) {}
        fn exit_action(&mut self, _ctx: CtxAction) -> SynAction;
        fn init_match(&mut self) {}
        fn exit_match(&mut self, _ctx: CtxMatch) -> SynMatch;
        fn init_alt_items(&mut self) {}
        fn exit_alt_items(&mut self, _ctx: CtxAltItems) -> SynAltItems;
        fn init_alt_item(&mut self) {}
        fn exit_alt_item(&mut self, _ctx: CtxAltItem) -> SynAltItem;
        fn init_repeat_item(&mut self) {}
        fn exit_repeat_item(&mut self, _ctx: CtxRepeatItem) -> SynRepeatItem;
        fn init_item(&mut self) {}
        fn exit_item(&mut self, _ctx: CtxItem) -> SynItem;
        fn init_char_set(&mut self) {}
        fn exit_char_set(&mut self, _ctx: CtxCharSet) -> SynCharSet;
        fn init_char_set_one(&mut self) {}
        fn exit_char_set_one(&mut self, _ctx: CtxCharSetOne) -> SynCharSetOne;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_file(),             // file
                        15 => self.init_file1(),                    // file_1
                        1 => self.listener.init_file_item(),        // file_item
                        2 => self.listener.init_header(),           // header
                        3 => self.listener.init_declaration(),      // declaration
                        4 => self.listener.init_option(),           // option
                        16 => self.init_option1(),                  // option_1
                        5 => self.listener.init_rule(),             // rule
                        21 => {}                                    // rule_1
                        6 => self.listener.init_actions(),          // actions
                        17 => self.init_actions1(),                 // actions_1
                        7 => self.listener.init_action(),           // action
                        8 => self.listener.init_match(),            // match
                        9 => self.listener.init_alt_items(),        // alt_items
                        18 => self.init_alt_items1(),               // alt_items_1
                        10 => self.listener.init_alt_item(),        // alt_item
                        19 => self.init_alt_item1(),                // alt_item_1
                        25 => {}                                    // alt_item_2
                        11 => self.listener.init_repeat_item(),     // repeat_item
                        22 => {}                                    // repeat_item_1
                        27 | 28 => {}                               // repeat_item_2, repeat_item_3
                        12 => self.listener.init_item(),            // item
                        23 => {}                                    // item_1
                        13 => self.listener.init_char_set(),        // char_set
                        20 => self.init_char_set1(),                // char_set_1
                        26 => {}                                    // char_set_2
                        14 => self.listener.init_char_set_one(),    // char_set_one
                        24 => {}                                    // char_set_one_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // file -> header file_1
                        1 => self.exit_file(alt_id),                // file -> file_1
                        33 => self.exit_file1(),                    // file_1 -> file_item file_1
                        34 => {}                                    // file_1 -> ε
                        2 |                                         // file_item -> option
                        3 |                                         // file_item -> declaration
                        4 => self.exit_file_item(alt_id),           // file_item -> rule
                        5 => self.exit_header(),                    // header -> "lexicon" Id ";"
                        6 => self.exit_declaration(),               // declaration -> "mode" Id ";"
                        7 => self.exit_option(),                    // option -> "channels" "{" Id option_1 "}"
                        35 => self.exit_option1(),                  // option_1 -> "," Id option_1
                        36 => {}                                    // option_1 -> ε
                        8 |                                         // rule -> "fragment" Id ":" match ";"
                        43 |                                        // rule_1 -> "->" actions ";"
                        44 => self.exit_rule(alt_id),               // rule_1 -> ";"
                     /* 9 */                                        // rule -> Id ":" match rule_1 (never called)
                        10 => self.exit_actions(),                  // actions -> action actions_1
                        37 => self.exit_actions1(),                 // actions_1 -> "," action actions_1
                        38 => {}                                    // actions_1 -> ε
                        11 |                                        // action -> "mode" "(" Id ")"
                        12 |                                        // action -> "push" "(" Id ")"
                        13 |                                        // action -> "pop"
                        14 |                                        // action -> "skip"
                        15 |                                        // action -> "more"
                        16 |                                        // action -> "type" "(" Id ")"
                        17 => self.exit_action(alt_id),             // action -> "channel" "(" Id ")"
                        18 => self.exit_match(),                    // match -> alt_items
                        19 => self.exit_alt_items(),                // alt_items -> alt_item alt_items_1
                        39 => self.exit_alt_items1(),               // alt_items_1 -> "|" alt_item alt_items_1
                        40 => {}                                    // alt_items_1 -> ε
                        20 => self.exit_alt_item(),                 // alt_item -> alt_item_1
                        53 |                                        // alt_item_2 -> alt_item_1
                        54 => self.exit_alt_item1(),                // alt_item_2 -> ε
                     /* 41 */                                       // alt_item_1 -> repeat_item alt_item_2 (never called)
                        46 |                                        // repeat_item_1 -> "?"
                        48 |                                        // repeat_item_1 -> ε
                        57 |                                        // repeat_item_2 -> "?"
                        58 |                                        // repeat_item_2 -> ε
                        59 |                                        // repeat_item_3 -> "?"
                        60 => self.exit_repeat_item(alt_id),        // repeat_item_3 -> ε
                     /* 21 */                                       // repeat_item -> item repeat_item_1 (never called)
                     /* 45 */                                       // repeat_item_1 -> "+" repeat_item_2 (never called)
                     /* 47 */                                       // repeat_item_1 -> "*" repeat_item_3 (never called)
                        22 |                                        // item -> "(" alt_items ")"
                        23 |                                        // item -> "~" item
                        24 |                                        // item -> Id
                        26 |                                        // item -> StrLit
                        27 |                                        // item -> char_set
                        49 |                                        // item_1 -> ".." CharLit
                        50 => self.exit_item(alt_id),               // item_1 -> ε
                     /* 25 */                                       // item -> CharLit item_1 (never called)
                        28 |                                        // char_set -> "[" char_set_1 "]"
                        29 |                                        // char_set -> "."
                        30 => self.exit_char_set(alt_id),           // char_set -> FixedSet
                        55 |                                        // char_set_2 -> char_set_1
                        56 => self.exit_char_set1(),                // char_set_2 -> ε
                     /* 42 */                                       // char_set_1 -> char_set_one char_set_2 (never called)
                        31 |                                        // char_set_one -> FixedSet
                        51 |                                        // char_set_one_1 -> "-" SetChar
                        52 => self.exit_char_set_one(alt_id),       // char_set_one_1 -> ε
                     /* 32 */                                       // char_set_one -> SetChar char_set_one_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let file = self.stack.pop().unwrap().get_file();
            self.listener.exit(file);
        }

        fn exit_file(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    let header = self.stack.pop().unwrap().get_header();
                    CtxFile::File1 { header, star }
                }
                1 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    CtxFile::File2 { star }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file")
            };
            let val = self.listener.exit_file(ctx);
            self.stack.push(SynValue::File(val));
        }

        fn init_file1(&mut self) {
            let val = SynFile1(Vec::new());
            self.stack.push(SynValue::File1(val));
        }

        fn exit_file1(&mut self) {
            let file_item = self.stack.pop().unwrap().get_file_item();
            let mut star_it = self.stack.pop().unwrap().get_file1();
            star_it.0.push(file_item);
            self.stack.push(SynValue::File1(star_it));
        }

        fn exit_file_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                2 => {
                    let option = self.stack.pop().unwrap().get_option();
                    CtxFileItem::FileItem1 { option }
                }
                3 => {
                    let declaration = self.stack.pop().unwrap().get_declaration();
                    CtxFileItem::FileItem2 { declaration }
                }
                4 => {
                    let rule = self.stack.pop().unwrap().get_rule();
                    CtxFileItem::FileItem3 { rule }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file_item")
            };
            let val = self.listener.exit_file_item(ctx);
            self.stack.push(SynValue::FileItem(val));
        }

        fn exit_header(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_header(CtxHeader::Header { id });
            self.stack.push(SynValue::Header(val));
        }

        fn exit_declaration(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_declaration(CtxDeclaration::Declaration { id });
            self.stack.push(SynValue::Declaration(val));
        }

        fn exit_option(&mut self) {
            let star = self.stack.pop().unwrap().get_option1();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_option(CtxOption::Option { id, star });
            self.stack.push(SynValue::Option(val));
        }

        fn init_option1(&mut self) {
            let val = SynOption1(Vec::new());
            self.stack.push(SynValue::Option1(val));
        }

        fn exit_option1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_option1();
            star_it.0.push(id);
            self.stack.push(SynValue::Option1(star_it));
        }

        fn exit_rule(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                8 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule1 { id, match1 }
                }
                43 => {
                    let actions = self.stack.pop().unwrap().get_actions();
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule2 { id, match1, actions }
                }
                44 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule3 { id, match1 }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_rule")
            };
            let val = self.listener.exit_rule(ctx);
            self.stack.push(SynValue::Rule(val));
        }

        fn exit_actions(&mut self) {
            let star = self.stack.pop().unwrap().get_actions1();
            let action = self.stack.pop().unwrap().get_action();
            let val = self.listener.exit_actions(CtxActions::Actions { action, star });
            self.stack.push(SynValue::Actions(val));
        }

        fn init_actions1(&mut self) {
            let val = SynActions1(Vec::new());
            self.stack.push(SynValue::Actions1(val));
        }

        fn exit_actions1(&mut self) {
            let action = self.stack.pop().unwrap().get_action();
            let mut star_it = self.stack.pop().unwrap().get_actions1();
            star_it.0.push(action);
            self.stack.push(SynValue::Actions1(star_it));
        }

        fn exit_action(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action1 { id }
                }
                12 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action2 { id }
                }
                13 => {
                    CtxAction::Action3
                }
                14 => {
                    CtxAction::Action4
                }
                15 => {
                    CtxAction::Action5
                }
                16 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action6 { id }
                }
                17 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action7 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_action")
            };
            let val = self.listener.exit_action(ctx);
            self.stack.push(SynValue::Action(val));
        }

        fn exit_match(&mut self) {
            let alt_items = self.stack.pop().unwrap().get_alt_items();
            let val = self.listener.exit_match(CtxMatch::Match { alt_items });
            self.stack.push(SynValue::Match(val));
        }

        fn exit_alt_items(&mut self) {
            let star = self.stack.pop().unwrap().get_alt_items1();
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let val = self.listener.exit_alt_items(CtxAltItems::AltItems { alt_item, star });
            self.stack.push(SynValue::AltItems(val));
        }

        fn init_alt_items1(&mut self) {
            let val = SynAltItems1(Vec::new());
            self.stack.push(SynValue::AltItems1(val));
        }

        fn exit_alt_items1(&mut self) {
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let mut star_it = self.stack.pop().unwrap().get_alt_items1();
            star_it.0.push(alt_item);
            self.stack.push(SynValue::AltItems1(star_it));
        }

        fn exit_alt_item(&mut self) {
            let plus = self.stack.pop().unwrap().get_alt_item1();
            let val = self.listener.exit_alt_item(CtxAltItem::AltItem { plus });
            self.stack.push(SynValue::AltItem(val));
        }

        fn init_alt_item1(&mut self) {
            let val = SynAltItem1(Vec::new());
            self.stack.push(SynValue::AltItem1(val));
        }

        fn exit_alt_item1(&mut self) {
            let repeat_item = self.stack.pop().unwrap().get_repeat_item();
            let mut plus_it = self.stack.pop().unwrap().get_alt_item1();
            plus_it.0.push(repeat_item);
            self.stack.push(SynValue::AltItem1(plus_it));
        }

        fn exit_repeat_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                46 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem1 { item }
                }
                48 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem2 { item }
                }
                57 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem3 { item }
                }
                58 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem4 { item }
                }
                59 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem5 { item }
                }
                60 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem6 { item }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_repeat_item")
            };
            let val = self.listener.exit_repeat_item(ctx);
            self.stack.push(SynValue::RepeatItem(val));
        }

        fn exit_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                22 => {
                    let alt_items = self.stack.pop().unwrap().get_alt_items();
                    CtxItem::Item1 { alt_items }
                }
                23 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxItem::Item2 { item }
                }
                24 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxItem::Item3 { id }
                }
                26 => {
                    let strlit = self.stack_t.pop().unwrap();
                    CtxItem::Item4 { strlit }
                }
                27 => {
                    let char_set = self.stack.pop().unwrap().get_char_set();
                    CtxItem::Item5 { char_set }
                }
                49 => {
                    let charlit_2 = self.stack_t.pop().unwrap();
                    let charlit_1 = self.stack_t.pop().unwrap();
                    CtxItem::Item6 { charlit: [charlit_1, charlit_2] }
                }
                50 => {
                    let charlit = self.stack_t.pop().unwrap();
                    CtxItem::Item7 { charlit }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_item")
            };
            let val = self.listener.exit_item(ctx);
            self.stack.push(SynValue::Item(val));
        }

        fn exit_char_set(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                28 => {
                    let plus = self.stack.pop().unwrap().get_char_set1();
                    CtxCharSet::CharSet1 { plus }
                }
                29 => {
                    CtxCharSet::CharSet2
                }
                30 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSet::CharSet3 { fixedset }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set")
            };
            let val = self.listener.exit_char_set(ctx);
            self.stack.push(SynValue::CharSet(val));
        }

        fn init_char_set1(&mut self) {
            let val = SynCharSet1(Vec::new());
            self.stack.push(SynValue::CharSet1(val));
        }

        fn exit_char_set1(&mut self) {
            let char_set_one = self.stack.pop().unwrap().get_char_set_one();
            let mut plus_it = self.stack.pop().unwrap().get_char_set1();
            plus_it.0.push(char_set_one);
            self.stack.push(SynValue::CharSet1(plus_it));
        }

        fn exit_char_set_one(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                31 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne1 { fixedset }
                }
                51 => {
                    let setchar_2 = self.stack_t.pop().unwrap();
                    let setchar_1 = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne2 { setchar: [setchar_1, setchar_2] }
                }
                52 => {
                    let setchar = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne3 { setchar }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set_one")
            };
            let val = self.listener.exit_char_set_one(ctx);
            self.stack.push(SynValue::CharSetOne(val));
        }
    }

    // [wrapper source for rule RTS(100) #1, start file]
    // ------------------------------------------------------------
}
