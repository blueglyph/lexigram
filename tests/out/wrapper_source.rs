// Copyright (c) 2025 Redglyph (@gmail.com). All Rights Reserved.

#![cfg(test)]
//#![allow(non_camel_case_types)]
#![allow(dead_code)]

pub(crate) mod level_string {
    use std::cmp::max;

    #[derive(Debug, PartialEq)]
    pub struct LevelString(pub u32, pub String);

    impl LevelString {
        pub fn get_string(self) -> String {
            self.1
        }
    }

    pub fn par(ls: LevelString) -> String {
        if ls.0 > 0 {
            format!("({})", ls.1)
        } else {
            ls.1
        }
    }

    pub fn ls_prefix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{op} {}", par(ls)))
    }

    pub fn ls_suffix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{} {op}", par(ls)))
    }

    pub fn ls_binary_op(op: &str, lsleft: LevelString, lsright: LevelString) -> LevelString {
        LevelString(max(lsleft.0, lsright.0) + 1, format!("{} {op} {}", par(lsleft), par(lsright)))
    }
}

// Most of the code below is generated by parsergen::tests::wrapper_source::build_items

// ================================================================================

pub(crate) mod rules_13_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 13 #1, start s]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_13_1::*;

    #[derive(Debug)]
    pub enum CtxS {
        /// `s -> Id "=" val`
        S1 { id: String, val: SynVal },
        /// `s -> "exit"`
        S2,
        /// `s -> "return" val`
        S3 { val: SynVal },
    }
    #[derive(Debug)]
    pub enum CtxVal {
        /// `val -> Id`
        Val1 { id: String },
        /// `val -> Num`
        Val2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `s`
    // #[derive(Debug, PartialEq)] pub struct SynS();
    // /// User-defined type for `val`
    // #[derive(Debug, PartialEq)] pub struct SynVal();

    #[derive(Debug)]
    enum SynValue { S(SynS), Val(SynVal) }

    impl SynValue {
        fn get_s(self) -> SynS {
            if let SynValue::S(val) = self { val } else { panic!() }
        }
        fn get_val(self) -> SynVal {
            if let SynValue::Val(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _s: SynS) {}
        fn init_s(&mut self) {}
        fn exit_s(&mut self, _ctx: CtxS) -> SynS;
        fn init_val(&mut self) {}
        fn exit_val(&mut self, _ctx: CtxVal) -> SynVal;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_s(),                // s
                        1 => self.listener.init_val(),              // val
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // s -> Id "=" val
                        1 |                                         // s -> "exit"
                        2 => self.exit_s(alt_id),                   // s -> "return" val
                        3 |                                         // val -> Id
                        4 => self.exit_val(alt_id),                 // val -> Num
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let s = self.stack.pop().unwrap().get_s();
            self.listener.exit(s);
        }

        fn exit_s(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let val = self.stack.pop().unwrap().get_val();
                    let id = self.stack_t.pop().unwrap();
                    CtxS::S1 { id, val }
                }
                1 => {
                    CtxS::S2
                }
                2 => {
                    let val = self.stack.pop().unwrap().get_val();
                    CtxS::S3 { val }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_s")
            };
            let val = self.listener.exit_s(ctx);
            self.stack.push(SynValue::S(val));
        }

        fn exit_val(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxVal::Val1 { id }
                }
                4 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxVal::Val2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_val")
            };
            let val = self.listener.exit_val(ctx);
            self.stack.push(SynValue::Val(val));
        }
    }

    // [wrapper source for rule 13 #1, start s]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_102_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 102 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_102_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B* C`
        A { a: String, star: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B*` array in `a -> A  ►► B* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 => self.exit_a1(),                        // a_1 -> B a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 102 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_103_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 103 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_103_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A B+ C`
        A { a: String, plus: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `B+` array in `a -> A  ►► B+ ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        2 |                                         // a_2 -> a_1
                        3 => self.exit_a1(),                        // a_2 -> ε
                     /* 1 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }
    }

    // [wrapper source for rule 103 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_106_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        A { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `(b ",")*` array in `a -> (A  ►► (b ",")* ◄◄  ";")* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynB>);
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `A (b ",")* ";"` item in `a -> ( ►► A (b ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub a: String, pub star: SynA1 }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        2 => self.init_a1(),                        // a_1
                        3 => self.init_a2(),                        // a_2
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 => self.exit_a1(),                        // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { a, star });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 106 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_106_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 106 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_106_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (b ",")* ";")* C`
        A { star: SynA2, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(A (b ",")* ";")*` array in `a ->  ►► (A (b ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        3 => self.init_a2(),                        // a_2
                        2 => {}                                     // a_1
                        1 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_2 C
                        2 |                                         // a_1 -> b "," a_1
                        3 => {}                                     // a_1 -> ε
                        4 => self.exit_a2(),                        // a_2 -> A a_1 ";" a_2
                        5 => {}                                     // a_2 -> ε
                        1 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(a);
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 106 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_108_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 108 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_108_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A "B"* C`
        A { a: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 C
                        1 |                                         // a_1 -> "B" a_1
                        2 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 108 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

// TODO: code generation not fully supported yet
#[cfg(any())]
pub(crate) mod rules_150_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 150 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_150_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A | B)*`
        A { star: SynA1 },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(A | B)*` array in `a ->  ►► (A | B)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1
                        1 |                                         // a_1 -> A a_1
                        3 => self.exit_a1(alt_id),                  // a_1 -> B a_1
                        3 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_a1();
            let val = self.listener.exit_a(CtxA::A { star });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(a);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 150 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

// TODO: code generation not fully supported yet
#[cfg(any())]
pub(crate) mod rules_152_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 152 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_152_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (B | C D | E)* F`
        A { a: String, star: SynA1, f: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(B | C D | E)*` array in `a -> A  ►► (B | C D | E)* ◄◄  F`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B` item in `a -> A ( ►► B ◄◄  | C D | E)* F`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub c: String, pub d: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 F
                        1 |                                         // a_1 -> B a_1
                        2 |                                         // a_1 -> C D a_1
                        4 => self.exit_a1(alt_id),                  // a_1 -> E a_1
                        4 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let f = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, f });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 152 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

// TODO: code generation not fully supported yet
// #[cfg(any())]
pub(crate) mod rules_153_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 153 #1, start a]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 6;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("A", None), ("B", None), ("C", None), ("D", None), ("E", None), ("F", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["a", "a_1", "a_2", "a_3", "a_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 2, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::T(0), Symbol::NT(1), Symbol::T(5)], &[Symbol::T(1), Symbol::NT(2)], &[Symbol::T(2), Symbol::T(3), Symbol::NT(3)], &[Symbol::T(4), Symbol::NT(4)], &[Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(1)], &[Symbol::Empty]];
    static PARSING_TABLE: [AltId; 35] = [0, 10, 10, 10, 10, 10, 11, 10, 1, 2, 10, 3, 11, 10, 10, 4, 4, 10, 4, 5, 10, 10, 6, 6, 10, 6, 7, 10, 10, 8, 8, 10, 8, 9, 10];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::Exit(0), OpCode::T(5), OpCode::NT(1), OpCode::T(0)], &[OpCode::NT(2), OpCode::T(1)], &[OpCode::NT(3), OpCode::T(3), OpCode::T(2)], &[OpCode::NT(4), OpCode::T(4)], &[OpCode::Loop(1), OpCode::Exit(4)], &[OpCode::Exit(5)], &[OpCode::Loop(1), OpCode::Exit(6)], &[OpCode::Exit(7)], &[OpCode::Loop(1), OpCode::Exit(8)], &[OpCode::Exit(9)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (B | C D | E)+ F`
        A { a: String, plus: SynA1, f: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `(B | C D | E)+` array in `a -> A  ►► (B | C D | E)+ ◄◄  F`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B` item in `a -> A ( ►► B ◄◄  | C D | E)+ F`
    #[derive(Debug, PartialEq)]
    pub enum SynA1Item {
        A1 { b: String},
        A2 { c: String, d: String },
        A3 { e: String }
    }

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 ..= 4 => {}                               // a_2, a_3, a_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A a_1 F
                        4 |                                         // a_2 -> a_1
                        5 |                                         // a_2 -> ε
                        6 |                                         // a_3 -> a_1
                        7 |                                         // a_3 -> ε
                        8 |                                         // a_4 -> a_1
                        9 => self.exit_a1(alt_id),                  // a_4 -> ε
                     /* 1 */                                        // a_1 -> B a_2 (never called)
                     /* 2 */                                        // a_1 -> C D a_3 (never called)
                     /* 3 */                                        // a_1 -> E a_4 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let f = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, f });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let val = match alt_id {
                4 | 5 => {
                    let b = self.stack_t.pop().unwrap();
                    SynA1Item::A1 { b }
                }
                6 | 7 => {
                    let d = self.stack_t.pop().unwrap();
                    let c = self.stack_t.pop().unwrap();
                    SynA1Item::A2 { c, d }
                }
                8 | 9 => {
                    let e = self.stack_t.pop().unwrap();
                    SynA1Item::A3 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let SynValue::A1(SynA1(plus_it)) = self.stack.last_mut().unwrap() else {
                panic!("unexpected SynA1 item on wrapper stack");
            };
            plus_it.push(val);
        }
    }

    // [wrapper source for rule 153 #1, start a]
    // ------------------------------------------------------------

    #[derive(Debug)]
    pub struct SynA(pub Vec<String>);

    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::lexer::CaretCol;
        use super::*;
        use lexigram_lib::log::{BufLog, LogStatus};

        struct EListener {
            log: BufLog,
            result: Option<Vec<String>>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, a: SynA) {
                self.result = Some(a.0);
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                let CtxA::A { a, plus, f } = ctx;
                let mut val = vec![];
                val.push(a);
                val.extend(plus.0.into_iter()
                    .map(|choice| {
                        match choice {
                            SynA1Item::A1 { b } => format!("b({b})"),
                            SynA1Item::A2 { c, d } => format!("c({c}), d({d})"),
                            SynA1Item::A3 { e } => format!("e({e})"),
                        }
                }));
                val.push(f);
                SynA(val)
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // a -> A (B | C D | E)+ F
                ("alpha echo charlie delta bravo foxtrot", Some(vec!["alpha", "e(echo)", "c(charlie), d(delta)", "b(bravo)", "foxtrot"])),
                ("A C B F", None),
            ];
            const VERBOSE: bool = true;
            const VERBOSE_LISTENER: bool = false;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let mut stop_lexer = false;
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).filter_map(|(i, w)| {
                    if !stop_lexer {
                        // use the first letter to find a terminal
                        let first = w.chars().next().unwrap_or('?').to_ascii_uppercase().to_string();
                        if let Some(s) = symbols.get(&first) {
                            Some((*s, w.to_string(), 1, i))
                        } else {
                            stop_lexer = true;
                            None
                        }
                    } else {
                        None
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|v| v.into_iter().map(|s| s.to_string()).to_vec()), "test failed for input {input}");
            }
        }

    }
}

// ================================================================================

pub(crate) mod rules_200_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_200_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        A { a: String, star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        I { star_it: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, b });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }
    }

    // [wrapper source for rule 200 #1, start a]
    // ------------------------------------------------------------

    #[test]
    fn test() {
        println!("compiles");
    }
}

// ================================================================================

pub(crate) mod rules_200_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 200 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_200_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)* C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )* C`
        I { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { b });
        }
    }

    // [wrapper source for rule 200 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        I { plus_it: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();

    #[derive(Debug)]
    enum SynValue { A(SynMyA), I(SynMyI) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynMyI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { plus_it, b, last_iteration });
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        I { b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();

    #[derive(Debug)]
    enum SynValue { A(SynMyA) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { b, last_iteration });
        }
    }

    // [wrapper source for rule 201 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_201_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 201 #3, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_201_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B)+ C`
        A { a: String, plus: SynMyI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
        I { plus_it: SynMyI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `<L> B` iteration in `a -> A ( ►► <L> B ◄◄ )+ C`
    // #[derive(Debug, PartialEq)] pub struct SynMyI();
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { I(SynMyI) }

    impl SynValue {
        fn get_i(self) -> SynMyI {
            let SynValue::I(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_i(&mut self) -> SynMyI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynMyI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        2 |                                         // a_1 -> i
                        3 => self.exit_i(alt_id),                   // a_1 -> ε
                     /* 1 */                                        // i -> <L> B a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, c });
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let last_iteration = alt_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { plus_it, b, last_iteration });
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 201 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_206_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 206 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_206_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (A (<L> B ",")* ";")* C`
        A { star: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
        J { star_it: SynAiter, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B ","` iteration in `a -> (A ( ►► <L> B "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynAiter();
    /// Computed `(A (<L> B ",")* ";")*` array in `a ->  ►► (A (<L> B ",")* ";")* ◄◄  C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `A (<L> B ",")* ";"` item in `a -> ( ►► A (<L> B ",")* ";" ◄◄ )* C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub a: String, pub star: SynAiter }

    #[derive(Debug)]
    enum SynValue { A(SynA), J(SynAiter), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynAiter {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_j(&mut self) -> SynAiter;
        fn exit_j(&mut self, _ctx: CtxJ) -> SynAiter;
        fn exitloop_j(&mut self, _star_it: &mut SynAiter) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_j(),                         // j
                        2 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> a_1 C
                        1 => self.exit_j(),                         // j -> <L> B "," j
                        2 => self.exitloop_j(),                     // j -> <L> ε
                        3 => self.exit_a1(),                        // a_1 -> A j ";" a_1
                        4 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_j();
            let val = self.listener.exit_j(CtxJ::J { star_it, b });
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_it);
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { a, star });
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 206 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { star_it: SynI, a: String, star: SynJ },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J { star_it: SynJ, b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();
    // /// User-defined type for `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
    // #[derive(Debug, PartialEq)] pub struct SynJ();
    // /// User-defined type for `b`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI), J(SynJ), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
        fn get_j(self) -> SynJ {
            if let SynValue::J(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
        fn init_j(&mut self) -> SynJ;
        fn exit_j(&mut self, _ctx: CtxJ) -> SynJ;
        fn exitloop_j(&mut self, _star_it: &mut SynJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.init_j(),                         // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => self.exitloop_j(),                     // j -> <L> ε
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let star = self.stack.pop().unwrap().get_j();
            let a = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, a, star });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }

        fn init_j(&mut self) {
            let val = self.listener.init_j();
            self.stack.push(SynValue::J(val));
        }

        fn exit_j(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let star_it = self.stack.pop().unwrap().get_j();
            let val = self.listener.exit_j(CtxJ::J { star_it, b });
            self.stack.push(SynValue::J(val));
        }

        fn exitloop_j(&mut self) {
            let SynValue::J(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_j(star_it);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule 208 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #2, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { star: SynI, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { star_it: SynI, a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, a });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #2, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #3, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { a });
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #3, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_208_4 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 208 #4, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_208_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A (<L> b ",")* ";")* C`
        A { c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A (<L> b ",")* ";"` iteration in `a -> ( ►► <L> A (<L> b ",")* ";" ◄◄ )* C`
        I { a: String },
    }
    #[derive(Debug)]
    pub enum CtxJ {
        /// `<L> b ","` iteration in `a -> (<L> A ( ►► <L> b "," ◄◄ )* ";")* C`
        J,
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `b -> B`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
        fn init_j(&mut self) {}
        fn exit_j(&mut self, _ctx: CtxJ) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        2 => self.listener.init_j(),                // j
                        3 => self.listener.init_b(),                // b
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i C
                        1 => self.exit_i(),                         // i -> <L> A j ";" i
                        3 => self.exit_j(),                         // j -> <L> b "," j
                        2 => {}                                     // i -> <L> ε (not used)
                        4 => {}                                     // j -> <L> ε (not used)
                        5 => self.exit_b(),                         // b -> B
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { c });
        }

        fn exit_i(&mut self) {
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_i(CtxI::I { a });
        }

        fn exit_j(&mut self) {
            self.listener.exit_j(CtxJ::J);
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule 208 #4, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_210_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 210 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_210_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> "B")* C`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> "B"` iteration in `a -> A ( ►► <L> "B" ◄◄ )* C`
        I,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) {}
        fn exit_i(&mut self, _ctx: CtxI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.listener.init_i(),                // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i C
                        1 => self.exit_i(),                         // i -> <L> "B" i
                        2 => {}                                     // i -> <L> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_i(&mut self) {
            self.listener.exit_i(CtxI::I);
        }
    }

    // [wrapper source for rule 210 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_211_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 211 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_211_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A A (B <L>)* C`
        A1 { a: [String; 2], star: SynI, c: String },
        /// `a -> A C (B <L>)* C`
        A2 { a: String, c: [String; 2], star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
        I { star_it: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B <L>` iteration in `a -> A A ( ►► B <L> ◄◄ )* C | A C ( ►► B <L> ◄◄ )* C`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 => {}                                     // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // a_1 -> A i C
                        4 => self.exit_a(alt_id),                   // a_1 -> C i C
                        1 => self.exit_i(),                         // i -> <L> B i
                        2 => self.exitloop_i(),                     // i -> <L> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let a_2 = self.stack_t.pop().unwrap();
                    let a_1 = self.stack_t.pop().unwrap();
                    CtxA::A1 { a: [a_1, a_2], star, c }
                }
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_i();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2], star }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let star_it = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_i(CtxI::I { star_it, b });
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }
    }

    // [wrapper source for rule 211 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_250_1 {

    // ------------------------------------------------------------
    // [wrapper source for rule 250 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_250_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | B)*`
        A { star: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)*`
        I1 { star_it: SynI, a: String },
        /// `B` iteration in `a -> (<L> A |  ►► B ◄◄ )*`
        I2 { star_it: SynI, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)*`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
        fn exitloop_i(&mut self, _star_it: &mut SynI) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        1 |                                         // i -> <L> A i
                        2 => self.exit_i(alt_id),                   // i -> <L> B i
                        3 => self.exitloop_i(),                     // i -> <L> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let star = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { star });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_i();
                    CtxI::I1 { star_it, a }
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_i();
                    CtxI::I2 { star_it, b }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let val = self.listener.exit_i(ctx);
            self.stack.push(SynValue::I(val));
        }

        fn exitloop_i(&mut self) {
            let SynValue::I(star_it) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_i(star_it);
        }
    }

    // [wrapper source for rule 250 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_251_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 251 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_251_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> (<L> A | B)+`
        A { plus: SynI },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)+`
        I1 { plus_it: SynI, a: String, last_iteration: bool },
        /// `B` iteration in `a -> (<L> A |  ►► B ◄◄ )+`
        I2 { plus_it: SynI, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> A` iteration in `a -> ( ►► <L> A ◄◄  | B)+`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 | 3 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> i
                        3 |                                         // a_1 -> i
                        4 |                                         // a_1 -> ε
                        5 |                                         // a_2 -> i
                        6 => self.exit_i(alt_id),                   // a_2 -> ε
                     /* 1 */                                        // i -> <L> A a_1 (never called)
                     /* 2 */                                        // i -> <L> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let plus = self.stack.pop().unwrap().get_i();
            let val = self.listener.exit_a(CtxA::A { plus });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 | 4 => {
                    let last_iteration = alt_id == 4;
                    let a = self.stack_t.pop().unwrap();
                    let plus_it = self.stack.pop().unwrap().get_i();
                    CtxI::I1 { plus_it, a, last_iteration }
                }
                5 | 6 => {
                    let last_iteration = alt_id == 6;
                    let b = self.stack_t.pop().unwrap();
                    let plus_it = self.stack.pop().unwrap().get_i();
                    CtxI::I2 { plus_it, b, last_iteration }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let val = self.listener.exit_i(ctx);
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 251 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_256_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 256 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_256_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A (<L> B A | B A C | D)+ E`
        A { a: String, plus: SynI, e: String },
    }
    #[derive(Debug)]
    pub enum CtxI {
        /// `<L> B A` iteration in `a -> A ( ►► <L> B A ◄◄  | B A C | D)+ E`
        I1 { plus_it: SynI, b: String, a: String, last_iteration: bool },
        /// `D` iteration in `a -> A (<L> B A | B A C |  ►► D ◄◄ )+ E`
        I2 { plus_it: SynI, d: String, last_iteration: bool },
        /// `B A C` iteration in `a -> A (<L> B A |  ►► B A C ◄◄  | D)+ E`
        I3 { plus_it: SynI, b: String, a: String, c: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `<L> B A` iteration in `a -> A ( ►► <L> B A ◄◄  | B A C | D)+ E`
    // #[derive(Debug, PartialEq)] pub struct SynI();

    #[derive(Debug)]
    enum SynValue { A(SynA), I(SynI) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_i(self) -> SynI {
            if let SynValue::I(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_i(&mut self) -> SynI;
        fn exit_i(&mut self, _ctx: CtxI) -> SynI;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_i(),                         // i
                        2 ..= 4 => {}                               // a_1, a_2, a_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.exit_a(),                         // a -> A i E
                        4 |                                         // a_1 -> i
                        5 |                                         // a_1 -> ε
                        6 |                                         // a_2 -> i
                        7 |                                         // a_2 -> ε
                        8 |                                         // a_3 -> i
                        9 => self.exit_i(alt_id),                   // a_3 -> ε
                     /* 1 */                                        // i -> <L> B A a_1 (never called)
                     /* 2 */                                        // i -> <L> D a_2 (never called)
                     /* 3 */                                        // a_1 -> C a_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let e = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_i();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, e });
            self.stack.push(SynValue::A(val));
        }

        fn init_i(&mut self) {
            let val = self.listener.init_i();
            self.stack.push(SynValue::I(val));
        }

        fn exit_i(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 | 5 => {
                    let last_iteration = alt_id == 5;
                    let a = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let plus_it = self.stack.pop().unwrap().get_i();
                    CtxI::I1 { plus_it, b, a, last_iteration }
                }
                6 | 7 => {
                    let last_iteration = alt_id == 7;
                    let d = self.stack_t.pop().unwrap();
                    let plus_it = self.stack.pop().unwrap().get_i();
                    CtxI::I2 { plus_it, d, last_iteration }
                }
                8 | 9 => {
                    let last_iteration = alt_id == 9;
                    let c = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let plus_it = self.stack.pop().unwrap().get_i();
                    CtxI::I3 { plus_it, b, a, c, last_iteration }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_i")
            };
            let val = self.listener.exit_i(ctx);
            self.stack.push(SynValue::I(val));
        }
    }

    // [wrapper source for rule 256 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_301_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        Expr1 { id: String, expr: SynExpr },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let expr = self.stack.pop().unwrap().get_expr();
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id, expr }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 301 #1, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_301_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 301 #2, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_301_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> Id "." expr`
        Expr1 { id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            self.listener.exit_expr(ctx);
        }
    }

    // [wrapper source for rule 301 #2, start expr]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_401_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_401_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        Expr1 { expr: SynExpr, id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_expr(),                      // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr1 { expr, id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr2 { expr, num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 401 #1, start expr]
}

// ================================================================================

pub(crate) mod rules_401_2 {
    #![allow(unused_imports)]
    // ------------------------------------------------------------
    // [wrapper source for rule 401 #2, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_401_2::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Id "." expr`
        Expr1 { id: String },
        /// `expr -> "(" Num ")"`
        Expr2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal Expr (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_expr(&mut self) {}
        fn exit_expr(&mut self, _ctx: CtxExpr) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_expr(),             // expr
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // expr -> <L> Id "." expr
                        1 => self.exit_expr(alt_id),                // expr -> <L> "(" Num ")"
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxExpr::Expr1 { id }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxExpr::Expr2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            self.listener.exit_expr(ctx);
        }
    }

    // [wrapper source for rule 401 #2, start expr]
}

// ================================================================================

pub(crate) mod rules_502_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_502_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        E1 { f: SynF },
        /// `e -> e "." Id`
        E2 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E2 { e, id });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_e(e);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_502_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule 502 #2, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_502_2::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> f`
        E1 { f: SynF },
        /// `e -> e "." Id`
        E2 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `f -> Id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `f`
    // #[derive(Debug, PartialEq)] pub struct SynF();
    /// Top non-terminal E (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynE();

    #[derive(Debug)]
    enum SynValue { F(SynF) }

    impl SynValue {
        fn get_f(self) -> SynF {
            let SynValue::F(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        2 => {}                                     // e_1
                        1 => self.listener.init_f(),                // f
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_e(),                        // e -> f e_1
                        2 => self.exit_e1(),                        // e_1 -> "." Id e_1
                        3 => {}                                     // e_1 -> ε (not used)
                        1 => self.exit_f(),                         // f -> Id
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            self.listener.exit_e(CtxE::E1 { f });
        }

        fn exit_e1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            self.listener.exit_e(CtxE::E2 { id });
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule 502 #2, start e]
    // ------------------------------------------------------------
}

// ================================================================================

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_580_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule 580 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_580_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> "-" e`
        E1 { e: SynE },
        /// `e -> Num`
        E2 { num: String },
        /// `e -> e "!"`
        E3 { e: SynE },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 => {}                                     // e_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // e -> "-" e
                        1 => self.inter_e(alt_id),                  // e -> Num e_1
                        2 => self.exit_e1(),                        // e_1 -> "!" e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E2 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E3 { e });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap();
            self.listener.exitloop_e(e);
        }
    }

    // [wrapper source for rule 580 #1, start e]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener1::build_parser;
        use crate::out::wrapper_source::level_string::{ls_prefix_op, ls_suffix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // e -> "-" e
                    CtxE::E1 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    // e -> Num
                    CtxE::E2 { num } => LevelString(0, num),
                    // e -> e "!"
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("!", ls),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: e -> e "!" | "-" e | Num
                ("- - 0 ! !", Some("- (- ((0 !) !))")),
                ("0 !", Some("0 !")),
                ("- 0", Some("- 0")),
                ("0", Some("0")),
                ("- !", None),
                ("-", None),
                ("!", None),
                ("", None),
                ("- 0 0 !", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let num_id = 2;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            (num_id, w.to_string(), 1, i)
                        } else {
                            panic!("IDs not supported")
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_581_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 581 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_581_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> <L> "-" e`
        E1 { e: SynE },
        /// `e -> Num`
        E2 { e: SynE, num: String },
        /// `e -> e "!"`
        E3 { e: SynE },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) -> SynE;
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exitloop_e(&mut self, _e: &mut SynE) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_e(),                         // e
                        1 => {}                                     // e_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // e -> <L> "-" e
                        1 => self.inter_e(alt_id),                  // e -> <L> Num e_1
                        2 => self.exit_e1(),                        // e_1 -> "!" e_1
                        3 => self.exitloop_e1(),                    // e_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn init_e(&mut self) {
            let val = self.listener.init_e();
            self.stack.push(SynValue::E(val));
        }

        fn inter_e(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E3 { e });
            self.stack.push(SynValue::E(val));
        }

        fn exitloop_e1(&mut self) {
            let SynValue::E(e) = self.stack.last_mut().unwrap();
            self.listener.exitloop_e(e);
        }
    }

    // [wrapper source for rule 581 #1, start e]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener1::build_parser;
        use crate::out::wrapper_source::level_string::{ls_prefix_op, ls_suffix_op, LevelString};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) -> SynE {
                self.result = None;
                SynE(LevelString(0, "".to_string()))
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // e -> <L> "-" e
                    CtxE::E1 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    // e -> Num
                    CtxE::E2 { e: SynE(ls), num } => LevelString(0, num),
                    // e -> e "!"
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("!", ls),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: e -> e "!" | <L> "-" e | Num
                ("- - 0 ! !", Some("- (- ((0 !) !))")),
                ("0 !", Some("0 !")),
                ("- 0", Some("- 0")),
                ("0", Some("0")),
                ("- !", None),
                ("-", None),
                ("!", None),
                ("", None),
                ("- 0 0 !", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let num_id = 2;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if let Some(s) = symbols.get(w) {
                            (*s, w.to_string(), 1, i)
                        } else {
                            if w.chars().next().unwrap().is_ascii_digit() {
                                (num_id, w.to_string(), 1, i)
                            } else {
                                panic!("IDs not supported")
                            }
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

// ================================================================================

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_600_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 600 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_600_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "+" e`
        E1 { e: [SynE; 2] },
        /// `e -> Num`
        E2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 => self.exit_e1(),                        // e_1 -> "+" e_2 e_1
                        3 => self.exit_e2(),                        // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        2 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self) {
            let e_2 = self.stack.pop().unwrap().get_e();
            let e_1 = self.stack.pop().unwrap().get_e();
            let val = self.listener.exit_e(CtxE::E1 { e: [e_1, e_2] });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E2 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 600 #1, start e]
    // ------------------------------------------------------------
}

// ================================================================================

// precedence group:

pub(crate) mod rules_603_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 603 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 603 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_604_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 604 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(2)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e_2
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 604 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_605_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 605 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 2, 3, 3, 4, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(4)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 0, 0, 10, 1, 2, 9, 9, 3, 10, 10, 4, 4, 10, 5, 6, 9, 9, 6, 10, 10, 7, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::NT(3), OpCode::Exit(4), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(6)], &[OpCode::Exit(7), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        5 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 |                                         // e_4 -> "!" e_4
                        8 => self.exit_e4(alt_id),                  // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        4 => {}                                     // e_2 -> e_4 e_3 (not used)
                        6 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                7 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                8 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 605 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_606_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 606 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(0), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> <R> e "!" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> <R> "!" e e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 606 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> <R> e "!" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_607_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 607 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> <R> e "!" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> <R> "!" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> <R> "!" e_2 e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 607 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <R> e "!" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_608_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 608 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> <R> e "!" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "*" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "!" e_4 e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> <R> "!" e_4 e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> <R> "!" e_4 e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 608 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> <R> e "!" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "*" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_609_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 609 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 9, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "!"`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "!" e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 609 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> e "!"`
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_610_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 610 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "!"`
        E2 { e: SynE },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "!" e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "!" e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 610 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "!"`
                    CtxE::E2 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_611_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 611 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "!"`
        E1 { e: SynE },
        /// `e -> e "*" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "!" e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> "!" e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> "!" e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 611 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "!"`
                    CtxE::E1 { e: SynE(ls) } => ls_suffix_op("!", ls),
                    // `e -> e "*" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_612_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 612 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 7;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4", "e_5", "e_6"];
    static ALT_VAR: [VarId; 13] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4, 5, 5, 6];
    static ALTERNATIVES: [&[Symbol]; 13] = [&[Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::NT(6), Symbol::NT(5)], &[Symbol::T(2), Symbol::NT(6), Symbol::NT(5)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 35] = [13, 13, 13, 0, 14, 2, 3, 1, 13, 4, 14, 14, 14, 5, 14, 7, 8, 6, 13, 8, 14, 14, 14, 9, 14, 11, 11, 10, 13, 11, 14, 14, 14, 12, 14];
    static OPCODES: [&[OpCode]; 13] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(6)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(6), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(6)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(6), OpCode::T(2)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(8)], &[OpCode::NT(5), OpCode::Exit(9), OpCode::NT(6)], &[OpCode::Loop(5), OpCode::Exit(10), OpCode::NT(6), OpCode::T(2)], &[OpCode::Exit(11)], &[OpCode::Exit(12), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "!" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "*" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 6 => {}                               // e_1, e_2, e_3, e_4, e_5, e_6
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "!" e_6 e_1
                        2 |                                         // e_1 -> "*" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 |                                         // e_3 -> "!" e_6 e_3 (duplicate of 1)
                        10 => self.exit_e1(1),                      // e_5 -> "!" e_6 e_5 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "*" e_4 e_3 (duplicate of 2)
                        12 => self.exit_e6(),                       // e_6 -> Num
                        0 => {}                                     // e -> e_6 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_6 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        9 => {}                                     // e_4 -> e_6 e_5 (not used)
                        11 => {}                                    // e_5 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e6(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 612 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "!" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "*" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_613_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 613 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 9] = [0, 1, 1, 1, 1, 2, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 9] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [9, 9, 9, 0, 10, 1, 2, 3, 9, 4, 10, 10, 10, 5, 10, 6, 7, 7, 9, 7, 10, 10, 10, 8, 10];
    static OPCODES: [&[OpCode]; 9] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(2)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Exit(7)], &[OpCode::Exit(8), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E2 { e: [SynE; 2] },
        /// `e -> <P> e "!" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "+" e_2 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "!" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        7 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 613 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> <P> e "!" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_614_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 614 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 5;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2", "e_3", "e_4"];
    static ALT_VAR: [VarId; 10] = [0, 1, 1, 1, 1, 2, 3, 3, 3, 4];
    static ALTERNATIVES: [&[Symbol]; 10] = [&[Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(2), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(0), Symbol::NT(4), Symbol::NT(3)], &[Symbol::T(2), Symbol::NT(4), Symbol::NT(3)], &[Symbol::Empty], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 25] = [10, 10, 10, 0, 11, 1, 3, 2, 10, 4, 11, 11, 11, 5, 11, 6, 8, 7, 10, 8, 11, 11, 11, 9, 11];
    static OPCODES: [&[OpCode]; 10] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(4)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::NT(4), OpCode::T(2)], &[OpCode::Loop(1), OpCode::Exit(3), OpCode::NT(2), OpCode::T(1)], &[OpCode::Exit(4)], &[OpCode::NT(3), OpCode::Exit(5), OpCode::NT(4)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(4), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(7), OpCode::NT(4), OpCode::T(2)], &[OpCode::Exit(8)], &[OpCode::Exit(9), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> <P> e "!" e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "!" e_4 e_1
                        3 => self.exit_e1(alt_id),                  // e_1 -> "+" e_2 e_1
                        6 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        7 => self.exit_e1(2),                       // e_3 -> "!" e_4 e_3 (duplicate of 2)
                        9 => self.exit_e4(),                        // e_4 -> Num
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        4 => {}                                     // e_1 -> ε (not used)
                        5 => {}                                     // e_2 -> e_4 e_3 (not used)
                        8 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let val = self.listener.exit_e(CtxE::E4 { num });
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 614 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <P> e "!" e`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("!", lsleft, lsright),
                    // `e -> e "+" e`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_630_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 630 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+"`
        E2 { e: SynE },
        /// `e -> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_1
                        4 |                                         // e_2 -> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 630 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+"`
                    CtxE::E2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_631_1 {
    use super::precedence_type::SynE;

    // ------------------------------------------------------------
    // [wrapper source for rule 631 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "+"`
        E2 { e: SynE },
        /// `e -> <R> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> "+" e_1
                        4 |                                         // e_2 -> <R> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 631 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, TestApi, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> e "+"`
                    CtxE::E2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> <R> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}
pub(crate) mod rules_632_1 {
    use super::precedence_type::{SynE, TestApi};

    // ------------------------------------------------------------
    // [wrapper source for rule 632 #1, start e]

    use lexigram_lib::{CollectJoin, FixedSymTable, grammar::{AltId, Alternative, Symbol, VarId}, log::Logger, parser::{Call, ListenerWrapper, OpCode, Parser}};

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    static SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("Mul", Some("*")), ("Add", Some("+")), ("Op", Some("!")), ("Num", None)];
    static SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["e", "e_1", "e_2"];
    static ALT_VAR: [VarId; 6] = [0, 1, 1, 1, 2, 2];
    static ALTERNATIVES: [&[Symbol]; 6] = [&[Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(0), Symbol::NT(2), Symbol::NT(1)], &[Symbol::T(1), Symbol::NT(1)], &[Symbol::Empty], &[Symbol::T(2), Symbol::NT(0)], &[Symbol::T(3)]];
    static PARSING_TABLE: [AltId; 15] = [7, 7, 0, 0, 7, 1, 2, 6, 6, 3, 7, 7, 4, 5, 7];
    static OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(1), OpCode::Exit(0), OpCode::NT(2)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::NT(2), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(2), OpCode::T(1)], &[OpCode::Exit(3)], &[OpCode::Exit(4), OpCode::NT(0), OpCode::T(2)], &[OpCode::Exit(5), OpCode::T(3)]];
    static START_SYMBOL: VarId = 0;

    pub fn build_parser() -> Parser<'static> {
        let symbol_table = FixedSymTable::new(
            SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))).collect(),
            SYMBOLS_NT.into_iter().map(|s| s.to_string()).collect()
        );
        Parser::new(
            PARSER_NUM_NT, PARSER_NUM_T + 1,
            &ALT_VAR,
            ALTERNATIVES.into_iter().map(|s| Alternative::new(s.to_vec())).collect(),
            OPCODES.into_iter().map(|strip| strip.to_vec()).collect(),
            &PARSING_TABLE,
            symbol_table,
            START_SYMBOL
        )
    }

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> <R> e "+"`
        E2 { e: SynE },
        /// `e -> "!" e`
        E3 { e: SynE },
        /// `e -> Num`
        E4 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 | 2 => {}                                 // e_1, e_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_2 e_1
                        2 => self.exit_e1(alt_id),                  // e_1 -> <R> "+" e_1
                        4 |                                         // e_2 -> "!" e
                        5 => self.exit_e2(alt_id),                  // e_2 -> Num
                        0 => {}                                     // e -> e_2 e_1 (not used)
                        3 => {}                                     // e_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e2(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                5 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E4 { num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e2")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 632 #1, start e]
    // ------------------------------------------------------------

    pub mod listener {
        use lexigram_lib::log::BufLog;
        use lexigram_lib::parser::ParserError;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op, ls_suffix_op, LevelString};
        use crate::out::wrapper_source::precedence_type::{get_stream, Tester};
        use super::*;

        pub struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `e -> e "*" e`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `e -> <R> e "+"`
                    CtxE::E2 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // `e -> "!" e`
                    CtxE::E3 { e: SynE(ls) } => ls_prefix_op("!", ls),
                    // `e -> Num`
                    CtxE::E4 { num } => LevelString(0, num),
                })
            }
        }

        impl TestApi for Tester<Wrapper<EListener>> {
            fn new() -> Self {
                let parser = build_parser();
                let symbols = Self::get_symbols(&parser);
                Tester {
                    parser: build_parser(),
                    wrapper: Wrapper::new(EListener { log: BufLog::new(), result: None }, false),
                    symbols
                }
            }

            fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)> {
                let stream = get_stream(input, &self.symbols);
                let result = self.parser.parse_stream(&mut self.wrapper, stream);
                let log = std::mem::take(&mut self.wrapper.listener.log);
                match result {
                    Ok(_) => Ok((self.wrapper.listener.result.take(), log)),
                    Err(e) => Err((e, log)),
                }
            }
        }
    }
}

pub mod precedence_type {
    use std::collections::HashMap;
    use iter_index::IndexerIterator;
    use lexigram_lib::dfa::TokenId;
    use lexigram_lib::grammar::Symbol;
    use lexigram_lib::lexer::CaretCol;
    use lexigram_lib::log::BufLog;
    use lexigram_lib::parser::{ListenerWrapper, Parser, ParserError, ParserToken};
    use crate::out::wrapper_source::level_string::LevelString;

    const TOK_NUM: TokenId = 3;
    const TOK_ID: TokenId = 4;

    /// User-defined type for `e`
    #[derive(Debug, PartialEq)] pub struct SynE(pub LevelString);

    pub fn get_stream(input: &str, symbols: &HashMap<String, TokenId>) -> impl Iterator<Item=ParserToken> {
        const VERBOSE: bool = false;
        input.chars().index_start::<CaretCol>(1).filter(|(_, c)| !c.is_ascii_whitespace())
        // input.split_ascii_whitespace().index_start::<CaretCol>(1)
            .map(|(i, w)| {
                if let Some(s) = symbols.get(&w.to_string()) {
                    (*s, w.to_string(), 1, i)
                } else {
                    // if w.chars().next().unwrap().is_ascii_digit() {
                    if w.is_ascii_digit() {
                        (TOK_NUM, w.to_string(), 1, i)
                    } else {
                        (TOK_ID, w.to_string(), 1, i)
                    }
                }
            })
            .inspect(|(tok, s, l, c)| { if VERBOSE { println!("STREAM: pos={l:3}:{c:3}, tok={tok}, s={s:?}"); } })
    }

    pub struct Tester<W: ListenerWrapper> {
        pub parser: Parser<'static>,
        pub wrapper: W,
        pub symbols: HashMap<String, TokenId>
    }

    pub trait TestApi {
        fn new() -> Self where Self: Sized;
        fn get_symbols(parser: &Parser) -> HashMap<String, TokenId> where Self: Sized {
            let table = parser.get_symbol_table().unwrap();
            (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>()
        }
        fn parse(&mut self, input: &str) -> Result<(Option<String>, BufLog), (ParserError, BufLog)>;
    }
}

mod test_precedence {
    use lexigram_lib::parser::ParserError;
    use crate::out::wrapper_source::precedence_type::{TestApi, Tester};
    #[allow(unused_imports)]
    use super::{rules_603_1, rules_604_1, rules_605_1, rules_606_1, rules_607_1, rules_608_1, rules_609_1, rules_610_1,
                rules_611_1, rules_612_1, rules_613_1, rules_614_1, rules_630_1, rules_631_1, rules_632_1};
    // use super::{rules_631_1, rules_632_1};

    #[test]
    fn test() {
        let listeners: Vec<(Box<dyn TestApi>, Vec<(&str, Result<Option<&str>, ParserError>)>)> = vec![
            (   // 603: e -> e "*" e | e "+" e |   "!" e | Num
                Box::new(Tester::<rules_603_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("!!2", Ok(Some("! (! 2)"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 3", Ok(Some("! (2 * 3)"))),
                    ("2 + !3", Ok(Some("2 + (! 3)"))),
                    ("!2 + 3", Ok(Some("! (2 + 3)"))),

                    ("2 * a", Err(ParserError::ExtraSymbol)),
                ]),
            (   // 604: e -> e "*" e |   "!" e | e "+" e | Num
                Box::new(Tester::<rules_604_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 3", Ok(Some("! (2 * 3)"))),
                    ("2 + !3", Ok(Some("2 + (! 3)"))),
                    ("!2 + 3", Ok(Some("(! 2) + 3"))),
                ]),
            (   // 605: e ->   "!" e | e "*" e | e "+" e | Num
                Box::new(Tester::<rules_605_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 3", Ok(Some("(! 2) * 3"))),
                    ("2 + !3", Ok(Some("2 + (! 3)"))),
                    ("!2 + 3", Ok(Some("(! 2) + 3"))),
                ]),
            (   // 606: e ->     e "*" e |     e "+" e | <R> e "!" e | Num
                Box::new(Tester::<rules_606_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("2 ! (3 ! 4)"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("((2 * 3) + 4) ! 5"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("1 ! (2 + (3 * 4))"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("(1 * 2) ! (3 + 4)"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("(1 + 2) ! (3 * 4)"))),
                ]),
            (   // 607: e ->     e "*" e | <R> e "!" e |     e "+" e | Num
                Box::new(Tester::<rules_607_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("2 ! (3 ! 4)"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("(2 * 3) + (4 ! 5)"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("(1 ! 2) + (3 * 4)"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("((1 * 2) ! 3) + 4"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("1 + (2 ! (3 * 4))"))),
                ]),
            (   // 608: e -> <R> e "!" e |     e "*" e |     e "+" e | Num
                Box::new(Tester::<rules_608_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("2 ! (3 ! 4)"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("(2 * 3) + (4 ! 5)"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("(1 ! 2) + (3 * 4)"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("(1 * (2 ! 3)) + 4"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("1 + ((2 ! 3) * 4)"))),
                ]),
            (   // 609: e -> e "*" e | e "+" e | e "!"   | Num
                Box::new(Tester::<rules_609_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * 3!", Ok(Some("(2 * 3) !"))),
                    ("2! * 3", Ok(Some("(2 !) * 3"))),
                    ("2 + 3!", Ok(Some("(2 + 3) !"))),
                    ("2! + 3", Ok(Some("(2 !) + 3"))),
                ]),
            (   // 610: e -> e "*" e | e "!"   | e "+" e | Num
                Box::new(Tester::<rules_610_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * 3!", Ok(Some("(2 * 3) !"))),
                    ("2! * 3", Ok(Some("(2 !) * 3"))),
                    ("2 + 3!", Ok(Some("2 + (3 !)"))),
                    ("2! + 3", Ok(Some("(2 !) + 3"))),
                ]),
            (   // 611: e -> e "!"   | e "*" e | e "+" e | Num
                Box::new(Tester::<rules_611_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 * 3 + 4", Ok(Some("(2 * 3) + 4"))),
                    ("2 + 3 * 4", Ok(Some("2 + (3 * 4)"))),
                    ("2 * 3!", Ok(Some("2 * (3 !)"))),
                    ("2! * 3", Ok(Some("(2 !) * 3"))),
                    ("2 + 3!", Ok(Some("2 + (3 !)"))),
                    ("2! + 3", Ok(Some("(2 !) + 3"))),
                ]),
            (   // 612: e -> e "!" e |     e "*" e |     e "+" e | Num
                Box::new(Tester::<rules_612_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("(2 ! 3) ! 4"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("(2 * 3) + (4 ! 5)"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("(1 ! 2) + (3 * 4)"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("(1 * (2 ! 3)) + 4"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("1 + ((2 ! 3) * 4)"))),
                ]),
            (   // 613: e -> e "*" e |     e "+" e | <P> e "!" e | Num
                Box::new(Tester::<rules_613_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("(2 ! 3) ! 4"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("((2 * 3) + 4) ! 5"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("(1 ! 2) + (3 * 4)"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("((1 * 2) ! 3) + 4"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("(1 + 2) ! (3 * 4)"))),
                ]),
            (   // 614: e -> e "*" e | <P> e "!" e |     e "+" e | Num
                Box::new(Tester::<rules_614_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2 + 3 + 4", Ok(Some("(2 + 3) + 4"))),
                    ("2 ! 3 ! 4", Ok(Some("(2 ! 3) ! 4"))),
                    ("2 * 3 + 4 ! 5", Ok(Some("(2 * 3) + (4 ! 5)"))),
                    ("1 ! 2 + 3 * 4", Ok(Some("(1 ! 2) + (3 * 4)"))),
                    ("1 * 2 ! 3 + 4", Ok(Some("((1 * 2) ! 3) + 4"))),
                    ("1 + 2 ! 3 * 4", Ok(Some("1 + ((2 ! 3) * 4)"))),
                ]),
            (   // 630: e -> e "*" e |     e "+" |     "!" e | Num
                Box::new(Tester::<rules_630_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2++", Ok(Some("(2 +) +"))),
                    ("!!2", Ok(Some("! (! 2)"))),
                    ("2 * 3+", Ok(Some("(2 * 3) +"))),
                    ("2+ * 4", Ok(Some("(2 +) * 4"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 4", Ok(Some("! (2 * 4)"))),
                    ("!2+", Ok(Some("! (2 +)"))),
                ]),
            (   // 631: e -> e "*" e |     e "+" | <R> "!" e | Num
                Box::new(Tester::<rules_631_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2++", Ok(Some("(2 +) +"))),
                    ("!!2", Ok(Some("! (! 2)"))),
                    ("2 * 3+", Ok(Some("(2 * 3) +"))),
                    ("2+ * 4", Ok(Some("(2 +) * 4"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 4", Ok(Some("! (2 * 4)"))),
                    ("!2+", Ok(Some("! (2 +)"))),
                ]),
            (   // 632: e -> e "*" e | <R> e "+" |     "!" e | Num
                Box::new(Tester::<rules_632_1::Wrapper<_>>::new()),
                vec![
                    ("2 * 3 * 4", Ok(Some("(2 * 3) * 4"))),
                    ("2++", Ok(Some("(2 +) +"))),
                    ("!!2", Ok(Some("! (! 2)"))),
                    ("2 * 3+", Ok(Some("(2 * 3) +"))),
                    ("2+ * 4", Ok(Some("(2 +) * 4"))),
                    ("2 * !3", Ok(Some("2 * (! 3)"))),
                    ("!2 * 4", Ok(Some("! (2 * 4)"))),
                    ("!2+", Ok(Some("! (2 +)"))),
                ]),
        ];
        const VERBOSE: bool = false;

        for (test_id, (mut tester, tests)) in listeners.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\nTest {test_id}", ""); }
            for (input, expected) in tests {
                if VERBOSE { println!("input: {input}"); }
                let (result, log) = match tester.parse(input) {
                    Ok((output, log)) => {
                        if VERBOSE { println!("-> output: {output:?}"); }
                        (Ok(output), log)
                    }
                    Err((error, log)) => {
                        if VERBOSE { println!("-> error: {error:?}"); }
                        (Err(error), log)
                    }
                };
                if VERBOSE && !log.is_empty() { println!("Log:\n{log}"); }
                assert_eq!(result, expected.map(|s_maybe| s_maybe.map(|s| s.to_string())));
            }
        }

    }
}

// ================================================================================

#[cfg(test)]
// #[allow(unused)]
pub(crate) mod rules_640_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule 640 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_640_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> e "/" <P> e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> e "-" <P> e`
        E4 { e: [SynE; 2] },
        /// `e -> "-" e`
        E5 { e: SynE },
        /// `e -> Id`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> "*" e_4 e_1
                        2 |                                         // e_1 -> "/" e_4 e_1
                        3 |                                         // e_1 -> "+" e_2 e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> "-" e_2 e_1
                        7 => self.exit_e1(1),                       // e_3 -> "*" e_4 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> "/" e_4 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 640 #1, start e]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener2::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | E * E | <P> E / E | E + E | <P> E - E | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("((a * b) * c) * d")),
                ("a / b / c / d", Some("((a / b) / c) / d")),
                ("a + b + c + d", Some("((a + b) + c) + d")),
                ("a - b - c - d", Some("((a - b) - c) - d")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("(a + b) - c")),
                ("a - b + c", Some("(a - b) + c")),
                ("a * b / c", Some("(a * b) / c")),
                ("a / b * c", Some("(a / b) * c")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
pub(crate) mod rules_641_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule 641 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_641_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> <R> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> <R> e "/" <P> e`
        E2 { e: [SynE; 2] },
        /// `e -> <R> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> <R> e "-" <P> e`
        E4 { e: [SynE; 2] },
        /// `e -> "-" e`
        E5 { e: SynE },
        /// `e -> Id`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "*" e_2 e_1
                        2 |                                         // e_1 -> <R> "/" e_2 e_1
                        3 |                                         // e_1 -> <R> "+" e e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> <R> "-" e e_1
                        7 => self.exit_e1(1),                       // e_3 -> <R> "*" e_2 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> <R> "/" e_2 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 641 #1, start e]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener3::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | <R> E * E | <R> E / E <P> | <R> E + E | <R> E - E <P> | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("a * (b * (c * d))")),
                ("a / b / c / d", Some("a / (b / (c / d))")),
                ("a + b + c + d", Some("a + (b + (c + d))")),
                ("a - b - c - d", Some("a - (b - (c - d))")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("a + (b - c)")),
                ("a - b + c", Some("a - (b + c)")),
                ("a * b / c", Some("a * (b / c)")),
                ("a / b * c", Some("a / (b * c)")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("a + ((- b) + c)")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
pub(crate) mod rules_642_1 {
    #![allow(unused_imports)]

    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule 642 #1, start e]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_642_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `e -> <R> e "*" e`
        E1 { e: [SynE; 2] },
        /// `e -> <R> e "/" <P> e`
        E2 { e: [SynE; 2] },
        /// `e -> e "+" e`
        E3 { e: [SynE; 2] },
        /// `e -> e "-" <P> e`
        E4 { e: [SynE; 2] },
        /// `e -> "-" e`
        E5 { e: SynE },
        /// `e -> Id`
        E6 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `e`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // e
                        1 ..= 4 => {}                               // e_1, e_2, e_3, e_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // e_1 -> <R> "*" e_2 e_1
                        2 |                                         // e_1 -> <R> "/" e_2 e_1
                        3 |                                         // e_1 -> "+" e_2 e_1
                        4 => self.exit_e1(alt_id),                  // e_1 -> "-" e_2 e_1
                        7 => self.exit_e1(1),                       // e_3 -> <R> "*" e_2 e_3 (duplicate of 1)
                        8 => self.exit_e1(2),                       // e_3 -> <R> "/" e_2 e_3 (duplicate of 2)
                        10 |                                        // e_4 -> "-" e_4
                        11 => self.exit_e4(alt_id),                 // e_4 -> Id
                        0 => {}                                     // e -> e_4 e_1 (not used)
                        5 => {}                                     // e_1 -> ε (not used)
                        6 => {}                                     // e_2 -> e_4 e_3 (not used)
                        9 => {}                                     // e_3 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn exit_e1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e: [e_1, e_2] }
                }
                2 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e: [e_1, e_2] }
                }
                3 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e: [e_1, e_2] }
                }
                4 => {
                    let e_2 = self.stack.pop().unwrap().get_e();
                    let e_1 = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e: [e_1, e_2] }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e4(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                10 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E6 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_e4")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule 642 #1, start e]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)]
    pub struct SynE(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::{BufLog, LogStatus};
        use crate::integration::parser_examples::listener4::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.get_string());
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // `E -> E * E`
                    CtxE::E1 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    // `E -> E / E`
                    CtxE::E2 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("/", lsleft, lsright),
                    // `E -> E + E`
                    CtxE::E3 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("+", lsleft, lsright),
                    // `E -> E - E`
                    CtxE::E4 { e: [SynE(lsleft), SynE(lsright)] } => ls_binary_op("-", lsleft, lsright),
                    // `E -> - E`
                    CtxE::E5 { e: SynE(lsleft) } => ls_prefix_op("-", lsleft),
                    // `E -> ID`
                    CtxE::E6 { id } => LevelString(0, id),
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // E -> - E | <R> E * E | <R> E / E <P> | E + E | E - E <P> | ID
                ("- a", Some("- a")),
                ("a * b", Some("a * b")),
                ("a / b", Some("a / b")),
                ("a + b", Some("a + b")),
                ("a - b", Some("a - b")),
                ("- - - a", Some("- (- (- a))")),
                ("a * b * c * d", Some("a * (b * (c * d))")),
                ("a / b / c / d", Some("a / (b / (c / d))")),
                ("a + b + c + d", Some("((a + b) + c) + d")),
                ("a - b - c - d", Some("((a - b) - c) - d")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a + b - c", Some("(a + b) - c")),
                ("a - b + c", Some("(a - b) + c")),
                ("a * b / c", Some("a * (b / c)")),
                ("a / b * c", Some("a / (b * c)")),
                ("a + b / c", Some("a + (b / c)")),
                ("a / b + c", Some("(a / b) + c")),
                ("- a * b", Some("(- a) * b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a / / b", None),
                ("a + + b", None),
                ("a - - b", Some("a - (- b)")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(errors.is_some(), listener.result.is_none(), "listener.result of unexpected variant for input {input}: {:?}", listener.result);
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

// ================================================================================

pub(crate) mod rules_650_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 650 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_650_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A a a`
        A1 { a: [SynA; 3], a1: String },
        /// `a -> B`
        A2 { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 => self.exit_a1(),                        // a_1 -> A a a_2 a_1
                        3 => self.exit_a2(),                        // a_2 -> B
                        0 => {}                                     // a -> a_2 a_1 (not used)
                        2 => {}                                     // a_1 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a1(&mut self) {
            let a_3 = self.stack.pop().unwrap().get_a();
            let a_2 = self.stack.pop().unwrap().get_a();
            let a1 = self.stack_t.pop().unwrap();
            let a_1 = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A1 { a: [a_1, a_2, a_3], a1 });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A2 { b });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 650 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_705_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 705 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_705_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> E`
        A1 { e: String },
        /// `a -> A`
        A2 { a: String },
        /// `a -> A B C`
        A3 { a: String, b: String, c: String },
        /// `a -> A B D`
        A4 { a: String, b: String, d: String },
        /// `a -> A B`
        A5 { a: String, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // a -> E
                        3 |                                         // a_1 -> ε
                        4 |                                         // a_2 -> C
                        5 |                                         // a_2 -> D
                        6 => self.exit_a(alt_id),                   // a_2 -> ε
                     /* 0 */                                        // a -> A a_1 (never called)
                     /* 2 */                                        // a_1 -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    CtxA::A1 { e }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a, b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A4 { a, b, d }
                }
                6 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A5 { a, b }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 705 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_820_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 820 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_820_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> B`
        A1 { b: String },
        /// `a -> a A* C`
        A2 { a: SynA, star: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A*` array in `a -> a  ►► A* ◄◄  C | B`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> B a_2
                        1 => self.exit_a1(),                        // a_1 -> A a_1
                        2 => {}                                     // a_1 -> ε
                        3 => self.exit_a2(),                        // a_2 -> a_1 C a_2
                        4 => self.exitloop_a2(),                    // a_2 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { b });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(a);
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A2 { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 820 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_821_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 821 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_821_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> B`
        A1 { b: String },
        /// `a -> a A+ C`
        A2 { a: SynA, plus: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A+` array in `a -> a  ►► A+ ◄◄  C | B`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 | 3 => {}                                 // a_2, a_3
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> B a_2
                        4 |                                         // a_3 -> a_1
                        5 => self.exit_a1(),                        // a_3 -> ε
                        2 => self.exit_a2(),                        // a_2 -> a_1 C a_2
                        3 => self.exitloop_a2(),                    // a_2 -> ε
                     /* 1 */                                        // a_1 -> A a_3 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { b });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(a);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A2 { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a2(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap() else { panic!() };
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 821 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_810_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 810 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_810_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A* B a`
        A1 { star: SynA1, b: String, a: SynA },
        /// `a -> C`
        A2 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A*` array in `a ->  ►► A* ◄◄  B a | C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> a_1 B a
                        1 => self.exit_a(alt_id),                   // a -> C
                        2 => self.exit_a1(),                        // a_1 -> A a_1
                        3 => {}                                     // a_1 -> ε
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let a = self.stack.pop().unwrap().get_a();
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    CtxA::A1 { star, b, a }
                }
                1 => {
                    let c = self.stack_t.pop().unwrap();
                    CtxA::A2 { c }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(a);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule 810 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_811_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 811 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_811_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> A+ B a`
        A1 { plus: SynA1, b: String, a: SynA },
        /// `a -> C`
        A2 { c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `A+` array in `a ->  ►► A+ ◄◄  B a | C`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 => {}                                     // a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // a -> a_1 B a
                        1 => self.exit_a(alt_id),                   // a -> C
                        3 |                                         // a_2 -> a_1
                        4 => self.exit_a1(),                        // a_2 -> ε
                     /* 2 */                                        // a_1 -> A a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let a = self.stack.pop().unwrap().get_a();
                    let b = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_a1();
                    CtxA::A1 { plus, b, a }
                }
                1 => {
                    let c = self.stack_t.pop().unwrap();
                    CtxA::A2 { c }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(a);
            self.stack.push(SynValue::A1(plus_it));
        }
    }

    // [wrapper source for rule 811 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_835_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 835 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_835_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a "x" a`
        A1 { a: [SynA; 2] },
        /// `a -> a "*" "[" Num+ "]"`
        A2 { a: SynA, plus: SynA1 },
        /// `a -> "-" a`
        A3 { a: SynA },
        /// `a -> Id`
        A4 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `Num+` array in `a -> a "x" a | a "*" "["  ►► Num+ ◄◄  "]" | "-" a | Id`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 => self.init_a1(),                        // a_1
                        2 ..= 4 => {}                               // a_2, a_3, a_4
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        7 |                                         // a_4 -> a_1
                        8 => self.exit_a1(),                        // a_4 -> ε
                        2 |                                         // a_2 -> "x" a_3 a_2
                        3 => self.exit_a2(alt_id),                  // a_2 -> "*" "[" a_1 "]" a_2
                        5 |                                         // a_3 -> "-" a
                        6 => self.exit_a3(alt_id),                  // a_3 -> Id
                        0 => {}                                     // a -> a_3 a_2 (not used)
                     /* 1 */                                        // a_1 -> Num a_4 (never called)
                        4 => {}                                     // a_2 -> ε (not used)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let num = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(num);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                2 => {
                    let a_2 = self.stack.pop().unwrap().get_a();
                    let a_1 = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a: [a_1, a_2] }
                }
                3 => {
                    let plus = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, plus }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a3(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                6 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxA::A4 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a3")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule 835 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_862_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 862 #1, start expr]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_862_1::*;

    #[derive(Debug)]
    pub enum CtxExpr {
        /// `expr -> <L> Num "^" expr`
        Expr1 { expr: SynExpr, num: String },
        /// `expr -> Num`
        Expr2 { expr: SynExpr, num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `expr`
    // #[derive(Debug, PartialEq)] pub struct SynExpr();

    #[derive(Debug)]
    enum SynValue { Expr(SynExpr) }

    impl SynValue {
        fn get_expr(self) -> SynExpr {
            let SynValue::Expr(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _expr: SynExpr) {}
        fn init_expr(&mut self) -> SynExpr;
        fn exit_expr(&mut self, _ctx: CtxExpr) -> SynExpr;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_expr(),                      // expr
                        1 => {}                                     // expr_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        1 |                                         // expr_1 -> "^" expr
                        2 => self.exit_expr(alt_id),                // expr_1 -> ε
                     /* 0 */                                        // expr -> <L> Num expr_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let expr = self.stack.pop().unwrap().get_expr();
            self.listener.exit(expr);
        }

        fn init_expr(&mut self) {
            let val = self.listener.init_expr();
            self.stack.push(SynValue::Expr(val));
        }

        fn exit_expr(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr1 { expr, num }
                }
                2 => {
                    let num = self.stack_t.pop().unwrap();
                    let expr = self.stack.pop().unwrap().get_expr();
                    CtxExpr::Expr2 { expr, num }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_expr")
            };
            let val = self.listener.exit_expr(ctx);
            self.stack.push(SynValue::Expr(val));
        }
    }

    // [wrapper source for rule 862 #1, start expr]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram_lib::dfa::TokenId;
        use lexigram_lib::grammar::Symbol;
        use lexigram_lib::lexer::CaretCol;
        use lexigram_lib::log::BufLog;
        use crate::integration::parser_examples::listener5::build_parser;
        use super::*;

        struct ExprListener {
            log: BufLog,
            result: Option<String>,
        }

        impl ExprListener {
            fn new() -> Self {
                ExprListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for ExprListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, expr: SynExpr) {
                let SynExpr(mut result) = expr;
                while result.len() > 1 {
                    let r = result.pop().unwrap();
                    let l = result.pop().unwrap();
                    result.push(if result.len() > 0 { format!("({l} ^ {r})") } else { format!("{l} ^ {r}") });
                }
                self.result = result.pop();
            }

            fn init_expr(&mut self) -> SynExpr {
                self.result = None;
                SynExpr(vec![])
            }

            fn exit_expr(&mut self, ctx: CtxExpr) -> SynExpr {
                let (mut e, num) = match ctx {
                    // expr -> <L> Num "^" expr
                    CtxExpr::Expr1 { expr: SynExpr(e), num } => (e, num),
                    // expr -> Num
                    CtxExpr::Expr2 { expr: SynExpr(e), num } => (e, num),
                };
                e.push(num);
                SynExpr(e)
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // expr -> <L=expr> Num "^" expr | Num
                ("1", Some("1")),
                ("1 ^ 2", Some("1 ^ 2")),
                ("1 ^ 2 ^ 3", Some("1 ^ (2 ^ 3)")),
                ("1 ^ 2 ^ 3 ^ 4", Some("1 ^ (2 ^ (3 ^ 4))")),
                ("", None),
                ("^ 1", None),
                ("1 ^", None),
                ("1 ^ ^", None),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let num_id = 0;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            println!("symbols = {symbols:?}");
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            (num_id, w.to_string(), 1, i)
                        } else {
                            panic!("'{w}' input not recognized")
                        }
                    }
                });
                let listener = ExprListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let result = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        wrapper.listener.result.take()
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        None
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.to_string();
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let expected_result = expected_result.map(|s| s.to_string());
                assert_eq!(result, expected_result, "test failed for input: {input}");
            }
        }
    }
}

// ================================================================================

pub(crate) mod rules_870_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 870 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_870_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> a A`
        A1 { a: SynA, a1: String },
        /// `a -> B C`
        A2 { b: String, c: String },
        /// `a -> B D`
        A3 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        3 |                                         // a_2 -> C a_1
                        4 => self.inter_a(alt_id),                  // a_2 -> D a_1
                        1 => self.exit_a1(),                        // a_1 -> A a_1
                        2 => self.exitloop_a1(),                    // a_1 -> ε
                     /* 0 */                                        // a -> B a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A2 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, d }
                }
                _ => panic!("unexpected alt id {alt_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self) {
            let a1 = self.stack_t.pop().unwrap();
            let a = self.stack.pop().unwrap().get_a();
            let val = self.listener.exit_a(CtxA::A1 { a, a1 });
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 870 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================

pub(crate) mod rules_871_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 871 #1, start a]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_871_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `a -> D`
        A1 { d: String },
        /// `a -> a A B`
        A2 { a: SynA, a1: String, b: String },
        /// `a -> a A C`
        A3 { a: SynA, a1: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `a`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn exitloop_a(&mut self, _a: &mut SynA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // a
                        1 | 2 => {}                                 // a_1, a_2
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 => self.inter_a(),                        // a -> D a_1
                        3 |                                         // a_2 -> B a_1
                        4 => self.exit_a1(alt_id),                  // a_2 -> C a_1
                        2 => self.exitloop_a1(),                    // a_1 -> ε
                     /* 1 */                                        // a_1 -> A a_2 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                3 => {
                    let b = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, a1, b }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a, a1, c }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exitloop_a1(&mut self) {
            let SynValue::A(a) = self.stack.last_mut().unwrap();
            self.listener.exitloop_a(a);
        }
    }

    // [wrapper source for rule 871 #1, start a]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 44: rules RTS(100) #1, start 0:

pub(crate) mod rules_901_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule 901 #1, start file]

    use lexigram_lib::{CollectJoin, grammar::{AltId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_901_1::*;

    #[derive(Debug)]
    pub enum CtxFile {
        /// `file -> header file_item*`
        File1 { header: SynHeader, star: SynFile1 },
        /// `file -> file_item*`
        File2 { star: SynFile1 },
    }
    #[derive(Debug)]
    pub enum CtxFileItem {
        /// `file_item -> option`
        FileItem1 { option: SynOption },
        /// `file_item -> declaration`
        FileItem2 { declaration: SynDeclaration },
        /// `file_item -> rule`
        FileItem3 { rule: SynRule },
    }
    #[derive(Debug)]
    pub enum CtxHeader {
        /// `header -> "lexicon" Id ";"`
        Header { id: String },
    }
    #[derive(Debug)]
    pub enum CtxDeclaration {
        /// `declaration -> "mode" Id ";"`
        Declaration { id: String },
    }
    #[derive(Debug)]
    pub enum CtxOption {
        /// `option -> "channels" "{" Id ("," Id)* "}"`
        Option { id: String, star: SynOption1 },
    }
    #[derive(Debug)]
    pub enum CtxRule {
        /// `rule -> "fragment" Id ":" match ";"`
        Rule1 { id: String, match1: SynMatch },
        /// `rule -> Id ":" match "->" actions ";"`
        Rule2 { id: String, match1: SynMatch, actions: SynActions },
        /// `rule -> Id ":" match ";"`
        Rule3 { id: String, match1: SynMatch },
    }
    #[derive(Debug)]
    pub enum CtxActions {
        /// `actions -> action ("," action)*`
        Actions { action: SynAction, star: SynActions1 },
    }
    #[derive(Debug)]
    pub enum CtxAction {
        /// `action -> "mode" "(" Id ")"`
        Action1 { id: String },
        /// `action -> "push" "(" Id ")"`
        Action2 { id: String },
        /// `action -> "pop"`
        Action3,
        /// `action -> "skip"`
        Action4,
        /// `action -> "more"`
        Action5,
        /// `action -> "type" "(" Id ")"`
        Action6 { id: String },
        /// `action -> "channel" "(" Id ")"`
        Action7 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxMatch {
        /// `match -> alt_items`
        Match { alt_items: SynAltItems },
    }
    #[derive(Debug)]
    pub enum CtxAltItems {
        /// `alt_items -> alt_item ("|" alt_item)*`
        AltItems { alt_item: SynAltItem, star: SynAltItems1 },
    }
    #[derive(Debug)]
    pub enum CtxAltItem {
        /// `alt_item -> repeat_item+`
        AltItem { plus: SynAltItem1 },
    }
    #[derive(Debug)]
    pub enum CtxRepeatItem {
        /// `repeat_item -> item "?"`
        RepeatItem1 { item: SynItem },
        /// `repeat_item -> item`
        RepeatItem2 { item: SynItem },
        /// `repeat_item -> item "+" "?"`
        RepeatItem3 { item: SynItem },
        /// `repeat_item -> item "+"`
        RepeatItem4 { item: SynItem },
        /// `repeat_item -> item "*" "?"`
        RepeatItem5 { item: SynItem },
        /// `repeat_item -> item "*"`
        RepeatItem6 { item: SynItem },
    }
    #[derive(Debug)]
    pub enum CtxItem {
        /// `item -> "(" alt_items ")"`
        Item1 { alt_items: SynAltItems },
        /// `item -> "~" item`
        Item2 { item: SynItem },
        /// `item -> Id`
        Item3 { id: String },
        /// `item -> StrLit`
        Item4 { strlit: String },
        /// `item -> char_set`
        Item5 { char_set: SynCharSet },
        /// `item -> CharLit ".." CharLit`
        Item6 { charlit: [String; 2] },
        /// `item -> CharLit`
        Item7 { charlit: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSet {
        /// `char_set -> "[" char_set_one+ "]"`
        CharSet1 { plus: SynCharSet1 },
        /// `char_set -> "."`
        CharSet2,
        /// `char_set -> FixedSet`
        CharSet3 { fixedset: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSetOne {
        /// `char_set_one -> FixedSet`
        CharSetOne1 { fixedset: String },
        /// `char_set_one -> SetChar "-" SetChar`
        CharSetOne2 { setchar: [String; 2] },
        /// `char_set_one -> SetChar`
        CharSetOne3 { setchar: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `file`
    // #[derive(Debug, PartialEq)] pub struct SynFile();
    // /// User-defined type for `file_item`
    // #[derive(Debug, PartialEq)] pub struct SynFileItem();
    // /// User-defined type for `header`
    // #[derive(Debug, PartialEq)] pub struct SynHeader();
    // /// User-defined type for `declaration`
    // #[derive(Debug, PartialEq)] pub struct SynDeclaration();
    // /// User-defined type for `option`
    // #[derive(Debug, PartialEq)] pub struct SynOption();
    // /// User-defined type for `rule`
    // #[derive(Debug, PartialEq)] pub struct SynRule();
    // /// User-defined type for `actions`
    // #[derive(Debug, PartialEq)] pub struct SynActions();
    // /// User-defined type for `action`
    // #[derive(Debug, PartialEq)] pub struct SynAction();
    // /// User-defined type for `match`
    // #[derive(Debug, PartialEq)] pub struct SynMatch();
    // /// User-defined type for `alt_items`
    // #[derive(Debug, PartialEq)] pub struct SynAltItems();
    // /// User-defined type for `alt_item`
    // #[derive(Debug, PartialEq)] pub struct SynAltItem();
    // /// User-defined type for `repeat_item`
    // #[derive(Debug, PartialEq)] pub struct SynRepeatItem();
    // /// User-defined type for `item`
    // #[derive(Debug, PartialEq)] pub struct SynItem();
    // /// User-defined type for `char_set`
    // #[derive(Debug, PartialEq)] pub struct SynCharSet();
    // /// User-defined type for `char_set_one`
    // #[derive(Debug, PartialEq)] pub struct SynCharSetOne();
    /// Computed `file_item*` array in `file -> header  ►► file_item* ◄◄  |  ►► file_item* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynFile1(pub Vec<SynFileItem>);
    /// Computed `("," Id)*` array in `option -> "channels" "{" Id  ►► ("," Id)* ◄◄  "}"`
    #[derive(Debug, PartialEq)]
    pub struct SynOption1(pub Vec<String>);
    /// Computed `("," action)*` array in `actions -> action  ►► ("," action)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynActions1(pub Vec<SynAction>);
    /// Computed `("|" alt_item)*` array in `alt_items -> alt_item  ►► ("|" alt_item)* ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItems1(pub Vec<SynAltItem>);
    /// Computed `repeat_item+` array in `alt_item ->  ►► repeat_item+ ◄◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItem1(pub Vec<SynRepeatItem>);
    /// Computed `char_set_one+` array in `char_set -> "["  ►► char_set_one+ ◄◄  "]" | "." | FixedSet`
    #[derive(Debug, PartialEq)]
    pub struct SynCharSet1(pub Vec<SynCharSetOne>);

    #[derive(Debug)]
    enum SynValue { File(SynFile), FileItem(SynFileItem), Header(SynHeader), Declaration(SynDeclaration), Option(SynOption), Rule(SynRule), Actions(SynActions), Action(SynAction), Match(SynMatch), AltItems(SynAltItems), AltItem(SynAltItem), RepeatItem(SynRepeatItem), Item(SynItem), CharSet(SynCharSet), CharSetOne(SynCharSetOne), File1(SynFile1), Option1(SynOption1), Actions1(SynActions1), AltItems1(SynAltItems1), AltItem1(SynAltItem1), CharSet1(SynCharSet1) }

    impl SynValue {
        fn get_file(self) -> SynFile {
            if let SynValue::File(val) = self { val } else { panic!() }
        }
        fn get_file_item(self) -> SynFileItem {
            if let SynValue::FileItem(val) = self { val } else { panic!() }
        }
        fn get_header(self) -> SynHeader {
            if let SynValue::Header(val) = self { val } else { panic!() }
        }
        fn get_declaration(self) -> SynDeclaration {
            if let SynValue::Declaration(val) = self { val } else { panic!() }
        }
        fn get_option(self) -> SynOption {
            if let SynValue::Option(val) = self { val } else { panic!() }
        }
        fn get_rule(self) -> SynRule {
            if let SynValue::Rule(val) = self { val } else { panic!() }
        }
        fn get_actions(self) -> SynActions {
            if let SynValue::Actions(val) = self { val } else { panic!() }
        }
        fn get_action(self) -> SynAction {
            if let SynValue::Action(val) = self { val } else { panic!() }
        }
        fn get_match(self) -> SynMatch {
            if let SynValue::Match(val) = self { val } else { panic!() }
        }
        fn get_alt_items(self) -> SynAltItems {
            if let SynValue::AltItems(val) = self { val } else { panic!() }
        }
        fn get_alt_item(self) -> SynAltItem {
            if let SynValue::AltItem(val) = self { val } else { panic!() }
        }
        fn get_repeat_item(self) -> SynRepeatItem {
            if let SynValue::RepeatItem(val) = self { val } else { panic!() }
        }
        fn get_item(self) -> SynItem {
            if let SynValue::Item(val) = self { val } else { panic!() }
        }
        fn get_char_set(self) -> SynCharSet {
            if let SynValue::CharSet(val) = self { val } else { panic!() }
        }
        fn get_char_set_one(self) -> SynCharSetOne {
            if let SynValue::CharSetOne(val) = self { val } else { panic!() }
        }
        fn get_file1(self) -> SynFile1 {
            if let SynValue::File1(val) = self { val } else { panic!() }
        }
        fn get_option1(self) -> SynOption1 {
            if let SynValue::Option1(val) = self { val } else { panic!() }
        }
        fn get_actions1(self) -> SynActions1 {
            if let SynValue::Actions1(val) = self { val } else { panic!() }
        }
        fn get_alt_items1(self) -> SynAltItems1 {
            if let SynValue::AltItems1(val) = self { val } else { panic!() }
        }
        fn get_alt_item1(self) -> SynAltItem1 {
            if let SynValue::AltItem1(val) = self { val } else { panic!() }
        }
        fn get_char_set1(self) -> SynCharSet1 {
            if let SynValue::CharSet1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _file: SynFile) {}
        fn init_file(&mut self) {}
        fn exit_file(&mut self, _ctx: CtxFile) -> SynFile;
        fn init_file_item(&mut self) {}
        fn exit_file_item(&mut self, _ctx: CtxFileItem) -> SynFileItem;
        fn init_header(&mut self) {}
        fn exit_header(&mut self, _ctx: CtxHeader) -> SynHeader;
        fn init_declaration(&mut self) {}
        fn exit_declaration(&mut self, _ctx: CtxDeclaration) -> SynDeclaration;
        fn init_option(&mut self) {}
        fn exit_option(&mut self, _ctx: CtxOption) -> SynOption;
        fn init_rule(&mut self) {}
        fn exit_rule(&mut self, _ctx: CtxRule) -> SynRule;
        fn init_actions(&mut self) {}
        fn exit_actions(&mut self, _ctx: CtxActions) -> SynActions;
        fn init_action(&mut self) {}
        fn exit_action(&mut self, _ctx: CtxAction) -> SynAction;
        fn init_match(&mut self) {}
        fn exit_match(&mut self, _ctx: CtxMatch) -> SynMatch;
        fn init_alt_items(&mut self) {}
        fn exit_alt_items(&mut self, _ctx: CtxAltItems) -> SynAltItems;
        fn init_alt_item(&mut self) {}
        fn exit_alt_item(&mut self, _ctx: CtxAltItem) -> SynAltItem;
        fn init_repeat_item(&mut self) {}
        fn exit_repeat_item(&mut self, _ctx: CtxRepeatItem) -> SynRepeatItem;
        fn init_item(&mut self) {}
        fn exit_item(&mut self, _ctx: CtxItem) -> SynItem;
        fn init_char_set(&mut self) {}
        fn exit_char_set(&mut self, _ctx: CtxCharSet) -> SynCharSet;
        fn init_char_set_one(&mut self) {}
        fn exit_char_set_one(&mut self, _ctx: CtxCharSetOne) -> SynCharSetOne;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, alt_id: AltId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, alt={alt_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_file(),             // file
                        15 => self.init_file1(),                    // file_1
                        1 => self.listener.init_file_item(),        // file_item
                        2 => self.listener.init_header(),           // header
                        3 => self.listener.init_declaration(),      // declaration
                        4 => self.listener.init_option(),           // option
                        16 => self.init_option1(),                  // option_1
                        5 => self.listener.init_rule(),             // rule
                        21 => {}                                    // rule_1
                        6 => self.listener.init_actions(),          // actions
                        17 => self.init_actions1(),                 // actions_1
                        7 => self.listener.init_action(),           // action
                        8 => self.listener.init_match(),            // match
                        9 => self.listener.init_alt_items(),        // alt_items
                        18 => self.init_alt_items1(),               // alt_items_1
                        10 => self.listener.init_alt_item(),        // alt_item
                        19 => self.init_alt_item1(),                // alt_item_1
                        25 => {}                                    // alt_item_2
                        11 => self.listener.init_repeat_item(),     // repeat_item
                        22 => {}                                    // repeat_item_1
                        27 | 28 => {}                               // repeat_item_2, repeat_item_3
                        12 => self.listener.init_item(),            // item
                        23 => {}                                    // item_1
                        13 => self.listener.init_char_set(),        // char_set
                        20 => self.init_char_set1(),                // char_set_1
                        26 => {}                                    // char_set_2
                        14 => self.listener.init_char_set_one(),    // char_set_one
                        24 => {}                                    // char_set_one_1
                        _ => panic!("unexpected enter nonterminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match alt_id {
                        0 |                                         // file -> header file_1
                        1 => self.exit_file(alt_id),                // file -> file_1
                        33 => self.exit_file1(),                    // file_1 -> file_item file_1
                        34 => {}                                    // file_1 -> ε
                        2 |                                         // file_item -> option
                        3 |                                         // file_item -> declaration
                        4 => self.exit_file_item(alt_id),           // file_item -> rule
                        5 => self.exit_header(),                    // header -> "lexicon" Id ";"
                        6 => self.exit_declaration(),               // declaration -> "mode" Id ";"
                        7 => self.exit_option(),                    // option -> "channels" "{" Id option_1 "}"
                        35 => self.exit_option1(),                  // option_1 -> "," Id option_1
                        36 => {}                                    // option_1 -> ε
                        8 |                                         // rule -> "fragment" Id ":" match ";"
                        43 |                                        // rule_1 -> "->" actions ";"
                        44 => self.exit_rule(alt_id),               // rule_1 -> ";"
                     /* 9 */                                        // rule -> Id ":" match rule_1 (never called)
                        10 => self.exit_actions(),                  // actions -> action actions_1
                        37 => self.exit_actions1(),                 // actions_1 -> "," action actions_1
                        38 => {}                                    // actions_1 -> ε
                        11 |                                        // action -> "mode" "(" Id ")"
                        12 |                                        // action -> "push" "(" Id ")"
                        13 |                                        // action -> "pop"
                        14 |                                        // action -> "skip"
                        15 |                                        // action -> "more"
                        16 |                                        // action -> "type" "(" Id ")"
                        17 => self.exit_action(alt_id),             // action -> "channel" "(" Id ")"
                        18 => self.exit_match(),                    // match -> alt_items
                        19 => self.exit_alt_items(),                // alt_items -> alt_item alt_items_1
                        39 => self.exit_alt_items1(),               // alt_items_1 -> "|" alt_item alt_items_1
                        40 => {}                                    // alt_items_1 -> ε
                        20 => self.exit_alt_item(),                 // alt_item -> alt_item_1
                        53 |                                        // alt_item_2 -> alt_item_1
                        54 => self.exit_alt_item1(),                // alt_item_2 -> ε
                     /* 41 */                                       // alt_item_1 -> repeat_item alt_item_2 (never called)
                        46 |                                        // repeat_item_1 -> "?"
                        48 |                                        // repeat_item_1 -> ε
                        57 |                                        // repeat_item_2 -> "?"
                        58 |                                        // repeat_item_2 -> ε
                        59 |                                        // repeat_item_3 -> "?"
                        60 => self.exit_repeat_item(alt_id),        // repeat_item_3 -> ε
                     /* 21 */                                       // repeat_item -> item repeat_item_1 (never called)
                     /* 45 */                                       // repeat_item_1 -> "+" repeat_item_2 (never called)
                     /* 47 */                                       // repeat_item_1 -> "*" repeat_item_3 (never called)
                        22 |                                        // item -> "(" alt_items ")"
                        23 |                                        // item -> "~" item
                        24 |                                        // item -> Id
                        26 |                                        // item -> StrLit
                        27 |                                        // item -> char_set
                        49 |                                        // item_1 -> ".." CharLit
                        50 => self.exit_item(alt_id),               // item_1 -> ε
                     /* 25 */                                       // item -> CharLit item_1 (never called)
                        28 |                                        // char_set -> "[" char_set_1 "]"
                        29 |                                        // char_set -> "."
                        30 => self.exit_char_set(alt_id),           // char_set -> FixedSet
                        55 |                                        // char_set_2 -> char_set_1
                        56 => self.exit_char_set1(),                // char_set_2 -> ε
                     /* 42 */                                       // char_set_1 -> char_set_one char_set_2 (never called)
                        31 |                                        // char_set_one -> FixedSet
                        51 |                                        // char_set_one_1 -> "-" SetChar
                        52 => self.exit_char_set_one(alt_id),       // char_set_one_1 -> ε
                     /* 32 */                                       // char_set_one -> SetChar char_set_one_1 (never called)
                        _ => panic!("unexpected exit alternative id: {alt_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_listener_mut(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn give_listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let file = self.stack.pop().unwrap().get_file();
            self.listener.exit(file);
        }

        fn exit_file(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                0 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    let header = self.stack.pop().unwrap().get_header();
                    CtxFile::File1 { header, star }
                }
                1 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    CtxFile::File2 { star }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file")
            };
            let val = self.listener.exit_file(ctx);
            self.stack.push(SynValue::File(val));
        }

        fn init_file1(&mut self) {
            let val = SynFile1(Vec::new());
            self.stack.push(SynValue::File1(val));
        }

        fn exit_file1(&mut self) {
            let file_item = self.stack.pop().unwrap().get_file_item();
            let mut star_it = self.stack.pop().unwrap().get_file1();
            star_it.0.push(file_item);
            self.stack.push(SynValue::File1(star_it));
        }

        fn exit_file_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                2 => {
                    let option = self.stack.pop().unwrap().get_option();
                    CtxFileItem::FileItem1 { option }
                }
                3 => {
                    let declaration = self.stack.pop().unwrap().get_declaration();
                    CtxFileItem::FileItem2 { declaration }
                }
                4 => {
                    let rule = self.stack.pop().unwrap().get_rule();
                    CtxFileItem::FileItem3 { rule }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_file_item")
            };
            let val = self.listener.exit_file_item(ctx);
            self.stack.push(SynValue::FileItem(val));
        }

        fn exit_header(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_header(CtxHeader::Header { id });
            self.stack.push(SynValue::Header(val));
        }

        fn exit_declaration(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_declaration(CtxDeclaration::Declaration { id });
            self.stack.push(SynValue::Declaration(val));
        }

        fn exit_option(&mut self) {
            let star = self.stack.pop().unwrap().get_option1();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_option(CtxOption::Option { id, star });
            self.stack.push(SynValue::Option(val));
        }

        fn init_option1(&mut self) {
            let val = SynOption1(Vec::new());
            self.stack.push(SynValue::Option1(val));
        }

        fn exit_option1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_option1();
            star_it.0.push(id);
            self.stack.push(SynValue::Option1(star_it));
        }

        fn exit_rule(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                8 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule1 { id, match1 }
                }
                43 => {
                    let actions = self.stack.pop().unwrap().get_actions();
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule2 { id, match1, actions }
                }
                44 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule3 { id, match1 }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_rule")
            };
            let val = self.listener.exit_rule(ctx);
            self.stack.push(SynValue::Rule(val));
        }

        fn exit_actions(&mut self) {
            let star = self.stack.pop().unwrap().get_actions1();
            let action = self.stack.pop().unwrap().get_action();
            let val = self.listener.exit_actions(CtxActions::Actions { action, star });
            self.stack.push(SynValue::Actions(val));
        }

        fn init_actions1(&mut self) {
            let val = SynActions1(Vec::new());
            self.stack.push(SynValue::Actions1(val));
        }

        fn exit_actions1(&mut self) {
            let action = self.stack.pop().unwrap().get_action();
            let mut star_it = self.stack.pop().unwrap().get_actions1();
            star_it.0.push(action);
            self.stack.push(SynValue::Actions1(star_it));
        }

        fn exit_action(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action1 { id }
                }
                12 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action2 { id }
                }
                13 => {
                    CtxAction::Action3
                }
                14 => {
                    CtxAction::Action4
                }
                15 => {
                    CtxAction::Action5
                }
                16 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action6 { id }
                }
                17 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action7 { id }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_action")
            };
            let val = self.listener.exit_action(ctx);
            self.stack.push(SynValue::Action(val));
        }

        fn exit_match(&mut self) {
            let alt_items = self.stack.pop().unwrap().get_alt_items();
            let val = self.listener.exit_match(CtxMatch::Match { alt_items });
            self.stack.push(SynValue::Match(val));
        }

        fn exit_alt_items(&mut self) {
            let star = self.stack.pop().unwrap().get_alt_items1();
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let val = self.listener.exit_alt_items(CtxAltItems::AltItems { alt_item, star });
            self.stack.push(SynValue::AltItems(val));
        }

        fn init_alt_items1(&mut self) {
            let val = SynAltItems1(Vec::new());
            self.stack.push(SynValue::AltItems1(val));
        }

        fn exit_alt_items1(&mut self) {
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let mut star_it = self.stack.pop().unwrap().get_alt_items1();
            star_it.0.push(alt_item);
            self.stack.push(SynValue::AltItems1(star_it));
        }

        fn exit_alt_item(&mut self) {
            let plus = self.stack.pop().unwrap().get_alt_item1();
            let val = self.listener.exit_alt_item(CtxAltItem::AltItem { plus });
            self.stack.push(SynValue::AltItem(val));
        }

        fn init_alt_item1(&mut self) {
            let val = SynAltItem1(Vec::new());
            self.stack.push(SynValue::AltItem1(val));
        }

        fn exit_alt_item1(&mut self) {
            let repeat_item = self.stack.pop().unwrap().get_repeat_item();
            let mut plus_it = self.stack.pop().unwrap().get_alt_item1();
            plus_it.0.push(repeat_item);
            self.stack.push(SynValue::AltItem1(plus_it));
        }

        fn exit_repeat_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                46 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem1 { item }
                }
                48 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem2 { item }
                }
                57 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem3 { item }
                }
                58 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem4 { item }
                }
                59 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem5 { item }
                }
                60 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem6 { item }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_repeat_item")
            };
            let val = self.listener.exit_repeat_item(ctx);
            self.stack.push(SynValue::RepeatItem(val));
        }

        fn exit_item(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                22 => {
                    let alt_items = self.stack.pop().unwrap().get_alt_items();
                    CtxItem::Item1 { alt_items }
                }
                23 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxItem::Item2 { item }
                }
                24 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxItem::Item3 { id }
                }
                26 => {
                    let strlit = self.stack_t.pop().unwrap();
                    CtxItem::Item4 { strlit }
                }
                27 => {
                    let char_set = self.stack.pop().unwrap().get_char_set();
                    CtxItem::Item5 { char_set }
                }
                49 => {
                    let charlit_2 = self.stack_t.pop().unwrap();
                    let charlit_1 = self.stack_t.pop().unwrap();
                    CtxItem::Item6 { charlit: [charlit_1, charlit_2] }
                }
                50 => {
                    let charlit = self.stack_t.pop().unwrap();
                    CtxItem::Item7 { charlit }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_item")
            };
            let val = self.listener.exit_item(ctx);
            self.stack.push(SynValue::Item(val));
        }

        fn exit_char_set(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                28 => {
                    let plus = self.stack.pop().unwrap().get_char_set1();
                    CtxCharSet::CharSet1 { plus }
                }
                29 => {
                    CtxCharSet::CharSet2
                }
                30 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSet::CharSet3 { fixedset }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set")
            };
            let val = self.listener.exit_char_set(ctx);
            self.stack.push(SynValue::CharSet(val));
        }

        fn init_char_set1(&mut self) {
            let val = SynCharSet1(Vec::new());
            self.stack.push(SynValue::CharSet1(val));
        }

        fn exit_char_set1(&mut self) {
            let char_set_one = self.stack.pop().unwrap().get_char_set_one();
            let mut plus_it = self.stack.pop().unwrap().get_char_set1();
            plus_it.0.push(char_set_one);
            self.stack.push(SynValue::CharSet1(plus_it));
        }

        fn exit_char_set_one(&mut self, alt_id: AltId) {
            let ctx = match alt_id {
                31 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne1 { fixedset }
                }
                51 => {
                    let setchar_2 = self.stack_t.pop().unwrap();
                    let setchar_1 = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne2 { setchar: [setchar_1, setchar_2] }
                }
                52 => {
                    let setchar = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne3 { setchar }
                }
                _ => panic!("unexpected alt id {alt_id} in fn exit_char_set_one")
            };
            let val = self.listener.exit_char_set_one(ctx);
            self.stack.push(SynValue::CharSetOne(val));
        }
    }

    // [wrapper source for rule 901 #1, start file]
    // ------------------------------------------------------------
}
