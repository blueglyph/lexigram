// Copyright (c) 2025 Redglyph (@gmail.com). All Rights Reserved.

#![cfg(test)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

// The code below is generated by parsergen::tests::wrapper_source::build_items

// ================================================================================
// Test 0: rules PRS(34) #1, start 0:
/*
before, NT with value: S, VAL
after,  NT with value: S, VAL
            // NT flags:
            //  - (nothing)
            // parents:
            //  - (nothing)
            (PRS(34), 0, btreemap![
                0 => "SynS".to_string(),
                1 => "SynVal".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1],               //  0: S -> id = VAL   | ◄0 ►VAL = id!  | id VAL
                1 => symbols![],                        //  1: S -> exit       | ◄1 exit        |
                2 => symbols![nt 1],                    //  2: S -> return VAL | ◄2 ►VAL return | VAL
                3 => symbols![t 0],                     //  3: VAL -> id       | ◄3 id!         | id
                4 => symbols![t 1],                     //  4: VAL -> num      | ◄4 num!        | num
            ], Set(symbols![nt 0, nt 1, t 0, t 1]), btreemap![0 => vec![0, 1, 2], 1 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_34_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(34) #1, start S]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_34_1::*;

    #[derive(Debug)]
    pub enum CtxS {
        /// `S -> id = VAL`
        S1 { id: String, val: SynVal },
        /// `S -> exit`
        S2,
        /// `S -> return VAL`
        S3 { val: SynVal },
    }
    #[derive(Debug)]
    pub enum CtxVal {
        /// `VAL -> id`
        Val1 { id: String },
        /// `VAL -> num`
        Val2 { num: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `S`
    // #[derive(Debug, PartialEq)] pub struct SynS();
    // /// User-defined type for `VAL`
    // #[derive(Debug, PartialEq)] pub struct SynVal();

    #[derive(Debug)]
    enum SynValue { S(SynS), Val(SynVal) }

    impl SynValue {
        fn get_s(self) -> SynS {
            if let SynValue::S(val) = self { val } else { panic!() }
        }
        fn get_val(self) -> SynVal {
            if let SynValue::Val(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _s: SynS) {}
        fn init_s(&mut self) {}
        fn exit_s(&mut self, _ctx: CtxS) -> SynS;
        fn init_val(&mut self) {}
        fn exit_val(&mut self, _ctx: CtxVal) -> SynVal;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_s(),                // S
                        1 => self.listener.init_val(),              // VAL
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // S -> id = VAL
                        1 |                                         // S -> exit
                        2 => self.exit_s(factor_id),                // S -> return VAL
                        3 |                                         // VAL -> id
                        4 => self.exit_val(factor_id),              // VAL -> num
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let s = self.stack.pop().unwrap().get_s();
            self.listener.exit(s);
        }

        fn exit_s(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let val = self.stack.pop().unwrap().get_val();
                    let id = self.stack_t.pop().unwrap();
                    CtxS::S1 { id, val }
                }
                1 => {
                    CtxS::S2
                }
                2 => {
                    let val = self.stack.pop().unwrap().get_val();
                    CtxS::S3 { val }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_s")
            };
            let val = self.listener.exit_s(ctx);
            self.stack.push(SynValue::S(val));
        }

        fn exit_val(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxVal::Val1 { id }
                }
                4 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxVal::Val2 { num }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_val")
            };
            let val = self.listener.exit_val(ctx);
            self.stack.push(SynValue::Val(val));
        }
    }

    // [wrapper source for rule PRS(34) #1, start S]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 1: rules RTS(21) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(21), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![nt 1, t 1],               //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | A_1 b
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_21_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(21) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_21_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]* c`
        A { a: String, star: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[b]*` array in `A -> a  ► [b]* ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]* c
                        1 => self.exit_a1(),                        // [b]* item in A -> a  ► [b]* ◄  c
                        2 => {}                                     // end of [b]* items in A -> a  ► [b]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule RTS(21) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 2: rules RTS(21) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(21), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a c
                1 => symbols![],                        //  1: A_1 -> b A_1 | ●A_1 ◄1 b     |
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_21_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(21) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_21_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]* c`
        A { a: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]* c
                        1 |                                         // [b]* item in A -> a  ► [b]* ◄  c
                        2 => {}                                     // end of [b]* items in A -> a  ► [b]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(21) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 3: rules RTS(22) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b!    | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_22_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter, b: String },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynAIter();

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 4: rules RTS(22) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a c
                1 => symbols![],                        //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     |
                2 => symbols![],                        //  2: AIter1 -> ε        | ◄2               |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_22_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1,
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) {}
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.listener.init_aiter1(),           // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    CtxAiter1::Aiter1_1
                }
                2 => {
                    CtxAiter1::Aiter1_2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            self.listener.exit_aiter1(ctx);
        }
    }

    // [wrapper source for rule RTS(22) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 5: rules RTS(22) #3, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1],                    //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     | AIter1
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], Set(symbols![nt 0, nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #3, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_22_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynAIter();

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 6: rules RTS(22) #4, start 0:
/*
before, NT with value: AIter1
after,  NT with value: AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            // parents:
            //  - AIter1 -> A
            (RTS(22), 0, btreemap![
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c    | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![nt 1],                    //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b     | AIter1
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
            ], Set(symbols![nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_22_4 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(22) #4, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_22_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)* c`
        A { a: String, star: SynAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_1 { star_it: SynAIter },
        /// end of `(b <L>)*` iterations in `A -> a  ► (b <L>)* ◄  c`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `(b <L>)*` iteration in `A -> a  ► (b <L>)* ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynAIter();
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { Aiter1(SynAIter) }

    impl SynValue {
        fn get_aiter1(self) -> SynAIter {
            let SynValue::Aiter1(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a  ► (b <L>)* ◄  c
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a  ► (b <L>)* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, star, c });
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(22) #4, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 7: rules RTS(32) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_left_fact | parent_+_or_* (2080)
            //  - AIter1: child_+_or_* | L-form (129)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> A
            (RTS(32), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAIter".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1         | ►A_1 a!          |
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1 | ●AIter1 ◄1 b!    | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε        | ◄2               | AIter1
                3 => symbols![t 0, t 0, nt 1, t 2],     //  3: A_1 -> a AIter1 c  | ◄3 c! ►AIter1 a! | a a AIter1 c
                4 => symbols![t 0, t 2, nt 1, t 2],     //  4: A_1 -> c AIter1 c  | ◄4 c! ►AIter1 c! | a c AIter1 c
            ], All, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_rts_32_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(32) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_32_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a a (b <L>)* c`
        A1 { a: [String; 2], star: SynAIter, c: String },
        /// `A -> a c (b <L>)* c`
        A2 { a: String, c: [String; 2], star: SynAIter },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a a  ► (b <L>)* ◄  c | ...`
        Aiter1_1 { star_it: SynAIter, b: String },
        /// end of `(b <L>)*` iterations in `A -> a a  ► (b <L>)* ◄  c | ...`
        Aiter1_2 { star_it: SynAIter },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `(b <L>)*` iteration in `A -> a a  ► (b <L>)* ◄  c | a c  ► (b <L>)* ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynAIter();

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAIter) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> a a (b <L>)* c
                        4 => self.exit_a(factor_id),                // A -> a c (b <L>)* c
                        1 |                                         // (b <L>)* iteration in A -> a a  ► (b <L>)* ◄  c | ...
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a a  ► (b <L>)* ◄  c | ...
                     /* 0 */                                        // A -> a a (b <L>)* c | a c (b <L>)* c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter1();
                    let a_2 = self.stack_t.pop().unwrap();
                    let a_1 = self.stack_t.pop().unwrap();
                    CtxA::A1 { a: [a_1, a_2], star, c }
                }
                4 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter1();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2], star }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(32) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 8: rules RTS(25) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(25), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a c
                1 => symbols![],                        //  1: A_1 -> # A_1 | ●A_1 ◄1 #     |
                2 => symbols![],                        //  2: A_1 -> ε     | ◄2            |
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_25_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(25) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_25_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [#]* c`
        A { a: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [#]* c
                        1 |                                         // [#]* item in A -> a  ► [#]* ◄  c
                        2 => {}                                     // end of [#]* items in A -> a  ► [#]* ◄  c
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(25) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 9: rules RTS(23) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(23), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![],                        //  1: A_1 -> b A_2 | ►A_2 b!       |
                2 => symbols![nt 1, t 1],               //  2: A_2 -> A_1   | ●A_1 ◄2       | A_1 b
                3 => symbols![nt 1, t 1],               //  3: A_2 -> ε     | ◄3            | A_1 b
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_23_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(23) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_23_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [b]+ c`
        A { a: String, plus: SynA1, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[b]+` array in `A -> a  ► [b]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [b]+ c
                        2 |                                         // [b]+ item in A -> a  ► [b]+ ◄  c
                        3 => self.exit_a1(),                        // end of [b]+ items in A -> a  ► [b]+ ◄  c
                     /* 1 */                                        // [b]+ item in A -> a  ► [b]+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }
    }

    // [wrapper source for rule RTS(23) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 10: rules RTS(27) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(27), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 2],          //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                1 => symbols![t 1],                     //  1: B -> b       | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B A_2 | ►A_2 ►B       |
                3 => symbols![nt 2, nt 1],              //  3: A_2 -> A_1   | ●A_1 ◄3       | A_1 B
                4 => symbols![nt 2, nt 1],              //  4: A_2 -> ε     | ◄4            | A_1 B
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_27_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(27) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_27_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [B]+ c`
        A { a: String, plus: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `[B]+` array in `A -> a  ► [B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynB>);

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => {}                                     // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [B]+ c
                        3 |                                         // [B]+ item in A -> a  ► [B]+ ◄  c
                        4 => self.exit_a1(),                        // end of [B]+ items in A -> a  ► [B]+ ◄  c
                     /* 2 */                                        // [B]+ item in A -> a  ► [B]+ ◄  c (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(27) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 11: rules RTS(28) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (RTS(28), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, t 2],               //  0: A -> A_1 c     | ◄0 c! ►A_1 | A_1 c
                1 => symbols![t 1],                     //  1: B -> b         | ◄1 b!      | b
                2 => symbols![],                        //  2: A_1 -> a B A_2 | ►A_2 ►B a! |
                3 => symbols![nt 2, t 0, nt 1],         //  3: A_2 -> A_1     | ●A_1 ◄3    | A_1 a B
                4 => symbols![nt 2, t 0, nt 1],         //  4: A_2 -> ε       | ◄4         | A_1 a B
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_28_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(28) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_28_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> [a B]+ c`
        A { plus: SynA1, c: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `[a B]+` array in `A ->  ► [a B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `a B` item in `A ->  ► [a B]+ ◄  c`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub a: String, pub b: SynB }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => {}                                     // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> [a B]+ c
                        3 |                                         // [a B]+ item in A ->  ► [a B]+ ◄  c
                        4 => self.exit_a1(),                        // end of [a B]+ items in A ->  ► [a B]+ ◄  c
                     /* 2 */                                        // [a B]+ item in A ->  ► [a B]+ ◄  c (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let val = self.listener.exit_a(CtxA::A { plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack.pop().unwrap().get_b();
            let a = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(SynA1Item { a, b });
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(28) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 12: rules RTS(24) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b!          |
                2 => symbols![nt 1, t 1],               //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1 b
                3 => symbols![nt 1, t 1],               //  3: A_1 -> ε        | ◄3               | AIter1 b
            ], All, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_24_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, b: String, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynMyAIter();

    #[derive(Debug)]
    enum SynValue { A(SynMyA), Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynMyAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let b = self.stack_t.pop().unwrap();
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, b, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 13: rules RTS(24) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
            ], btreemap![
                0 => symbols![t 0, t 2],                //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![],                        //  2: A_1 -> AIter1   | ●AIter1 ◄2       |
                3 => symbols![],                        //  3: A_1 -> ε        | ◄3               |
            ], Set(symbols![nt 0, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_24_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();

    #[derive(Debug)]
    enum SynValue { A(SynMyA) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) {}
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.listener.init_aiter1(),           // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, c });
            self.stack.push(SynValue::A(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            self.listener.exit_aiter1(CtxAiter1::Aiter1 { last_iteration });
        }
    }

    // [wrapper source for rule RTS(24) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 14: rules RTS(24) #3, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![nt 1],                    //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1
                3 => symbols![nt 1],                    //  3: A_1 -> ε        | ◄3               | AIter1
            ], Set(symbols![nt 0, nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #3, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_24_3::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynMyAIter();

    #[derive(Debug)]
    enum SynValue { A(SynMyA), Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynMyAIter {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 15: rules RTS(24) #4, start 0:
/*
before, NT with value: AIter1
after,  NT with value: AIter1
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - AIter1: child_+_or_* | parent_left_fact | L-form | plus (4257)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - AIter1 -> A
            //  - A_1 -> AIter1
            (RTS(24), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynMyAIter".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 1, t 2],          //  0: A -> a AIter1 c | ◄0 c! ►AIter1 a! | a AIter1 c
                1 => symbols![],                        //  1: AIter1 -> b A_1 | ►A_1 b           |
                2 => symbols![nt 1],                    //  2: A_1 -> AIter1   | ●AIter1 ◄2       | AIter1
                3 => symbols![nt 1],                    //  3: A_1 -> ε        | ◄3               | AIter1
            ], Set(symbols![nt 1, t 0, t 2]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_24_4 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(24) #4, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_24_4::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a (b <L>)+ c`
        A { a: String, plus: SynMyAIter, c: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
        Aiter1 { plus_it: SynMyAIter, last_iteration: bool },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `(b <L>)+` iteration in `A -> a  ► (b <L>)+ ◄  c`
    // #[derive(Debug, PartialEq)] pub struct SynMyAIter();
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { Aiter1(SynMyAIter) }

    impl SynValue {
        fn get_aiter1(self) -> SynMyAIter {
            let SynValue::Aiter1(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_aiter1(&mut self) -> SynMyAIter;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynMyAIter;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a (b <L>)+ c
                        2 |                                         // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c
                        3 => self.exit_aiter1(factor_id),           // end of (b <L>)+ iterations in A -> a  ► (b <L>)+ ◄  c
                     /* 1 */                                        // (b <L>)+ iteration in A -> a  ► (b <L>)+ ◄  c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, c });
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let last_iteration = factor_id == 3;
            let plus_it = self.stack.pop().unwrap().get_aiter1();
            let val = self.listener.exit_aiter1(CtxAiter1::Aiter1 { plus_it, last_iteration });
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(24) #4, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 16: rules RTS(29) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!           | b
                2 => symbols![nt 2, nt 1, t 1],         //  2: A_1 -> B b A_1   | ●A_1 ◄2 b! ►B   | A_1 B b
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, nt 2, t 2],         //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 A_1 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_29_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `[B b]*` array in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B b` item in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: SynB, pub b1: String }
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `[B b]* c` item in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub star: SynA1, pub c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 => self.exit_a1(),                        // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b1 = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { b, b1 });
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { star, c });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(29) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 17: rules RTS(29) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                0 => "SynA".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![],                        //  1: B -> b           | ◄1 b            |
                2 => symbols![],                        //  2: A_1 -> B b A_1   | ●A_1 ◄2 b ►B    |
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, t 2],               //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], Set(symbols![nt 0, t 0, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_29_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => {}                                     // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 |                                         // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(c);
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            self.listener.exit_b(CtxB::B);
        }
    }

    // [wrapper source for rule RTS(29) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 18: rules RTS(29) #3, start 0:
/*
before, NT with value:
after,  NT with value: A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            (RTS(29), 0, btreemap![
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a!   | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!           | b
                2 => symbols![nt 2, t 1],               //  2: A_1 -> B b A_1   | ●A_1 ◄2 b! ►B   | A_1 b
                3 => symbols![],                        //  3: A_1 -> ε         | ◄3              |
                4 => symbols![nt 3, nt 2, t 2],         //  4: A_2 -> A_1 c A_2 | ●A_2 ◄4 c! ►A_1 | A_2 A_1 c
                5 => symbols![],                        //  5: A_2 -> ε         | ◄5              |
            ], Set(symbols![t 0, t 1, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_29_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(29) #3, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]* c]* d`
        A { a: String, star: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Computed `[B b]*` array in `A -> a [ ► [B b]* ◄  c]* d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);
    /// Computed `[[B b]* c]*` array in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `[B b]* c` item in `A -> a  ► [[B b]* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub star: SynA1, pub c: String }
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]* c]* d
                        2 => self.exit_a1(),                        // [B b]* item in A -> a [ ► [B b]* ◄  c]* d
                        3 => {}                                     // end of [B b]* items in A -> a [ ► [B b]* ◄  c]* d
                        4 => self.exit_a2(),                        // [[B b]* c]* item in A -> a  ► [[B b]* c]* ◄  d
                        5 => {}                                     // end of [[B b]* c]* items in A -> a  ► [[B b]* c]* ◄  d
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, star, d });
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(b);
            self.stack.push(SynValue::A1(star_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let mut star_it = self.stack.pop().unwrap().get_a2();
            star_it.0.push(SynA2Item { star, c });
            self.stack.push(SynValue::A2(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule RTS(29) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 19: rules RTS(39) #1, start 0:
/*
before, NT with value: A, AIter2, AIter1
after,  NT with value: A, AIter2, AIter1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter2: child_+_or_* | L-form (129)
            //  - AIter1: child_+_or_* | L-form | parent_+_or_* (2177)
            // parents:
            //  - AIter2 -> AIter1
            //  - AIter1 -> A
            (RTS(39), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAiter2".to_string(),
                2 => "SynAiter1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 3],          //  0: A -> a AIter1 d           | ◄0 d! ►AIter1 a!      | a AIter1 d
                1 => symbols![nt 1, t 1],               //  1: AIter2 -> b AIter2        | ●AIter2 ◄1 b!         | AIter2 b
                2 => symbols![nt 1],                    //  2: AIter2 -> ε               | ◄2                    | AIter2
                3 => symbols![nt 2, nt 1, t 2],         //  3: AIter1 -> AIter2 c AIter1 | ●AIter1 ◄3 c! ►AIter2 | AIter1 AIter2 c
                4 => symbols![nt 2],                    //  4: AIter1 -> ε               | ◄4                    | AIter1
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_39_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(39) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_39_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a ((b <L>)* c <L>)* d`
        A { a: String, star: SynAiter1, d: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter2 {
        /// `(b <L>)*` iteration in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
        Aiter2_1 { star_it: SynAiter2, b: String },
        /// end of `(b <L>)*` iterations in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
        Aiter2_2 { star_it: SynAiter2 },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `((b <L>)* c <L>)*` iteration in `A -> a  ► ((b <L>)* c <L>)* ◄  d`
        Aiter1_1 { star_it: SynAiter1, star: SynAiter2, c: String },
        /// end of `((b <L>)* c <L>)*` iterations in `A -> a  ► ((b <L>)* c <L>)* ◄  d`
        Aiter1_2 { star_it: SynAiter1 },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `(b <L>)*` iteration in `A -> a ( ► (b <L>)* ◄  c <L>)* d`
    // #[derive(Debug, PartialEq)] pub struct SynAiter2();
    // /// User-defined type for `((b <L>)* c <L>)*` iteration in `A -> a  ► ((b <L>)* c <L>)* ◄  d`
    // #[derive(Debug, PartialEq)] pub struct SynAiter1();

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter2(SynAiter2), Aiter1(SynAiter1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter2(self) -> SynAiter2 {
            if let SynValue::Aiter2(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAiter1 {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter2(&mut self) -> SynAiter2;
        fn exit_aiter2(&mut self, _ctx: CtxAiter2) -> SynAiter2;
        fn init_aiter1(&mut self) -> SynAiter1;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAiter1;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter2(),                    // AIter2
                        2 => self.init_aiter1(),                    // AIter1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a ((b <L>)* c <L>)* d
                        1 |                                         // (b <L>)* iteration in A -> a ( ► (b <L>)* ◄  c <L>)* d
                        2 => self.exit_aiter2(factor_id),           // end of (b <L>)* iterations in A -> a ( ► (b <L>)* ◄  c <L>)* d
                        3 |                                         // ((b <L>)* c <L>)* iteration in A -> a  ► ((b <L>)* c <L>)* ◄  d
                        4 => self.exit_aiter1(factor_id),           // end of ((b <L>)* c <L>)* iterations in A -> a  ► ((b <L>)* c <L>)* ◄  d
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter2(&mut self) {
            let val = self.listener.init_aiter2();
            self.stack.push(SynValue::Aiter2(val));
        }

        fn exit_aiter2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter2();
                    CtxAiter2::Aiter2_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter2();
                    CtxAiter2::Aiter2_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter2")
            };
            let val = self.listener.exit_aiter2(ctx);
            self.stack.push(SynValue::Aiter2(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_aiter2();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, star, c }
                }
                4 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }
    }

    // [wrapper source for rule RTS(39) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 20: rules RTS(40) #1, start 0:
/*
before, NT with value: A, AIter1
after,  NT with value: A, AIter1, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - AIter1: child_+_or_* | L-form (129)
            //  - A_1: child_+_or_* | parent_+_or_* (2049)
            // parents:
            //  - AIter1 -> A_1
            //  - A_1 -> A
            (RTS(40), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynAiter1".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 2, t 3],          //  0: A -> a A_1 d        | ◄0 d! ►A_1 a!      | a A_1 d
                1 => symbols![nt 1, t 1],               //  1: AIter1 -> b AIter1  | ●AIter1 ◄1 b!      | AIter1 b
                2 => symbols![nt 1],                    //  2: AIter1 -> ε         | ◄2                 | AIter1
                3 => symbols![nt 2, nt 1, t 2],         //  3: A_1 -> AIter1 c A_1 | ●A_1 ◄3 c! ►AIter1 | A_1 AIter1 c
                4 => symbols![],                        //  4: A_1 -> ε            | ◄4                 |
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_40_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(40) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_40_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [(b <L>)* c]* d`
        A { a: String, star: SynA1, d: String },
    }
    #[derive(Debug)]
    pub enum CtxAiter1 {
        /// `(b <L>)*` iteration in `A -> a [ ► (b <L>)* ◄  c]* d`
        Aiter1_1 { star_it: SynAiter1, b: String },
        /// end of `(b <L>)*` iterations in `A -> a [ ► (b <L>)* ◄  c]* d`
        Aiter1_2 { star_it: SynAiter1 },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `(b <L>)*` iteration in `A -> a [ ► (b <L>)* ◄  c]* d`
    // #[derive(Debug, PartialEq)] pub struct SynAiter1();
    /// Computed `[(b <L>)* c]*` array in `A -> a  ► [(b <L>)* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `(b <L>)* c` item in `A -> a  ► [(b <L>)* c]* ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub star: SynAiter1, pub c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), Aiter1(SynAiter1), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_aiter1(self) -> SynAiter1 {
            if let SynValue::Aiter1(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_aiter1(&mut self) -> SynAiter1;
        fn exit_aiter1(&mut self, _ctx: CtxAiter1) -> SynAiter1;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_aiter1(),                    // AIter1
                        2 => self.init_a1(),                        // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [(b <L>)* c]* d
                        1 |                                         // (b <L>)* iteration in A -> a [ ► (b <L>)* ◄  c]* d
                        2 => self.exit_aiter1(factor_id),           // end of (b <L>)* iterations in A -> a [ ► (b <L>)* ◄  c]* d
                        3 => self.exit_a1(),                        // [(b <L>)* c]* item in A -> a  ► [(b <L>)* c]* ◄  d
                        4 => {}                                     // end of [(b <L>)* c]* items in A -> a  ► [(b <L>)* c]* ◄  d
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_a1();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, star, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_aiter1(&mut self) {
            let val = self.listener.init_aiter1();
            self.stack.push(SynValue::Aiter1(val));
        }

        fn exit_aiter1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b = self.stack_t.pop().unwrap();
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_1 { star_it, b }
                }
                2 => {
                    let star_it = self.stack.pop().unwrap().get_aiter1();
                    CtxAiter1::Aiter1_2 { star_it }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_aiter1")
            };
            let val = self.listener.exit_aiter1(ctx);
            self.stack.push(SynValue::Aiter1(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let star = self.stack.pop().unwrap().get_aiter1();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { star, c });
            self.stack.push(SynValue::A1(star_it));
        }
    }

    // [wrapper source for rule RTS(40) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 21: rules RTS(30) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_3: child_left_fact (64)
            //  - A_4: child_left_fact (64)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            //  - A_3 -> A_1
            //  - A_4 -> A_2
            (RTS(30), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a! | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B b A_3   | ►A_3 b! ►B    |
                3 => symbols![],                        //  3: A_2 -> A_1 c A_4 | ►A_4 c! ►A_1  |
                4 => symbols![nt 2, nt 1, t 1],         //  4: A_3 -> A_1       | ●A_1 ◄4       | A_1 B b
                5 => symbols![nt 2, nt 1, t 1],         //  5: A_3 -> ε         | ◄5            | A_1 B b
                6 => symbols![nt 3, nt 2, t 2],         //  6: A_4 -> A_2       | ●A_2 ◄6       | A_2 A_1 c
                7 => symbols![nt 3, nt 2, t 2],         //  7: A_4 -> ε         | ◄7            | A_2 A_1 c
            ], All, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_30_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(30) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_30_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]+ c]+ d`
        A { a: String, plus: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `[B b]+` array in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B b` item in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: SynB, pub b1: String }
    /// Computed `[[B b]+ c]+` array in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `[B b]+ c` item in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub plus: SynA1, pub c: String }

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB), A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        4 => {}                                     // A_3
                        5 => {}                                     // A_4
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]+ c]+ d
                        4 |                                         // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d
                        5 => self.exit_a1(),                        // end of [B b]+ items in A -> a [ ► [B b]+ ◄  c]+ d
                        6 |                                         // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d
                        7 => self.exit_a2(),                        // end of [[B b]+ c]+ items in A -> a  ► [[B b]+ c]+ ◄  d
                     /* 2 */                                        // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d (never called)
                     /* 3 */                                        // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b1 = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(SynA1Item { b, b1 });
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(SynA2Item { plus, c });
            self.stack.push(SynValue::A2(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(30) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 22: rules RTS(30) #2, start 0:
/*
before, NT with value:
after,  NT with value: A_1, A_2
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_3: child_left_fact (64)
            //  - A_4: child_left_fact (64)
            // parents:
            //  - A_1 -> A_2
            //  - A_2 -> A
            //  - A_3 -> A_1
            //  - A_4 -> A_2
            (RTS(30), 0, btreemap![
                2 => "SynA1".to_string(),
                3 => "SynA2".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 3],          //  0: A -> a A_2 d     | ◄0 d! ►A_2 a! | a A_2 d
                1 => symbols![t 1],                     //  1: B -> b           | ◄1 b!         | b
                2 => symbols![],                        //  2: A_1 -> B b A_3   | ►A_3 b! ►B    |
                3 => symbols![],                        //  3: A_2 -> A_1 c A_4 | ►A_4 c! ►A_1  |
                4 => symbols![nt 2, t 1],               //  4: A_3 -> A_1       | ●A_1 ◄4       | A_1 b
                5 => symbols![nt 2, t 1],               //  5: A_3 -> ε         | ◄5            | A_1 b
                6 => symbols![nt 3, nt 2, t 2],         //  6: A_4 -> A_2       | ●A_2 ◄6       | A_2 A_1 c
                7 => symbols![nt 3, nt 2, t 2],         //  7: A_4 -> ε         | ◄7            | A_2 A_1 c
            ], Set(symbols![t 0, t 1, t 2, t 3]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_rts_30_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(30) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[B b]+ c]+ d`
        A { a: String, plus: SynA2, d: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Computed `[B b]+` array in `A -> a [ ► [B b]+ ◄  c]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);
    /// Computed `[[B b]+ c]+` array in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<SynA2Item>);
    /// `[B b]+ c` item in `A -> a  ► [[B b]+ c]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2Item { pub plus: SynA1, pub c: String }
    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A1(SynA1), A2(SynA2) }

    impl SynValue {
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        3 => self.init_a2(),                        // A_2
                        4 => {}                                     // A_3
                        5 => {}                                     // A_4
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[B b]+ c]+ d
                        4 |                                         // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d
                        5 => self.exit_a1(),                        // end of [B b]+ items in A -> a [ ► [B b]+ ◄  c]+ d
                        6 |                                         // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d
                        7 => self.exit_a2(),                        // end of [[B b]+ c]+ items in A -> a  ► [[B b]+ c]+ ◄  d
                     /* 2 */                                        // [B b]+ item in A -> a [ ► [B b]+ ◄  c]+ d (never called)
                     /* 3 */                                        // [[B b]+ c]+ item in A -> a  ► [[B b]+ c]+ ◄  d (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a2();
            let a = self.stack_t.pop().unwrap();
            self.listener.exit_a(CtxA::A { a, plus, d });
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(SynA2Item { plus, c });
            self.stack.push(SynValue::A2(plus_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            self.listener.exit_b(CtxB::B { b });
        }
    }

    // [wrapper source for rule RTS(30) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 23: rules RTS(34) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1, A_2, A_3, A_4, A_5, A_6
            // NT flags:
            //  - A: parent_+_or_* | plus (6144)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_3: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_4: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_5: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_6: child_+_or_* | parent_left_fact | parent_+_or_* | plus (6177)
            //  - A_7: child_left_fact (64)
            //  - A_8: child_left_fact (64)
            //  - A_9: child_left_fact (64)
            //  - A_10: child_left_fact (64)
            //  - A_11: child_left_fact (64)
            //  - A_12: child_left_fact (64)
            // parents:
            //  - A_1 -> A_3
            //  - A_2 -> A
            //  - A_3 -> A
            //  - A_4 -> A_6
            //  - A_5 -> A
            //  - A_6 -> A
            //  - A_7 -> A_1
            //  - A_8 -> A_2
            //  - A_9 -> A_3
            //  - A_10 -> A_4
            //  - A_11 -> A_5
            //  - A_12 -> A_6
            (RTS(34), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
                2 => "SynA2".to_string(),
                3 => "SynA3".to_string(),
                4 => "SynA4".to_string(),
                5 => "SynA5".to_string(),
                6 => "SynA6".to_string(),
            ], btreemap![
                0 => symbols![t 0, nt 3, t 2, nt 6, t 3], //  0: A -> a A_3 c A_6 d  | ◄0 d! ►A_6 c! ►A_3 a! | a A_3 c A_6 d
                1 => symbols![],                          //  1: A_1 -> b A_7        | ►A_7 b!               |
                2 => symbols![],                          //  2: A_2 -> b A_8        | ►A_8 b!               |
                3 => symbols![],                          //  3: A_3 -> A_1 A_2 A_9  | ►A_9 ►A_2 ►A_1        |
                4 => symbols![],                          //  4: A_4 -> b A_10       | ►A_10 b!              |
                5 => symbols![],                          //  5: A_5 -> b A_11       | ►A_11 b!              |
                6 => symbols![],                          //  6: A_6 -> A_4 A_5 A_12 | ►A_12 ►A_5 ►A_4       |
                7 => symbols![nt 1, t 1],                 //  7: A_7 -> A_1          | ●A_1 ◄7               | A_1 b
                8 => symbols![nt 1, t 1],                 //  8: A_7 -> ε            | ◄8                    | A_1 b
                9 => symbols![nt 2, t 1],                 //  9: A_8 -> A_2          | ●A_2 ◄9               | A_2 b
                10 => symbols![nt 2, t 1],                // 10: A_8 -> ε            | ◄10                   | A_2 b
                11 => symbols![nt 3, nt 1, nt 2],         // 11: A_9 -> A_3          | ●A_3 ◄11              | A_3 A_1 A_2
                12 => symbols![nt 3, nt 1, nt 2],         // 12: A_9 -> ε            | ◄12                   | A_3 A_1 A_2
                13 => symbols![nt 4, t 1],                // 13: A_10 -> A_4         | ●A_4 ◄13              | A_4 b
                14 => symbols![nt 4, t 1],                // 14: A_10 -> ε           | ◄14                   | A_4 b
                15 => symbols![nt 5, t 1],                // 15: A_11 -> A_5         | ●A_5 ◄15              | A_5 b
                16 => symbols![nt 5, t 1],                // 16: A_11 -> ε           | ◄16                   | A_5 b
                17 => symbols![nt 6, nt 4, nt 5],         // 17: A_12 -> A_6         | ●A_6 ◄17              | A_6 A_4 A_5
                18 => symbols![nt 6, nt 4, nt 5],         // 18: A_12 -> ε           | ◄18                   | A_6 A_4 A_5
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_34_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(34) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_34_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a [[b]+ [b]+]+ c [[b]+ [b]+]+ d`
        A { a: String, plus: SynA3, c: String, plus1: SynA6, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[b]+` array in `A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);
    /// Computed `[b]+` array in `A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA2(pub Vec<String>);
    /// Computed `[[b]+ [b]+]+` array in `A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA3(pub Vec<SynA3Item>);
    /// `[b]+ [b]+` item in `A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA3Item { pub plus: SynA1, pub plus1: SynA2 }
    /// Computed `[b]+` array in `A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA4(pub Vec<String>);
    /// Computed `[b]+` array in `A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d`
    #[derive(Debug, PartialEq)]
    pub struct SynA5(pub Vec<String>);
    /// Computed `[[b]+ [b]+]+` array in `A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA6(pub Vec<SynA6Item>);
    /// `[b]+ [b]+` item in `A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d`
    #[derive(Debug, PartialEq)]
    pub struct SynA6Item { pub plus: SynA4, pub plus1: SynA5 }

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1), A2(SynA2), A3(SynA3), A4(SynA4), A5(SynA5), A6(SynA6) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
        fn get_a2(self) -> SynA2 {
            if let SynValue::A2(val) = self { val } else { panic!() }
        }
        fn get_a3(self) -> SynA3 {
            if let SynValue::A3(val) = self { val } else { panic!() }
        }
        fn get_a4(self) -> SynA4 {
            if let SynValue::A4(val) = self { val } else { panic!() }
        }
        fn get_a5(self) -> SynA5 {
            if let SynValue::A5(val) = self { val } else { panic!() }
        }
        fn get_a6(self) -> SynA6 {
            if let SynValue::A6(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => self.init_a2(),                        // A_2
                        3 => self.init_a3(),                        // A_3
                        4 => self.init_a4(),                        // A_4
                        5 => self.init_a5(),                        // A_5
                        6 => self.init_a6(),                        // A_6
                        7 => {}                                     // A_7
                        8 => {}                                     // A_8
                        9 => {}                                     // A_9
                        10 => {}                                    // A_10
                        11 => {}                                    // A_11
                        12 => {}                                    // A_12
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_a(),                         // A -> a [[b]+ [b]+]+ c [[b]+ [b]+]+ d
                        7 |                                         // [b]+ item in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d
                        8 => self.exit_a1(),                        // end of [b]+ items in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d
                        9 |                                         // [b]+ item in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d
                        10 => self.exit_a2(),                       // end of [b]+ items in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d
                        11 |                                        // [[b]+ [b]+]+ item in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d
                        12 => self.exit_a3(),                       // end of [[b]+ [b]+]+ items in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d
                        13 |                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d
                        14 => self.exit_a4(),                       // end of [b]+ items in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d
                        15 |                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d
                        16 => self.exit_a5(),                       // end of [b]+ items in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d
                        17 |                                        // [[b]+ [b]+]+ item in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d
                        18 => self.exit_a6(),                       // end of [[b]+ [b]+]+ items in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d
                     /* 1 */                                        // [b]+ item in A -> a [ ► [b]+ ◄  [b]+]+ c [[b]+ [b]+]+ d (never called)
                     /* 2 */                                        // [b]+ item in A -> a [[b]+  ► [b]+ ◄ ]+ c [[b]+ [b]+]+ d (never called)
                     /* 3 */                                        // [[b]+ [b]+]+ item in A -> a  ► [[b]+ [b]+]+ ◄  c [[b]+ [b]+]+ d (never called)
                     /* 4 */                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [ ► [b]+ ◄  [b]+]+ d (never called)
                     /* 5 */                                        // [b]+ item in A -> a [[b]+ [b]+]+ c [[b]+  ► [b]+ ◄ ]+ d (never called)
                     /* 6 */                                        // [[b]+ [b]+]+ item in A -> a [[b]+ [b]+]+ c  ► [[b]+ [b]+]+ ◄  d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let plus1 = self.stack.pop().unwrap().get_a6();
            let c = self.stack_t.pop().unwrap();
            let plus = self.stack.pop().unwrap().get_a3();
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A { a, plus, c, plus1, d });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(b);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn init_a2(&mut self) {
            let val = SynA2(Vec::new());
            self.stack.push(SynValue::A2(val));
        }

        fn exit_a2(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a2();
            plus_it.0.push(b);
            self.stack.push(SynValue::A2(plus_it));
        }

        fn init_a3(&mut self) {
            let val = SynA3(Vec::new());
            self.stack.push(SynValue::A3(val));
        }

        fn exit_a3(&mut self) {
            let plus1 = self.stack.pop().unwrap().get_a2();
            let plus = self.stack.pop().unwrap().get_a1();
            let mut plus_it = self.stack.pop().unwrap().get_a3();
            plus_it.0.push(SynA3Item { plus, plus1 });
            self.stack.push(SynValue::A3(plus_it));
        }

        fn init_a4(&mut self) {
            let val = SynA4(Vec::new());
            self.stack.push(SynValue::A4(val));
        }

        fn exit_a4(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a4();
            plus_it.0.push(b);
            self.stack.push(SynValue::A4(plus_it));
        }

        fn init_a5(&mut self) {
            let val = SynA5(Vec::new());
            self.stack.push(SynValue::A5(val));
        }

        fn exit_a5(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a5();
            plus_it.0.push(b);
            self.stack.push(SynValue::A5(plus_it));
        }

        fn init_a6(&mut self) {
            let val = SynA6(Vec::new());
            self.stack.push(SynValue::A6(val));
        }

        fn exit_a6(&mut self) {
            let plus1 = self.stack.pop().unwrap().get_a5();
            let plus = self.stack.pop().unwrap().get_a4();
            let mut plus_it = self.stack.pop().unwrap().get_a6();
            plus_it.0.push(SynA6Item { plus, plus1 });
            self.stack.push(SynValue::A6(plus_it));
        }
    }

    // [wrapper source for rule RTS(34) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 24: rules PRS(28) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact (32)
            //  - A_1: parent_left_fact | child_left_fact (96)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            (PRS(28), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1   | ►A_1 a! |
                1 => symbols![t 4],                     //  1: A -> e       | ◄1 e!   | e
                2 => symbols![],                        //  2: A_1 -> b A_2 | ►A_2 b! |
                3 => symbols![t 0],                     //  3: A_1 -> ε     | ◄3      | a
                4 => symbols![t 0, t 1, t 2],           //  4: A_2 -> c     | ◄4 c!   | a b c
                5 => symbols![t 0, t 1, t 3],           //  5: A_2 -> d     | ◄5 d!   | a b d
                6 => symbols![t 0, t 1],                //  6: A_2 -> ε     | ◄6      | a b
            ], Default, btreemap![0 => vec![1, 3, 4, 5, 6]]),
*/
pub(crate) mod rules_prs_28_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(28) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_28_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> e`
        A1 { e: String },
        /// `A -> a`
        A2 { a: String },
        /// `A -> a b c`
        A3 { a: String, b: String, c: String },
        /// `A -> a b d`
        A4 { a: String, b: String, d: String },
        /// `A -> a b`
        A5 { a: String, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        1 |                                         // A -> e
                        3 |                                         // A -> a
                        4 |                                         // A -> a b c
                        5 |                                         // A -> a b d
                        6 => self.exit_a(factor_id),                // A -> a b
                     /* 0 */                                        // A -> a | a b | a b c | a b d (never called)
                     /* 2 */                                        // A -> a b | a b c | a b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let e = self.stack_t.pop().unwrap();
                    CtxA::A1 { e }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a, b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A4 { a, b, d }
                }
                6 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A5 { a, b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(28) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 25: rules PRS(31) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(31), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!        | id
                2 => symbols![nt 0, t 1],               //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | E id
                3 => symbols![nt 0],                    //  3: E_1 -> ε        | ◄3            | E
            ], Default, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_31_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(31) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_31_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> E . id`
        E2 { e: SynE, id: String },
        /// end of iterations in E -> E . id
        E3 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `F`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_e(),                        // E -> F
                        2 |                                         // E -> E . id
                        3 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, id }
                }
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(31) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 26: rules PRS(31) #2, start 0:
/*
before, NT with value: F
after,  NT with value: F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(31), 0, btreemap![
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!        | id
                2 => symbols![t 1],                     //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | id
                3 => symbols![],                        //  3: E_1 -> ε        | ◄3            |
            ], Set(symbols![nt 1, t 1]), btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_31_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(31) #2, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_31_2::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> E . id`
        E2 { id: String },
        /// end of iterations in E -> E . id
        E3,
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `F`
    // #[derive(Debug, PartialEq)] pub struct SynF();
    /// Top non-terminal E (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynE();

    #[derive(Debug)]
    enum SynValue { F(SynF) }

    impl SynValue {
        fn get_f(self) -> SynF {
            let SynValue::F(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) {}
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_e(),                        // E -> F
                        2 |                                         // E -> E . id
                        3 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            self.listener.exit_e(CtxE::E1 { f });
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE::E2 { id }
                }
                3 => {
                    CtxE::E3
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            self.listener.exit_e(ctx);
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(31) #2, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 27: rules PRS(36) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec (4)
            // parents:
            //  - E_1 -> E
            (PRS(36), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                1 => symbols![t 2],                     //  1: E -> num E_1    | ►E_1 ◄1 num!  | num
                2 => symbols![t 1],                     //  2: F -> id         | ◄2 id!        | id
                3 => symbols![nt 0, t 1],               //  3: E_1 -> . id E_1 | ●E_1 ◄3 id! . | E id
                4 => symbols![nt 0],                    //  4: E_1 -> ε        | ◄4            | E
            ], Default, btreemap![0 => vec![0, 1], 1 => vec![2]]),
*/
pub(crate) mod rules_prs_36_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(36) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_36_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// `E -> num`
        E2 { num: String },
        /// `E -> E . id`
        E3 { e: SynE, id: String },
        /// end of iterations in E -> E . id
        E4 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `F`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // E -> F
                        1 => self.inter_e(factor_id),               // E -> num
                        3 |                                         // E -> E . id
                        4 => self.exit_e1(factor_id),               // end of iterations in E -> E . id
                        2 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let f = self.stack.pop().unwrap().get_f();
                    CtxE::E1 { f }
                }
                1 => {
                    let num = self.stack_t.pop().unwrap();
                    CtxE::E2 { num }
                }
                _ => panic!("unexpected factor id {factor_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, id }
                }
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(36) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 28: rules PRS(33) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(33), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(33) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// end of iterations in A -> A a
        A2 { a: SynA },
        /// `A -> b c`
        A3 { b: String, c: String },
        /// `A -> b d`
        A4 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> b c
                        4 => self.inter_a(factor_id),               // A -> b d
                        1 |                                         // A -> A a
                        2 => self.exit_a1(factor_id),               // end of iterations in A -> A a
                     /* 0 */                                        // A -> b c | b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A4 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                2 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(33) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 29: rules PRS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec (4)
            //  - A_2: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (PRS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![nt 0, t 0],               //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                2 => symbols![nt 0, t 1],               //  2: A_1 -> b A_1 | ●A_1 ◄2 b! | A b
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![t 1, t 2],                //  4: A_2 -> c A_1 | ►A_1 ◄4 c! | b c
                5 => symbols![t 1, t 3],                //  5: A_2 -> d A_1 | ►A_1 ◄5 d! | b d
            ], Default, btreemap![0 => vec![4, 5]]),
*/
pub(crate) mod rules_prs_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(38) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> A a`
        A1 { a: SynA, a1: String },
        /// `A -> A b`
        A2 { a: SynA, b: String },
        /// end of iterations in A -> A a | A b
        A3 { a: SynA },
        /// `A -> b c`
        A4 { b: String, c: String },
        /// `A -> b d`
        A5 { b: String, d: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        4 |                                         // A -> b c
                        5 => self.inter_a(factor_id),               // A -> b d
                        1 |                                         // A -> A a
                        2 |                                         // A -> A b
                        3 => self.exit_a1(factor_id),               // end of iterations in A -> A a | A b
                     /* 0 */                                        // A -> b c | b d (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A4 { b, c }
                }
                5 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A5 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, b }
                }
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 30: rules PRS(39) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact | parent_left_rec (544)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (PRS(39), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> b A_2   | ►A_2 b!    |
                1 => symbols![],                        //  1: A_1 -> a A_3 | ►A_3 a!    |
                2 => symbols![nt 0],                    //  2: A_1 -> ε     | ◄2         | A
                3 => symbols![t 1, t 2],                //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                4 => symbols![t 1, t 3],                //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
                5 => symbols![nt 0, t 0, t 1],          //  5: A_3 -> b A_1 | ●A_1 ◄5 b! | A a b
                6 => symbols![nt 0, t 0, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A a c
            ], Default, btreemap![0 => vec![3, 4]]),
*/
pub(crate) mod rules_prs_39_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(39) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_39_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// end of iterations in A -> A a b | A a c
        A1 { a: SynA },
        /// `A -> b c`
        A2 { b: String, c: String },
        /// `A -> b d`
        A3 { b: String, d: String },
        /// `A -> A a b`
        A4 { a: SynA, a1: String, b: String },
        /// `A -> A a c`
        A5 { a: SynA, a1: String, c: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        3 |                                         // A -> b c
                        4 => self.inter_a(factor_id),               // A -> b d
                        2 |                                         // end of iterations in A -> A a b | A a c
                        5 |                                         // A -> A a b
                        6 => self.exit_a1(factor_id),               // A -> A a c
                     /* 0 */                                        // A -> b c | b d (never called)
                     /* 1 */                                        // A -> A a b | A a c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A2 { b, c }
                }
                4 => {
                    let d = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    CtxA::A3 { b, d }
                }
                _ => panic!("unexpected factor id {factor_id} in fn inter_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a }
                }
                5 => {
                    let b = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, a1, b }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a, a1, c }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(39) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 31: rules PRS(32) #1, start 0:
/*
before, NT with value: E, F
after,  NT with value: E, F
            // NT flags:
            //  - E: parent_left_rec (512)
            //  - E_1: child_left_rec | parent_left_fact (36)
            //  - E_2: child_left_fact (64)
            // parents:
            //  - E_1 -> E
            //  - E_2 -> E_1
            (PRS(32), 0, btreemap![
                0 => "SynE".to_string(),
                1 => "SynF".to_string(),
            ], btreemap![
                0 => symbols![nt 1],                    //  0: E -> F E_1      | ►E_1 ◄0 ►F  | F
                1 => symbols![t 1],                     //  1: F -> id         | ◄1 id!      | id
                2 => symbols![],                        //  2: E_1 -> . id E_2 | ►E_2 id! .  |
                3 => symbols![nt 0],                    //  3: E_1 -> ε        | ◄3          | E
                4 => symbols![nt 0, t 1],               //  4: E_2 -> ( ) E_1  | ●E_1 ◄4 ) ( | E id
                5 => symbols![nt 0, t 1],               //  5: E_2 -> E_1      | ●E_1 ◄5     | E id
            ], Default, btreemap![0 => vec![0], 1 => vec![1]]),
*/
pub(crate) mod rules_prs_32_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(32) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_32_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> F`
        E1 { f: SynF },
        /// end of iterations in E -> E . id ( ) | E . id
        E2 { e: SynE },
        /// `E -> E . id ( )`
        E3 { e: SynE, id: String },
        /// `E -> E . id`
        E4 { e: SynE, id: String },
    }
    #[derive(Debug)]
    pub enum CtxF {
        /// `F -> id`
        F { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `F`
    // #[derive(Debug, PartialEq)] pub struct SynF();

    #[derive(Debug)]
    enum SynValue { E(SynE), F(SynF) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynF {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_f(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) -> SynF;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        2 => {}                                     // E_1
                        3 => {}                                     // E_2
                        1 => self.listener.init_f(),                // F
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_e(),                        // E -> F
                        3 |                                         // end of iterations in E -> E . id ( ) | E . id
                        4 |                                         // E -> E . id ( )
                        5 => self.exit_e1(factor_id),               // E -> E . id
                     /* 2 */                                        // E -> E . id ( ) | E . id (never called)
                        1 => self.exit_f(),                         // F -> id
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let f = self.stack.pop().unwrap().get_f();
            let val = self.listener.exit_e(CtxE::E1 { f });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e }
                }
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, id }
                }
                5 => {
                    let id = self.stack_t.pop().unwrap();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e, id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn exit_f(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_f(CtxF::F { id });
            self.stack.push(SynValue::F(val));
        }
    }

    // [wrapper source for rule PRS(32) #1, start E]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 32: rules RTS(38) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a!    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b!    |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0, t 0, t 2],          //  4: A_2 -> c A_1 | ●A_1 ◄4 c! | A a c
                5 => symbols![nt 0, t 0],               //  5: A_2 -> A_1   | ●A_1 ◄5    | A a
                6 => symbols![nt 0, t 1, t 2],          //  6: A_3 -> c A_1 | ●A_1 ◄6 c! | A b c
                7 => symbols![nt 0, t 1],               //  7: A_3 -> A_1   | ●A_1 ◄7    | A b
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_38_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2 { a: SynA },
        /// `A -> A a c`
        A3 { a: SynA, a1: String, c: String },
        /// `A -> A a`
        A4 { a: SynA, a1: String },
        /// `A -> A b c`
        A5 { a: SynA, b: String, c: String },
        /// `A -> A b`
        A6 { a: SynA, b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_a(),                        // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                4 => {
                    let c = self.stack_t.pop().unwrap();
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a, a1, c }
                }
                5 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a, a1 }
                }
                6 => {
                    let c = self.stack_t.pop().unwrap();
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a, b, c }
                }
                7 => {
                    let b = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A6 { a, b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(38) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 33: rules RTS(38) #2, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![t 3],                     //  0: A -> d A_1   | ►A_1 ◄0 d! | d
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a     |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b     |
                3 => symbols![nt 0],                    //  3: A_1 -> ε     | ◄3         | A
                4 => symbols![nt 0],                    //  4: A_2 -> c A_1 | ●A_1 ◄4 c  | A
                5 => symbols![nt 0],                    //  5: A_2 -> A_1   | ●A_1 ◄5    | A
                6 => symbols![nt 0],                    //  6: A_3 -> c A_1 | ●A_1 ◄6 c  | A
                7 => symbols![nt 0],                    //  7: A_3 -> A_1   | ●A_1 ◄7    | A
            ], Set(symbols![nt 0, t 3]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #2, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_38_2::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1 { d: String },
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2 { a: SynA },
        /// `A -> A a c`
        A3 { a: SynA },
        /// `A -> A a`
        A4 { a: SynA },
        /// `A -> A b c`
        A5 { a: SynA },
        /// `A -> A b`
        A6 { a: SynA },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_a(),                        // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let d = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { d });
            self.stack.push(SynValue::A(val));
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a }
                }
                4 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                5 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A4 { a }
                }
                6 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A5 { a }
                }
                7 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A6 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(38) #2, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 34: rules RTS(38) #3, start 0:
/*
before, NT with value:
after,  NT with value:
            // NT flags:
            //  - A: parent_left_rec (512)
            //  - A_1: child_left_rec | parent_left_fact (36)
            //  - A_2: child_left_fact (64)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A_1
            //  - A_3 -> A_1
            (RTS(38), 0, btreemap![
            ], btreemap![
                0 => symbols![],                        //  0: A -> d A_1   | ►A_1 ◄0 d |
                1 => symbols![],                        //  1: A_1 -> a A_2 | ►A_2 a    |
                2 => symbols![],                        //  2: A_1 -> b A_3 | ►A_3 b    |
                3 => symbols![],                        //  3: A_1 -> ε     | ◄3        |
                4 => symbols![],                        //  4: A_2 -> c A_1 | ●A_1 ◄4 c |
                5 => symbols![],                        //  5: A_2 -> A_1   | ●A_1 ◄5   |
                6 => symbols![],                        //  6: A_3 -> c A_1 | ●A_1 ◄6 c |
                7 => symbols![],                        //  7: A_3 -> A_1   | ●A_1 ◄7   |
            ], Set(symbols![]), btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_38_3 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(38) #3, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> d`
        A1,
        /// end of iterations in A -> A a c | A a | A b c | A b
        A2,
        /// `A -> A a c`
        A3,
        /// `A -> A a`
        A4,
        /// `A -> A b c`
        A5,
        /// `A -> A b`
        A6,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    /// Top non-terminal A (has no value)
    #[derive(Debug, PartialEq)]
    pub struct SynA();

    #[derive(Debug)]
    enum SynValue {  }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_a(),                        // A -> d
                        3 |                                         // end of iterations in A -> A a c | A a | A b c | A b
                        4 |                                         // A -> A a c
                        5 |                                         // A -> A a
                        6 |                                         // A -> A b c
                        7 => self.exit_a1(factor_id),               // A -> A b
                     /* 1 */                                        // A -> A a c | A a (never called)
                     /* 2 */                                        // A -> A b c | A b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.listener.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn inter_a(&mut self) {
            self.listener.exit_a(CtxA::A1);
        }

        fn exit_a1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    CtxA::A2
                }
                4 => {
                    CtxA::A3
                }
                5 => {
                    CtxA::A4
                }
                6 => {
                    CtxA::A5
                }
                7 => {
                    CtxA::A6
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a1")
            };
            self.listener.exit_a(ctx);
        }
    }

    // [wrapper source for rule RTS(38) #3, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 35: rules PRS(20) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec (2)
            // parents:
            //  - (nothing)
            (PRS(20), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![t 5, t 5, nt 1],          //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id LIST
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_20_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(20) #1, start STRUCT]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_20_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST`
        List1 { id: [String; 2], list: SynList },
        /// `LIST -> }`
        List2,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `STRUCT`
    // #[derive(Debug, PartialEq)] pub struct SynStruct();
    // /// User-defined type for `LIST`
    // #[derive(Debug, PartialEq)] pub struct SynList();

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _struct: SynStruct) {}
        fn init_struct(&mut self) {}
        fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct(),           // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct(),                    // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST
                        2 => self.exit_list(factor_id),             // LIST -> }
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct();
            self.listener.exit(struct1);
        }

        fn exit_struct(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let list = self.stack.pop().unwrap().get_list();
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2], list }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(20) #1, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 36: rules PRS(20) #2, start 0:
/*
before, NT with value: STRUCT
after,  NT with value: STRUCT
            // NT flags:
            //  - LIST: right_rec (2)
            // parents:
            //  - (nothing)
            (PRS(20), 0, btreemap![
                0 => "SynStruct".to_string(),
            ], btreemap![
                0 => symbols![t 5],                     //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id
                1 => symbols![t 5, t 5],                //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Set(symbols![nt 0, t 5]), btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_20_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(20) #2, start STRUCT]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_20_2::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST`
        List1 { id: [String; 2] },
        /// `LIST -> }`
        List2,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `STRUCT`
    // #[derive(Debug, PartialEq)] pub struct SynStruct();

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct) }

    impl SynValue {
        fn get_struct(self) -> SynStruct {
            let SynValue::Struct(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _struct: SynStruct) {}
        fn init_struct(&mut self) {}
        fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct(),           // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct(),                    // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST
                        2 => self.exit_list(factor_id),             // LIST -> }
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct();
            self.listener.exit(struct1);
        }

        fn exit_struct(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct(CtxStruct::Struct { id });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2] }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            self.listener.exit_list(ctx);
        }
    }

    // [wrapper source for rule PRS(20) #2, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 37: rules PRS(37) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec | parent_left_fact (34)
            //  - LIST_1: child_left_fact (64)
            // parents:
            //  - LIST_1 -> LIST
            (PRS(37), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![],                        //  1: LIST -> }                  | ◄1 }                  |
                2 => symbols![],                        //  2: LIST -> id LIST_1          | ►LIST_1 id!           |
                3 => symbols![t 5, t 5],                //  3: LIST_1 -> : id ; LIST      | ●LIST ◄3 ; id! :      | id id
                4 => symbols![t 5],                     //  4: LIST_1 -> ; LIST           | ●LIST ◄4 ;            | id
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 3, 4]]),
*/
pub(crate) mod rules_prs_37_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(37) #1, start STRUCT]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_37_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> }`
        List1,
        /// `LIST -> id : id ; LIST`
        List2 { id: [String; 2], list: SynList },
        /// `LIST -> id ; LIST`
        List3 { id: String, list: SynList },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `STRUCT`
    // #[derive(Debug, PartialEq)] pub struct SynStruct();
    // /// User-defined type for `LIST`
    // #[derive(Debug, PartialEq)] pub struct SynList();

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _struct: SynStruct) {}
        fn init_struct(&mut self) {}
        fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct(),           // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        2 => {}                                     // LIST_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct(),                    // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> }
                        3 |                                         // LIST -> id : id ; LIST
                        4 => self.exit_list(factor_id),             // LIST -> id ; LIST
                     /* 2 */                                        // LIST -> id : id ; LIST | id ; LIST (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct();
            self.listener.exit(struct1);
        }

        fn exit_struct(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    CtxList::List1
                }
                3 => {
                    let list = self.stack.pop().unwrap().get_list();
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List2 { id: [id_1, id_2], list }
                }
                4 => {
                    let list = self.stack.pop().unwrap().get_list();
                    let id = self.stack_t.pop().unwrap();
                    CtxList::List3 { id, list }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(37) #1, start STRUCT]
    // ------------------------------------------------------------
}

pub(crate) mod rules_prs_44_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(44) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_44_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> B a A`
        A1 { b: SynB, a: String, a1: SynA },
        /// `A -> B`
        A2 { b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => {}                                     // A_1
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        2 |                                         // A -> B a A
                        3 => self.exit_a(factor_id),                // A -> B
                     /* 0 */                                        // A -> B | B a A (never called)
                        1 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let a1 = self.stack.pop().unwrap().get_a();
                    let a = self.stack_t.pop().unwrap();
                    let b = self.stack.pop().unwrap().get_b();
                    CtxA::A1 { b, a, a1 }
                }
                3 => {
                    let b = self.stack.pop().unwrap().get_b();
                    CtxA::A2 { b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule PRS(44) #1, start A]
    // ------------------------------------------------------------
}

pub(crate) mod rules_prs_45_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(45) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_45_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a A`
        A1 { a: String, a1: SynA },
        /// `A -> B`
        A2 { b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // A -> a A
                        1 => self.exit_a(factor_id),                // A -> B
                        2 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let a1 = self.stack.pop().unwrap().get_a();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A1 { a, a1 }
                }
                1 => {
                    let b = self.stack.pop().unwrap().get_b();
                    CtxA::A2 { b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule PRS(45) #1, start A]
    // ------------------------------------------------------------

}

pub(crate) mod rules_prs_48_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(48) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_48_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a A <L>`
        A1 { a: SynA, a1: String },
        /// `A -> B <L>`
        A2 { a: SynA, b: SynB },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();

    #[derive(Debug)]
    enum SynValue { A(SynA), B(SynB) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) -> SynA;
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_a(),                         // A
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // A -> a A <L>
                        1 => self.exit_a(factor_id),                // A -> B <L>
                        2 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn init_a(&mut self) {
            let val = self.listener.init_a();
            self.stack.push(SynValue::A(val));
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let a1 = self.stack_t.pop().unwrap();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A1 { a, a1 }
                }
                1 => {
                    let b = self.stack.pop().unwrap().get_b();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, b }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule PRS(48) #1, start A]
    // ------------------------------------------------------------

}

// ================================================================================
// Test 38: rules PRS(30) #1, start 0:
/*
before, NT with value: STRUCT, LIST
after,  NT with value: STRUCT, LIST
            // NT flags:
            //  - LIST: right_rec | L-form (130)
            // parents:
            //  - (nothing)
            (PRS(30), 0, btreemap![
                0 => "SynStruct".to_string(),
                1 => "SynList".to_string(),
            ], btreemap![
                0 => symbols![t 5, nt 1],               //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                1 => symbols![nt 1, t 5, t 5],          //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | LIST id id
                2 => symbols![nt 1],                    //  2: LIST -> }                  | ◄2 }                  | LIST
            ], Default, btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_30_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(30) #1, start STRUCT]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_30_1::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String, list: SynList },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST <L>`
        List1 { list: SynList, id: [String; 2] },
        /// `LIST -> } <L>`
        List2 { list: SynList },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `STRUCT`
    // #[derive(Debug, PartialEq)] pub struct SynStruct();
    // /// User-defined type for `LIST`
    // #[derive(Debug, PartialEq)] pub struct SynList();

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct), List(SynList) }

    impl SynValue {
        fn get_struct(self) -> SynStruct {
            if let SynValue::Struct(val) = self { val } else { panic!() }
        }
        fn get_list(self) -> SynList {
            if let SynValue::List(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _struct: SynStruct) {}
        fn init_struct(&mut self) {}
        fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) -> SynList;
        fn exit_list(&mut self, _ctx: CtxList) -> SynList;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct(),           // STRUCT
                        1 => self.init_list(),                      // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct(),                    // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST <L>
                        2 => self.exit_list(factor_id),             // LIST -> } <L>
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct();
            self.listener.exit(struct1);
        }

        fn exit_struct(&mut self) {
            let list = self.stack.pop().unwrap().get_list();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct(CtxStruct::Struct { id, list });
            self.stack.push(SynValue::Struct(val));
        }

        fn init_list(&mut self) {
            let val = self.listener.init_list();
            self.stack.push(SynValue::List(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    let list = self.stack.pop().unwrap().get_list();
                    CtxList::List1 { list, id: [id_1, id_2] }
                }
                2 => {
                    let list = self.stack.pop().unwrap().get_list();
                    CtxList::List2 { list }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            let val = self.listener.exit_list(ctx);
            self.stack.push(SynValue::List(val));
        }
    }

    // [wrapper source for rule PRS(30) #1, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 39: rules PRS(30) #2, start 0:
/*
before, NT with value: STRUCT
after,  NT with value: STRUCT
            // NT flags:
            //  - LIST: right_rec | L-form (130)
            // parents:
            //  - (nothing)
            (PRS(30), 0, btreemap![
                0 => "SynStruct".to_string(),
            ], btreemap![
                0 => symbols![t 5],                     //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id
                1 => symbols![t 5, t 5],                //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | id id
                2 => symbols![],                        //  2: LIST -> }                  | ◄2 }                  |
            ], Set(symbols![nt 0, t 5]), btreemap![0 => vec![0], 1 => vec![1, 2]]),
*/
pub(crate) mod rules_prs_30_2 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(30) #2, start STRUCT]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_30_2::*;

    #[derive(Debug)]
    pub enum CtxStruct {
        /// `STRUCT -> struct id { LIST`
        Struct { id: String },
    }
    #[derive(Debug)]
    pub enum CtxList {
        /// `LIST -> id : id ; LIST <L>`
        List1 { id: [String; 2] },
        /// `LIST -> } <L>`
        List2,
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `STRUCT`
    // #[derive(Debug, PartialEq)] pub struct SynStruct();

    #[derive(Debug)]
    enum SynValue { Struct(SynStruct) }

    impl SynValue {
        fn get_struct(self) -> SynStruct {
            let SynValue::Struct(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _struct: SynStruct) {}
        fn init_struct(&mut self) {}
        fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
        fn init_list(&mut self) {}
        fn exit_list(&mut self, _ctx: CtxList) {}
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_struct(),           // STRUCT
                        1 => self.listener.init_list(),             // LIST
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.exit_struct(),                    // STRUCT -> struct id { LIST
                        1 |                                         // LIST -> id : id ; LIST <L>
                        2 => self.exit_list(factor_id),             // LIST -> } <L>
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let struct1 = self.stack.pop().unwrap().get_struct();
            self.listener.exit(struct1);
        }

        fn exit_struct(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_struct(CtxStruct::Struct { id });
            self.stack.push(SynValue::Struct(val));
        }

        fn exit_list(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let id_2 = self.stack_t.pop().unwrap();
                    let id_1 = self.stack_t.pop().unwrap();
                    CtxList::List1 { id: [id_1, id_2] }
                }
                2 => {
                    CtxList::List2
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_list")
            };
            self.listener.exit_list(ctx);
        }
    }

    // [wrapper source for rule PRS(30) #2, start STRUCT]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 40: rules RTS(26) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* (2560)
            //  - A_1: child_+_or_* (1)
            //  - A_2: child_left_rec (4)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            (RTS(26), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![nt 1, t 2],               //  1: A_1 -> c A_1     | ●A_1 ◄1 c!      | A_1 c
                2 => symbols![],                        //  2: A_1 -> ε         | ◄2              |
                3 => symbols![nt 0, nt 1, t 1],         //  3: A_2 -> A_1 b A_2 | ●A_2 ◄3 b! ►A_1 | A A_1 b
                4 => symbols![nt 0],                    //  4: A_2 -> ε         | ◄4              | A
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_26_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(26) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_26_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A [c]* b`
        A2 { a: SynA, star: SynA1, b: String },
        /// end of iterations in A -> A [c]* b
        A3 { a: SynA },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[c]*` array in `A -> a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_a(),                        // A -> a
                        1 => self.exit_a1(),                        // [c]* item in A -> A  ► [c]* ◄  b
                        2 => {}                                     // end of [c]* items in A -> A  ► [c]* ◄  b
                        3 |                                         // A -> A [c]* b
                        4 => self.exit_a2(factor_id),               // end of iterations in A -> A [c]* b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(c);
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_a2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, star, b }
                }
                4 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(26) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 41: rules RTS(16) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A, A_1
            // NT flags:
            //  - A: parent_left_rec | parent_+_or_* | plus (6656)
            //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - A_2: child_left_rec (4)
            //  - A_3: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            //  - A_2 -> A
            //  - A_3 -> A_1
            (RTS(16), 0, btreemap![
                0 => "SynA".to_string(),
                1 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![t 0],                     //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                1 => symbols![],                        //  1: A_1 -> c A_3     | ►A_3 c!         |
                2 => symbols![nt 0, nt 1, t 1],         //  2: A_2 -> A_1 b A_2 | ●A_2 ◄2 b! ►A_1 | A A_1 b
                3 => symbols![nt 0],                    //  3: A_2 -> ε         | ◄3              | A
                4 => symbols![nt 1, t 2],               //  4: A_3 -> A_1       | ●A_1 ◄4         | A_1 c
                5 => symbols![nt 1, t 2],               //  5: A_3 -> ε         | ◄5              | A_1 c
            ], Default, btreemap![0 => vec![0]]),
*/
pub(crate) mod rules_rts_16_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(16) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_16_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a`
        A1 { a: String },
        /// `A -> A [c]+ b`
        A2 { a: SynA, plus: SynA1, b: String },
        /// end of iterations in A -> A [c]+ b
        A3 { a: SynA },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();
    /// Computed `[c]+` array in `A -> a`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<String>);

    #[derive(Debug)]
    enum SynValue { A(SynA), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => self.init_a1(),                        // A_1
                        2 => {}                                     // A_2
                        3 => {}                                     // A_3
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_a(),                        // A -> a
                        4 |                                         // [c]+ item in A -> A  ► [c]+ ◄  b
                        5 => self.exit_a1(),                        // end of [c]+ items in A -> A  ► [c]+ ◄  b
                        2 |                                         // A -> A [c]+ b
                        3 => self.exit_a2(factor_id),               // end of iterations in A -> A [c]+ b
                     /* 1 */                                        // [c]+ item in A -> A  ► [c]+ ◄  b (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn inter_a(&mut self) {
            let a = self.stack_t.pop().unwrap();
            let val = self.listener.exit_a(CtxA::A1 { a });
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let mut plus_it = self.stack.pop().unwrap().get_a1();
            plus_it.0.push(c);
            self.stack.push(SynValue::A1(plus_it));
        }

        fn exit_a2(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let b = self.stack_t.pop().unwrap();
                    let plus = self.stack.pop().unwrap().get_a1();
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A2 { a, plus, b }
                }
                3 => {
                    let a = self.stack.pop().unwrap().get_a();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a2")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule RTS(16) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 42: rules PRS(35) #1, start 0:
/*
before, NT with value: A
after,  NT with value: A
            // NT flags:
            //  - A: parent_left_fact (32)
            //  - A_1: child_left_fact (64)
            // parents:
            //  - A_1 -> A
            (PRS(35), 0, btreemap![
                0 => "SynA".to_string(),
            ], btreemap![
                0 => symbols![],                        //  0: A -> a A_1 | ►A_1 a!  |
                1 => symbols![t 0, t 1, t 1],           //  1: A_1 -> b b | ◄1 b! b! | a b b
                2 => symbols![t 0, t 2, t 2],           //  2: A_1 -> c c | ◄2 c! c! | a c c
                3 => symbols![t 0],                     //  3: A_1 -> ε   | ◄3       | a
            ], Default, btreemap![0 => vec![1, 2, 3]]),
*/
pub(crate) mod rules_prs_35_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule PRS(35) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_35_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> a b b`
        A1 { a: String, b: [String; 2] },
        /// `A -> a c c`
        A2 { a: String, c: [String; 2] },
        /// `A -> a`
        A3 { a: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynA();

    #[derive(Debug)]
    enum SynValue { A(SynA) }

    impl SynValue {
        fn get_a(self) -> SynA {
            let SynValue::A(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynA;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        1 => {}                                     // A_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        1 |                                         // A -> a b b
                        2 |                                         // A -> a c c
                        3 => self.exit_a(factor_id),                // A -> a
                     /* 0 */                                        // A -> a | a b b | a c c (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let b_2 = self.stack_t.pop().unwrap();
                    let b_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A1 { a, b: [b_1, b_2] }
                }
                2 => {
                    let c_2 = self.stack_t.pop().unwrap();
                    let c_1 = self.stack_t.pop().unwrap();
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a, c: [c_1, c_2] }
                }
                3 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A3 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }
    }

    // [wrapper source for rule PRS(35) #1, start A]
    // ------------------------------------------------------------
}

// ================================================================================
// Test 43: rules RTS(33) #1, start 0:
/*
before, NT with value: A, B
after,  NT with value: A, B, A_1
            // NT flags:
            //  - A: parent_+_or_* (2048)
            //  - A_1: child_+_or_* (1)
            // parents:
            //  - A_1 -> A
            (RTS(33), 0, btreemap![
                0 => "SynMyA".to_string(),
                1 => "SynB".to_string(),
                2 => "SynA1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, t 1],               //  0: A -> A_1 b     | ◄0 b! ►A_1    | A_1 b
                1 => symbols![t 0],                     //  1: A -> a         | ◄1 a!         | a
                2 => symbols![t 1],                     //  2: B -> b         | ◄2 b!         | b
                3 => symbols![nt 2, nt 1, t 2],         //  3: A_1 -> B c A_1 | ●A_1 ◄3 c! ►B | A_1 B c
                4 => symbols![],                        //  4: A_1 -> ε       | ◄4            |
            ], All, btreemap![0 => vec![0, 1], 1 => vec![2]]),
*/
pub(crate) mod rules_rts_33_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(33) #1, start A]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_33_1::*;

    #[derive(Debug)]
    pub enum CtxA {
        /// `A -> [B c]* b`
        A1 { star: SynA1, b: String },
        /// `A -> a`
        A2 { a: String },
    }
    #[derive(Debug)]
    pub enum CtxB {
        /// `B -> b`
        B { b: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `A`
    // #[derive(Debug, PartialEq)] pub struct SynMyA();
    // /// User-defined type for `B`
    // #[derive(Debug, PartialEq)] pub struct SynB();
    /// Computed `[B c]*` array in `A ->  ► [B c]* ◄  b`
    #[derive(Debug, PartialEq)]
    pub struct SynA1(pub Vec<SynA1Item>);
    /// `B c` item in `A ->  ► [B c]* ◄  b`
    #[derive(Debug, PartialEq)]
    pub struct SynA1Item { pub b: SynB, pub c: String }

    #[derive(Debug)]
    enum SynValue { A(SynMyA), B(SynB), A1(SynA1) }

    impl SynValue {
        fn get_a(self) -> SynMyA {
            if let SynValue::A(val) = self { val } else { panic!() }
        }
        fn get_b(self) -> SynB {
            if let SynValue::B(val) = self { val } else { panic!() }
        }
        fn get_a1(self) -> SynA1 {
            if let SynValue::A1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _a: SynMyA) {}
        fn init_a(&mut self) {}
        fn exit_a(&mut self, _ctx: CtxA) -> SynMyA;
        fn init_b(&mut self) {}
        fn exit_b(&mut self, _ctx: CtxB) -> SynB;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_a(),                // A
                        2 => self.init_a1(),                        // A_1
                        1 => self.listener.init_b(),                // B
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // A -> [B c]* b
                        1 => self.exit_a(factor_id),                // A -> a
                        3 => self.exit_a1(),                        // [B c]* item in A ->  ► [B c]* ◄  b
                        4 => {}                                     // end of [B c]* items in A ->  ► [B c]* ◄  b
                        2 => self.exit_b(),                         // B -> b
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let a = self.stack.pop().unwrap().get_a();
            self.listener.exit(a);
        }

        fn exit_a(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let b = self.stack_t.pop().unwrap();
                    let star = self.stack.pop().unwrap().get_a1();
                    CtxA::A1 { star, b }
                }
                1 => {
                    let a = self.stack_t.pop().unwrap();
                    CtxA::A2 { a }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_a")
            };
            let val = self.listener.exit_a(ctx);
            self.stack.push(SynValue::A(val));
        }

        fn init_a1(&mut self) {
            let val = SynA1(Vec::new());
            self.stack.push(SynValue::A1(val));
        }

        fn exit_a1(&mut self) {
            let c = self.stack_t.pop().unwrap();
            let b = self.stack.pop().unwrap().get_b();
            let mut star_it = self.stack.pop().unwrap().get_a1();
            star_it.0.push(SynA1Item { b, c });
            self.stack.push(SynValue::A1(star_it));
        }

        fn exit_b(&mut self) {
            let b = self.stack_t.pop().unwrap();
            let val = self.listener.exit_b(CtxB::B { b });
            self.stack.push(SynValue::B(val));
        }
    }

    // [wrapper source for rule RTS(33) #1, start A]
    // ------------------------------------------------------------
}

pub(crate) mod level_string {
    use std::cmp::max;

    #[derive(Debug, PartialEq)]
    pub struct LevelString(pub u32, pub String);

    pub fn par(ls: LevelString) -> String {
        if ls.0 > 0 {
            format!("({})", ls.1)
        } else {
            ls.1
        }
    }

    pub fn ls_prefix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{op} {}", par(ls)))
    }

    pub fn ls_suffix_op(op: &str, ls: LevelString) -> LevelString {
        LevelString(ls.0 + 1, format!("{} {op}", par(ls)))
    }

    pub fn ls_binary_op(op: &str, lsleft: LevelString, lsright: LevelString) -> LevelString {
        LevelString(max(lsleft.0, lsright.0) + 1, format!("{} {op} {}", par(lsleft), par(lsright)))
    }


}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_58_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule PRS(58) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_58_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> -`
        E1 { e: SynE },
        /// `E -> 0`
        E2,
        /// `E -> E +`
        E3 { e: SynE },
        /// end of iterations in E -> E +
        E4 { e: SynE },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();

    #[derive(Debug)]
    enum SynValue { E(SynE) }

    impl SynValue {
        fn get_e(self) -> SynE {
            let SynValue::E(val) = self;
            val
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 => {}                                     // E_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // E -> -
                        1 => self.inter_e(factor_id),               // E -> 0
                        2 => {}                                     // E -> E + (not used)
                        3 => {}                                     // end of iterations in E -> E + (not used)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E1 { e }
                }
                1 => {
                    CtxE::E2
                }
                _ => panic!("unexpected factor id {factor_id} in fn inter_e")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }
    }

    // [wrapper source for rule PRS(58) #1, start E]
    // ------------------------------------------------------------

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram::dfa::TokenId;
        use lexigram::grammar::Symbol;
        use lexigram::lexer::CaretCol;
        use lexigram::log::BufLog;
        use crate::integration::parser_examples::listener16::build_parser;
        use crate::out::wrapper_source::level_string::{ls_prefix_op, ls_suffix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    // E -> - E
                    CtxE::E1 { e: SynE(ls) } => ls_prefix_op("-", ls),
                    // E -> 0
                    CtxE::E2 => LevelString(0, "0".to_string()),
                    // E -> E +
                    CtxE::E3 { e: SynE(ls) } => ls_suffix_op("+", ls),
                    // end of iterations in E -> E +
                    CtxE::E4 { e: SynE(ls) } => ls,
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> E + | - E | 0
                ("- - 0 + +", Some("-(-((0+)+))")),
            ];
            const VERBOSE: bool = true;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_63_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule PRS(63) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_63_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E6`
        E1 { e6: SynE6 },
        /// `E -> E ^ E5`
        E2 { e: SynE, e5: SynE5 },
        /// `E -> E * E5`
        E3 { e: SynE, e5: SynE5 },
        /// `E -> E + E3`
        E4 { e: SynE, e3: SynE3 },
        /// end of iterations in E -> E ^ E5 | E * E5 | E + E3
        E5 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxE3 {
        /// `E3 -> E6`
        E3_1 { e6: SynE6 },
        /// `E3 -> E3 ^ E5`
        E3_2 { e3: SynE3, e5: SynE5 },
        /// `E3 -> E3 * E5`
        E3_3 { e3: SynE3, e5: SynE5 },
        /// end of iterations in E3 -> E3 ^ E5 | E3 * E5
        E3_4 { e3: SynE3 },
    }
    #[derive(Debug)]
    pub enum CtxE5 {
        /// `E5 -> E6 ^ E5`
        E5_1 { e6: SynE6, e5: SynE5 },
        /// `E5 -> E6`
        E5_2 { e6: SynE6 },
    }
    #[derive(Debug)]
    pub enum CtxE6 {
        /// `E6 -> - E3`
        E6_1 { e3: SynE3 },
        /// `E6 -> ID`
        E6_2 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `E3`
    // #[derive(Debug, PartialEq)] pub struct SynE3();
    // /// User-defined type for `E5`
    // #[derive(Debug, PartialEq)] pub struct SynE5();
    // /// User-defined type for `E6`
    // #[derive(Debug, PartialEq)] pub struct SynE6();

    #[derive(Debug)]
    enum SynValue { E(SynE), E3(SynE3), E5(SynE5), E6(SynE6) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_e3(self) -> SynE3 {
            if let SynValue::E3(val) = self { val } else { panic!() }
        }
        fn get_e5(self) -> SynE5 {
            if let SynValue::E5(val) = self { val } else { panic!() }
        }
        fn get_e6(self) -> SynE6 {
            if let SynValue::E6(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_e3(&mut self) {}
        fn exit_e3(&mut self, _ctx: CtxE3) -> SynE3;
        fn init_e5(&mut self) {}
        fn exit_e5(&mut self, _ctx: CtxE5) -> SynE5;
        fn init_e6(&mut self) {}
        fn exit_e6(&mut self, _ctx: CtxE6) -> SynE6;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        4 => {}                                     // E_1
                        1 => self.listener.init_e3(),               // E3
                        5 => {}                                     // E3_1
                        2 => self.listener.init_e5(),               // E5
                        6 => {}                                     // E5_1
                        3 => self.listener.init_e6(),               // E6
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_e(),                        // E -> E6
                        5 |                                         // E -> E ^ E5
                        6 |                                         // E -> E * E5
                        7 |                                         // E -> E + E3
                        8 => self.exit_e1(factor_id),               // end of iterations in E -> E ^ E5 | E * E5 | E + E3
                        1 => self.inter_e3(),                       // E3 -> E6
                        9 |                                         // E3 -> E3 ^ E5
                        10 |                                        // E3 -> E3 * E5
                        11 => self.exit_e31(factor_id),             // end of iterations in E3 -> E3 ^ E5 | E3 * E5
                        12 |                                        // E5 -> E6 ^ E5
                        13 => self.exit_e5(factor_id),              // E5 -> E6
                     /* 2 */                                        // E5 -> E6 | E6 ^ E5 (never called)
                        3 |                                         // E6 -> - E3
                        4 => self.exit_e6(factor_id),               // E6 -> ID
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let e6 = self.stack.pop().unwrap().get_e6();
            let val = self.listener.exit_e(CtxE::E1 { e6 });
            self.stack.push(SynValue::E(val));
        }

        fn exit_e1(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                5 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, e5 }
                }
                6 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, e5 }
                }
                7 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e, e3 }
                }
                8 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e1")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn inter_e3(&mut self) {
            let e6 = self.stack.pop().unwrap().get_e6();
            let val = self.listener.exit_e3(CtxE3::E3_1 { e6 });
            self.stack.push(SynValue::E3(val));
        }

        fn exit_e31(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                9 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_2 { e3, e5 }
                }
                10 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_3 { e3, e5 }
                }
                11 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_4 { e3 }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e31")
            };
            let val = self.listener.exit_e3(ctx);
            self.stack.push(SynValue::E3(val));
        }

        fn exit_e5(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                12 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    let e6 = self.stack.pop().unwrap().get_e6();
                    CtxE5::E5_1 { e6, e5 }
                }
                13 => {
                    let e6 = self.stack.pop().unwrap().get_e6();
                    CtxE5::E5_2 { e6 }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e5")
            };
            let val = self.listener.exit_e5(ctx);
            self.stack.push(SynValue::E5(val));
        }

        fn exit_e6(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                3 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE6::E6_1 { e3 }
                }
                4 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE6::E6_2 { id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e6")
            };
            let val = self.listener.exit_e6(ctx);
            self.stack.push(SynValue::E6(val));
        }
    }

    // [wrapper source for rule PRS(63) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)] pub struct SynE(LevelString);
    /// User-defined type for `E3`
    #[derive(Debug, PartialEq)] pub struct SynE3(LevelString);
    /// User-defined type for `E5`
    #[derive(Debug, PartialEq)] pub struct SynE5(LevelString);
    /// User-defined type for `E6`
    #[derive(Debug, PartialEq)] pub struct SynE6(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram::dfa::TokenId;
        use lexigram::grammar::Symbol;
        use lexigram::lexer::CaretCol;
        use lexigram::log::BufLog;
        use crate::integration::parser_examples::listener14::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    CtxE::E1 { e6: SynE6(ls) }
                    | CtxE::E5 { e: SynE(ls) } => ls,
                    CtxE::E2 { e: SynE(lsleft), e5: SynE5(lsright) } => ls_binary_op("^", lsleft, lsright),
                    CtxE::E3 { e: SynE(lsleft), e5: SynE5(lsright) } => ls_binary_op("*", lsleft, lsright),
                    CtxE::E4 { e: SynE(lsleft), e3: SynE3(lsright) } => ls_binary_op("+", lsleft, lsright),
                })
            }

            fn exit_e3(&mut self, ctx: CtxE3) -> SynE3 {
                SynE3(match ctx {
                    CtxE3::E3_2 { e3: SynE3(lsleft), e5: SynE5(lsright) } => ls_binary_op("^", lsleft, lsright),
                    CtxE3::E3_3 { e3: SynE3(lsleft), e5: SynE5(lsright) } => ls_binary_op("*", lsleft, lsright),
                    CtxE3::E3_1 { e6: SynE6(ls) }
                    | CtxE3::E3_4 { e3: SynE3(ls) } => ls
                })
            }

            fn exit_e5(&mut self, ctx: CtxE5) -> SynE5 {
                SynE5(match ctx {
                    // E5 -> E6 ^ E5
                    CtxE5::E5_1 { e6: SynE6(lsleft), e5: SynE5(lsright) } => ls_binary_op("^", lsleft, lsright),
                    // E5 -> E6
                    CtxE5::E5_2 { e6: SynE6(ls) } => ls,
                })
            }

            fn exit_e6(&mut self, ctx: CtxE6) -> SynE6 {
                SynE6(match ctx{
                    CtxE6::E6_1 { e3: SynE3(ls) } => ls_prefix_op("-", ls),
                    CtxE6::E6_2 { id } => LevelString(0, id)
                })
            }
        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> <R> E ^ E | E * E | - E | E + E | ID;
                ("a + b + c + d + e", Some("(((a + b) + c) + d) + e")),
                ("a * b", Some("a * b")),
                ("a + b", Some("a + b")),
                ("- a", Some("- a")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a * b * c", Some("(a * b) * c")),
                ("- a * b", Some("- (a * b)")),
                ("a * - b * c", Some("a * (- (b * c))")),   // ! because here p(-) < p(*)
                ("- a + b", Some("(- a) + b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a ^ b", Some("a ^ b")),
                ("a ^ b ^ c ^ d", Some("a ^ (b ^ (c ^ d))")),
                ("a ^ b ^ - c", Some("a ^ (b ^ (- c))")),
                ("a ^ - b ^ c", Some("a ^ (- (b ^ c))")),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let mut listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

#[cfg(test)]
#[allow(unused)]
pub(crate) mod rules_prs_65_1 {
    use crate::out::wrapper_source::level_string::LevelString;

    // ------------------------------------------------------------
    // [wrapper source for rule PRS(65) #1, start E]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_prs_65_1::*;

    #[derive(Debug)]
    pub enum CtxE {
        /// `E -> E5`
        E1 { e5: SynE5 },
        /// `E -> E ^ E4`
        E2 { e: SynE, e4: SynE4 },
        /// `E -> E * E3`
        E3 { e: SynE, e3: SynE3 },
        /// `E -> E + E3`
        E4 { e: SynE, e3: SynE3 },
        /// end of iterations in E -> E ^ E4 | E * E3 | E + E3
        E5 { e: SynE },
    }
    #[derive(Debug)]
    pub enum CtxE3 {
        /// `E3 -> E5`
        E3_1 { e5: SynE5 },
        /// `E3 -> E3 ^ E4`
        E3_2 { e3: SynE3, e4: SynE4 },
        /// `E3 -> E3 * E3`
        E3_3 { e3: [SynE3; 2] },
        /// end of iterations in E3 -> E3 ^ E4 | E3 * E3
        E3_4 { e3: SynE3 },
    }
    #[derive(Debug)]
    pub enum CtxE4 {
        /// `E4 -> E5 ^ E4`
        E4_1 { e5: SynE5, e4: SynE4 },
        /// `E4 -> E5`
        E4_2 { e5: SynE5 },
    }
    #[derive(Debug)]
    pub enum CtxE5 {
        /// `E5 -> - E3`
        E5_1 { e3: SynE3 },
        /// `E5 -> ID`
        E5_2 { id: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `E`
    // #[derive(Debug, PartialEq)] pub struct SynE();
    // /// User-defined type for `E3`
    // #[derive(Debug, PartialEq)] pub struct SynE3();
    // /// User-defined type for `E4`
    // #[derive(Debug, PartialEq)] pub struct SynE4();
    // /// User-defined type for `E5`
    // #[derive(Debug, PartialEq)] pub struct SynE5();

    #[derive(Debug)]
    enum SynValue { E(SynE), E3(SynE3), E4(SynE4), E5(SynE5) }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_e3(self) -> SynE3 {
            if let SynValue::E3(val) = self { val } else { panic!() }
        }
        fn get_e4(self) -> SynE4 {
            if let SynValue::E4(val) = self { val } else { panic!() }
        }
        fn get_e5(self) -> SynE5 {
            if let SynValue::E5(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _e: SynE) {}
        fn init_e(&mut self) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn init_e3(&mut self) {}
        fn exit_e3(&mut self, _ctx: CtxE3) -> SynE3;
        fn init_e4(&mut self) {}
        fn exit_e4(&mut self, _ctx: CtxE4) -> SynE4;
        fn init_e5(&mut self) {}
        fn exit_e5(&mut self, _ctx: CtxE5) -> SynE5;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_e(),                // E
                        1 => {}                                     // Eb
                        2 => self.listener.init_e3(),               // E3
                        3 => {}                                     // E3b
                        4 => self.listener.init_e4(),               // E4
                        5 => {}                                     // E4b
                        6 => self.listener.init_e5(),               // E5
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 => self.inter_e(),                        // E -> E5
                        1 |                                         // E -> E ^ E4
                        2 |                                         // E -> E * E3
                        3 |                                         // E -> E + E3
                        4 => self.exit_eb(factor_id),               // end of iterations in E -> E ^ E4 | E * E3 | E + E3
                        5 => self.inter_e3(),                       // E3 -> E5
                        6 |                                         // E3 -> E3 ^ E4
                        7 |                                         // E3 -> E3 * E3
                        8 => self.exit_e3b(factor_id),              // end of iterations in E3 -> E3 ^ E4 | E3 * E3
                        10 |                                        // E4 -> E5 ^ E4
                        11 => self.exit_e4(factor_id),              // E4 -> E5
                     /* 9 */                                        // E4 -> E5 | E5 ^ E4 (never called)
                        12 |                                        // E5 -> - E3
                        13 => self.exit_e5(factor_id),              // E5 -> ID
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let e = self.stack.pop().unwrap().get_e();
            self.listener.exit(e);
        }

        fn inter_e(&mut self) {
            let e5 = self.stack.pop().unwrap().get_e5();
            let val = self.listener.exit_e(CtxE::E1 { e5 });
            self.stack.push(SynValue::E(val));
        }

        fn exit_eb(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                1 => {
                    let e4 = self.stack.pop().unwrap().get_e4();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E2 { e, e4 }
                }
                2 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E3 { e, e3 }
                }
                3 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E4 { e, e3 }
                }
                4 => {
                    let e = self.stack.pop().unwrap().get_e();
                    CtxE::E5 { e }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_eb")
            };
            let val = self.listener.exit_e(ctx);
            self.stack.push(SynValue::E(val));
        }

        fn inter_e3(&mut self) {
            let e5 = self.stack.pop().unwrap().get_e5();
            let val = self.listener.exit_e3(CtxE3::E3_1 { e5 });
            self.stack.push(SynValue::E3(val));
        }

        fn exit_e3b(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                6 => {
                    let e4 = self.stack.pop().unwrap().get_e4();
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_2 { e3, e4 }
                }
                7 => {
                    let e3_2 = self.stack.pop().unwrap().get_e3();
                    let e3_1 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_3 { e3: [e3_1, e3_2] }
                }
                8 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE3::E3_4 { e3 }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e3b")
            };
            let val = self.listener.exit_e3(ctx);
            self.stack.push(SynValue::E3(val));
        }

        fn exit_e4(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                10 => {
                    let e4 = self.stack.pop().unwrap().get_e4();
                    let e5 = self.stack.pop().unwrap().get_e5();
                    CtxE4::E4_1 { e5, e4 }
                }
                11 => {
                    let e5 = self.stack.pop().unwrap().get_e5();
                    CtxE4::E4_2 { e5 }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e4")
            };
            let val = self.listener.exit_e4(ctx);
            self.stack.push(SynValue::E4(val));
        }

        fn exit_e5(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                12 => {
                    let e3 = self.stack.pop().unwrap().get_e3();
                    CtxE5::E5_1 { e3 }
                }
                13 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxE5::E5_2 { id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_e5")
            };
            let val = self.listener.exit_e5(ctx);
            self.stack.push(SynValue::E5(val));
        }
    }

    // [wrapper source for rule PRS(65) #1, start E]
    // ------------------------------------------------------------

    /// User-defined type for `E`
    #[derive(Debug, PartialEq)] pub struct SynE(LevelString);
    /// User-defined type for `E3`
    #[derive(Debug, PartialEq)] pub struct SynE3(LevelString);
    /// User-defined type for `E4`
    #[derive(Debug, PartialEq)] pub struct SynE4(LevelString);
    /// User-defined type for `E5`
    #[derive(Debug, PartialEq)] pub struct SynE5(LevelString);

    #[cfg(test)]
    mod test {
        use std::collections::HashMap;
        use iter_index::IndexerIterator;
        use lexigram::dfa::TokenId;
        use lexigram::grammar::Symbol;
        use lexigram::lexer::CaretCol;
        use lexigram::log::BufLog;
        use crate::integration::parser_examples::listener15::build_parser;
        use crate::out::wrapper_source::level_string::{ls_binary_op, ls_prefix_op};
        use super::*;

        struct EListener {
            log: BufLog,
            result: Option<String>,
        }

        impl EListener {
            fn new() -> Self {
                EListener {
                    log: BufLog::new(),
                    result: None,
                }
            }
        }

        impl TestListener for EListener {
            fn get_mut_log(&mut self) -> &mut impl Logger {
                &mut self.log
            }

            fn exit(&mut self, e: SynE) {
                self.result = Some(e.0.1);
            }

            fn init_e(&mut self) {
                self.result = None;
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                SynE(match ctx {
                    CtxE::E1 { e5: SynE5(ls) }
                    | CtxE::E5 { e: SynE(ls) } => ls,
                    CtxE::E2 { e: SynE(lsleft), e4: SynE4(lsright) } => ls_binary_op("^", lsleft, lsright),
                    CtxE::E3 { e: SynE(lsleft), e3: SynE3(lsright) } => ls_binary_op("*", lsleft, lsright),
                    CtxE::E4 { e: SynE(lsleft), e3: SynE3(lsright) } => ls_binary_op("+", lsleft, lsright),
                })
            }

            fn exit_e3(&mut self, ctx: CtxE3) -> SynE3 {
                SynE3(match ctx {
                    CtxE3::E3_2 { e3: SynE3(lsleft), e4: SynE4(lsright) } => ls_binary_op("^", lsleft, lsright),
                    CtxE3::E3_3 { e3: [SynE3(lsleft), SynE3(lsright)] } => ls_binary_op("*", lsleft, lsright),
                    CtxE3::E3_1 { e5: SynE5(ls) }
                    | CtxE3::E3_4 { e3: SynE3(ls) } => ls
                })
            }

            fn exit_e4(&mut self, ctx: CtxE4) -> SynE4 {
                SynE4(match ctx {
                    // E4 -> E5 ^ E4
                    CtxE4::E4_1 { e5: SynE5(lsleft), e4: SynE4(lsright) } => ls_binary_op("^", lsleft, lsright),
                    // E4 -> E5
                    CtxE4::E4_2 { e5: SynE5(ls) } => ls,
                })
            }

            fn exit_e5(&mut self, ctx: CtxE5) -> SynE5 {
                SynE5(match ctx{
                    CtxE5::E5_1 { e3: SynE3(ls) } => ls_prefix_op("-", ls),
                    CtxE5::E5_2 { id } => LevelString(0, id)
                })
            }

        }

        #[test]
        fn test() {
            let sequences = vec![
                // priority: E -> <R> E ^ E | <R> E * E | - E | E + E | ID;
                ("a + b + c + d + e", Some("(((a + b) + c) + d) + e")),
                ("a * b", Some("a * b")),
                ("a + b", Some("a + b")),
                ("- a", Some("- a")),
                ("a * b + c", Some("(a * b) + c")),
                ("a + b * c", Some("a + (b * c)")),
                ("a * b * c", Some("a * (b * c)")),
                ("- a * b", Some("- (a * b)")),
                ("a * - b * c", Some("a * (- (b * c))")),   // ! because here p(-) < p(*)
                ("- a + b", Some("(- a) + b")),
                ("a + - b + c", Some("(a + (- b)) + c")),
                ("a * - b", Some("a * (- b)")),
                ("a * * b", None),
                ("a ^ b", Some("a ^ b")),
                ("a ^ b ^ c ^ d", Some("a ^ (b ^ (c ^ d))")),
                ("a ^ b ^ - c", Some("a ^ (b ^ (- c))")),
                ("a ^ - b ^ c", Some("a ^ (- (b ^ c))")),
            ];
            const VERBOSE: bool = true;
            const VERBOSE_LISTENER: bool = false;
            let id_id = 4;

            let mut parser = build_parser();
            let table = parser.get_symbol_table().unwrap();
            let symbols = (0..table.get_num_t() as TokenId)
                .map(|t| (Symbol::T(t).to_str(Some(table)), t))
                .collect::<HashMap<_, _>>();
            for (input, expected_result) in sequences {
                if VERBOSE { println!("{:-<60}\nnew input '{input}'", ""); }
                let stream = input.split_ascii_whitespace().index_start::<CaretCol>(1).map(|(i, w)| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string(), 1, i)
                    } else {
                        if w.chars().next().unwrap().is_ascii_digit() {
                            // (num_id, w.to_string(), 1, i)
                            panic!("numbers not supported")
                        } else {
                            (id_id, w.to_string(), 1, i)
                        }
                    }
                });
                let listener = EListener::new();
                let mut wrapper = Wrapper::new(listener, VERBOSE_LISTENER);
                let _errors = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully: {:?}", wrapper.listener.result); }
                        None
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        Some(wrapper.listener.log.get_errors().map(|s| s.as_str()).to_vec())
                    }
                };
                if VERBOSE {
                    let msg = wrapper.listener.log.get_messages().map(|s| format!("- {s:?}")).join("\n");
                    if !msg.is_empty() {
                        println!("Messages:\n{msg}");
                    }
                }
                let listener = wrapper.get_listener();
                assert_eq!(listener.result, expected_result.map(|s| s.to_string()), "test failed for input {input}");
            }
        }
    }
}

// ================================================================================
// Test 44: rules RTS(100) #1, start 0:
/*
before, NT with value: file, file_item, header, declaration, option, rule, actions, action, match, alt_items, alt_item, repeat_item, item
after,  NT with value: file, file_item, header, declaration, option, rule, actions, action, match, alt_items, alt_item, repeat_item, item, file_1, option_1, actions_1, alt_item_1
            // NT flags:
            //  - file: parent_+_or_* (2048)
            //  - option: parent_+_or_* (2048)
            //  - rule: parent_left_fact (32)
            //  - actions: parent_+_or_* (2048)
            //  - alt_items: parent_left_rec (512)
            //  - alt_item: parent_+_or_* | plus (6144)
            //  - repeat_item: parent_left_rec (512)
            //  - item: parent_left_fact | parent_left_rec (544)
            //  - file_1: child_+_or_* (1)
            //  - option_1: child_+_or_* (1)
            //  - actions_1: child_+_or_* (1)
            //  - alt_item_1: child_+_or_* | parent_left_fact | plus (4129)
            //  - alt_items_1: child_left_rec (4)
            //  - repeat_item_1: child_left_rec | parent_left_fact (36)
            //  - item_1: child_left_rec (4)
            //  - rule_1: child_left_fact (64)
            //  - item_2: child_left_fact (64)
            //  - alt_item_2: child_left_fact (64)
            //  - repeat_item_2: child_left_fact (64)
            //  - repeat_item_3: child_left_fact (64)
            // parents:
            //  - file_1 -> file
            //  - option_1 -> option
            //  - actions_1 -> actions
            //  - alt_item_1 -> alt_item
            //  - alt_items_1 -> alt_items
            //  - repeat_item_1 -> repeat_item
            //  - item_1 -> item
            //  - rule_1 -> rule
            //  - item_2 -> item
            //  - alt_item_2 -> alt_item_1
            //  - repeat_item_2 -> repeat_item_1
            //  - repeat_item_3 -> repeat_item_1
            (RTS(100), 0, btreemap![
                0 => "SynFile".to_string(),
                1 => "SynFileItem".to_string(),
                2 => "SynHeader".to_string(),
                3 => "SynDeclaration".to_string(),
                4 => "SynOption".to_string(),
                5 => "SynRule".to_string(),
                6 => "SynActions".to_string(),
                7 => "SynAction".to_string(),
                8 => "SynMatch".to_string(),
                9 => "SynAltItems".to_string(),
                10 => "SynAltItem".to_string(),
                11 => "SynRepeatItem".to_string(),
                12 => "SynItem".to_string(),
                13 => "SynFile1".to_string(),
                14 => "SynOption1".to_string(),
                15 => "SynActions1".to_string(),
                16 => "SynAltItem1".to_string(),
            ], btreemap![
                0 => symbols![nt 2, nt 13],             //  0: file -> header file_1                 | ◄0 ►file_1 ►header            | header file_1
                1 => symbols![nt 13],                   //  1: file -> file_1                        | ◄1 ►file_1                    | file_1
                2 => symbols![nt 4],                    //  2: file_item -> option                   | ◄2 ►option                    | option
                3 => symbols![nt 3],                    //  3: file_item -> declaration              | ◄3 ►declaration               | declaration
                4 => symbols![nt 5],                    //  4: file_item -> rule                     | ◄4 ►rule                      | rule
                5 => symbols![t 23],                    //  5: header -> lexicon Id ;                | ◄5 ; Id! lexicon              | Id
                6 => symbols![t 23],                    //  6: declaration -> mode Id ;              | ◄6 ; Id! mode                 | Id
                7 => symbols![t 23, nt 14],             //  7: option -> channels { Id option_1 }    | ◄7 } ►option_1 Id! { channels | Id option_1
                8 => symbols![t 23, nt 8],              //  8: rule -> fragment Id : match ;         | ◄8 ; ►match : Id! fragment    | Id match
                9 => symbols![],                        //  9: rule -> Id : match rule_1             | ►rule_1 ►match : Id!          |
                10 => symbols![nt 7, nt 15],            // 10: actions -> action actions_1           | ◄10 ►actions_1 ►action        | action actions_1
                11 => symbols![t 23],                   // 11: action -> push ( Id )                 | ◄11 ) Id! ( push              | Id
                12 => symbols![],                       // 12: action -> pop                         | ◄12 pop                       |
                13 => symbols![],                       // 13: action -> skip                        | ◄13 skip                      |
                14 => symbols![],                       // 14: action -> return                      | ◄14 return                    |
                15 => symbols![nt 9],                   // 15: match -> alt_items                    | ◄15 ►alt_items                | alt_items
                16 => symbols![nt 10],                  // 16: alt_items -> alt_item alt_items_1     | ►alt_items_1 ◄16 ►alt_item    | alt_item
                17 => symbols![nt 16],                  // 17: alt_item -> alt_item_1                | ◄17 ►alt_item_1               | alt_item_1
                18 => symbols![nt 12],                  // 18: repeat_item -> item repeat_item_1     | ►repeat_item_1 ◄18 ►item      | item
                19 => symbols![],                       // 19: item -> ( item ) item_1               | ◄19 ►item_1 ) ●item (         |
                20 => symbols![],                       // 20: item -> ~ item item_1                 | ◄20 ►item_1 ●item ~           |
                21 => symbols![],                       // 21: item -> EOF item_1                    | ◄21 ►item_1 EOF               |
                22 => symbols![t 23],                   // 22: item -> Id item_1                     | ◄22 ►item_1 Id!               | Id
                23 => symbols![],                       // 23: item -> CharLit item_2                | ►item_2 CharLit!              |
                24 => symbols![t 25],                   // 24: item -> CharSet item_1                | ◄24 ►item_1 CharSet!          | CharSet
                25 => symbols![t 26],                   // 25: item -> StrLit item_1                 | ◄25 ►item_1 StrLit!           | StrLit
                26 => symbols![nt 13, nt 1],            // 26: file_1 -> file_item file_1            | ●file_1 ◄26 ►file_item        | file_1 file_item
                27 => symbols![],                       // 27: file_1 -> ε                           | ◄27                           |
                28 => symbols![nt 14, t 23],            // 28: option_1 -> , Id option_1             | ●option_1 ◄28 Id! ,           | option_1 Id
                29 => symbols![],                       // 29: option_1 -> ε                         | ◄29                           |
                30 => symbols![nt 15, nt 7],            // 30: actions_1 -> , action actions_1       | ●actions_1 ◄30 ►action ,      | actions_1 action
                31 => symbols![],                       // 31: actions_1 -> ε                        | ◄31                           |
                32 => symbols![],                       // 32: alt_item_1 -> repeat_item alt_item_2  | ►alt_item_2 ►repeat_item      |
                33 => symbols![nt 9, nt 10],            // 33: alt_items_1 -> | alt_item alt_items_1 | ●alt_items_1 ◄33 ►alt_item |  | alt_items alt_item
                34 => symbols![nt 9],                   // 34: alt_items_1 -> ε                      | ◄34                           | alt_items
                35 => symbols![],                       // 35: repeat_item_1 -> + repeat_item_2      | ►repeat_item_2 +              |
                36 => symbols![],                       // 36: repeat_item_1 -> * repeat_item_3      | ►repeat_item_3 *              |
                37 => symbols![nt 11],                  // 37: repeat_item_1 -> ε                    | ◄37                           | repeat_item
                38 => symbols![nt 12],                  // 38: item_1 -> ? item_1                    | ●item_1 ◄38 ?                 | item
                39 => symbols![nt 12],                  // 39: item_1 -> ε                           | ◄39                           | item
                40 => symbols![t 23, nt 8, nt 6],       // 40: rule_1 -> -> actions ;                | ◄40 ; ►actions ->             | Id match actions
                41 => symbols![t 23, nt 8],             // 41: rule_1 -> ;                           | ◄41 ;                         | Id match
                42 => symbols![t 24, t 24],             // 42: item_2 -> .. CharLit item_1           | ►item_1 ◄42 CharLit! ..       | CharLit CharLit
                43 => symbols![t 24],                   // 43: item_2 -> item_1                      | ►item_1 ◄43                   | CharLit
                44 => symbols![nt 16, nt 11],           // 44: alt_item_2 -> alt_item_1              | ●alt_item_1 ◄44               | alt_item_1 repeat_item
                45 => symbols![nt 16, nt 11],           // 45: alt_item_2 -> ε                       | ◄45                           | alt_item_1 repeat_item
                46 => symbols![nt 11],                  // 46: repeat_item_2 -> ? repeat_item_1      | ●repeat_item_1 ◄46 ?          | repeat_item
                47 => symbols![nt 11],                  // 47: repeat_item_2 -> repeat_item_1        | ●repeat_item_1 ◄47            | repeat_item
                48 => symbols![nt 11],                  // 48: repeat_item_3 -> ? repeat_item_1      | ●repeat_item_1 ◄48 ?          | repeat_item
                49 => symbols![nt 11],                  // 49: repeat_item_3 -> repeat_item_1        | ●repeat_item_1 ◄49            | repeat_item
            ], Default, btreemap![0 => vec![0, 1], 1 => vec![2, 3, 4], 2 => vec![5], 3 => vec![6], 4 => vec![7], 5 => vec![8, 40, 41], 6 => vec![10], 7 => vec![11, 12, 13, 14], 8 => vec![15], 9 => vec![16], 10 => vec![17], 11 => vec![18], 12 => vec![19, 20, 21, 22, 24, 25, 42, 43]]),
*/
pub(crate) mod rules_rts_100_1 {
    // ------------------------------------------------------------
    // [wrapper source for rule RTS(100) #1, start file]

    use lexigram::{CollectJoin, grammar::{FactorId, VarId}, log::Logger, parser::{Call, ListenerWrapper}};
    use super::super::wrapper_code::code_rts_100_1::*;

    #[derive(Debug)]
    pub enum CtxFile {
        /// `file -> header [file_item]*`
        File1 { header: SynHeader, star: SynFile1 },
        /// `file -> [file_item]*`
        File2 { star: SynFile1 },
    }
    #[derive(Debug)]
    pub enum CtxFileItem {
        /// `file_item -> option`
        FileItem1 { option: SynOption },
        /// `file_item -> declaration`
        FileItem2 { declaration: SynDeclaration },
        /// `file_item -> rule`
        FileItem3 { rule: SynRule },
    }
    #[derive(Debug)]
    pub enum CtxHeader {
        /// `header -> lexicon Id ;`
        Header { id: String },
    }
    #[derive(Debug)]
    pub enum CtxDeclaration {
        /// `declaration -> mode Id ;`
        Declaration { id: String },
    }
    #[derive(Debug)]
    pub enum CtxOption {
        /// `option -> channels { Id [, Id]* }`
        Option { id: String, star: SynOption1 },
    }
    #[derive(Debug)]
    pub enum CtxRule {
        /// `rule -> fragment Id : match ;`
        Rule1 { id: String, match1: SynMatch },
        /// `rule -> Id : match -> actions ;`
        Rule2 { id: String, match1: SynMatch, actions: SynActions },
        /// `rule -> Id : match ;`
        Rule3 { id: String, match1: SynMatch },
    }
    #[derive(Debug)]
    pub enum CtxActions {
        /// `actions -> action [, action]*`
        Actions { action: SynAction, star: SynActions1 },
    }
    #[derive(Debug)]
    pub enum CtxAction {
        /// `action -> mode ( Id )`
        Action1 { id: String },
        /// `action -> push ( Id )`
        Action2 { id: String },
        /// `action -> pop`
        Action3,
        /// `action -> skip`
        Action4,
        /// `action -> more`
        Action5,
        /// `action -> type ( Id )`
        Action6 { id: String },
        /// `action -> channel ( Id )`
        Action7 { id: String },
    }
    #[derive(Debug)]
    pub enum CtxMatch {
        /// `match -> alt_items`
        Match { alt_items: SynAltItems },
    }
    #[derive(Debug)]
    pub enum CtxAltItems {
        /// `alt_items -> alt_item [| alt_item]*`
        AltItems { alt_item: SynAltItem, star: SynAltItems1 },
    }
    #[derive(Debug)]
    pub enum CtxAltItem {
        /// `alt_item -> [repeat_item]+`
        AltItem { plus: SynAltItem1 },
    }
    #[derive(Debug)]
    pub enum CtxRepeatItem {
        /// `repeat_item -> item ?`
        RepeatItem1 { item: SynItem },
        /// `repeat_item -> item`
        RepeatItem2 { item: SynItem },
        /// `repeat_item -> item + ?`
        RepeatItem3 { item: SynItem },
        /// `repeat_item -> item +`
        RepeatItem4 { item: SynItem },
        /// `repeat_item -> item * ?`
        RepeatItem5 { item: SynItem },
        /// `repeat_item -> item *`
        RepeatItem6 { item: SynItem },
    }
    #[derive(Debug)]
    pub enum CtxItem {
        /// `item -> ( alt_items )`
        Item1 { alt_items: SynAltItems },
        /// `item -> ~ item`
        Item2 { item: SynItem },
        /// `item -> Id`
        Item3 { id: String },
        /// `item -> StrLit`
        Item4 { strlit: String },
        /// `item -> char_set`
        Item5 { char_set: SynCharSet },
        /// `item -> CharLit .. CharLit`
        Item6 { charlit: [String; 2] },
        /// `item -> CharLit`
        Item7 { charlit: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSet {
        /// `char_set -> [ [char_set_one]+ ]`
        CharSet1 { plus: SynCharSet1 },
        /// `char_set -> .`
        CharSet2,
        /// `char_set -> FixedSet`
        CharSet3 { fixedset: String },
    }
    #[derive(Debug)]
    pub enum CtxCharSetOne {
        /// `char_set_one -> FixedSet`
        CharSetOne1 { fixedset: String },
        /// `char_set_one -> SetChar - SetChar`
        CharSetOne2 { setchar: [String; 2] },
        /// `char_set_one -> SetChar`
        CharSetOne3 { setchar: String },
    }

    // NT types and user-defined type templates (copy elsewhere and uncomment when necessary):

    // /// User-defined type for `file`
    // #[derive(Debug, PartialEq)] pub struct SynFile();
    // /// User-defined type for `file_item`
    // #[derive(Debug, PartialEq)] pub struct SynFileItem();
    // /// User-defined type for `header`
    // #[derive(Debug, PartialEq)] pub struct SynHeader();
    // /// User-defined type for `declaration`
    // #[derive(Debug, PartialEq)] pub struct SynDeclaration();
    // /// User-defined type for `option`
    // #[derive(Debug, PartialEq)] pub struct SynOption();
    // /// User-defined type for `rule`
    // #[derive(Debug, PartialEq)] pub struct SynRule();
    // /// User-defined type for `actions`
    // #[derive(Debug, PartialEq)] pub struct SynActions();
    // /// User-defined type for `action`
    // #[derive(Debug, PartialEq)] pub struct SynAction();
    // /// User-defined type for `match`
    // #[derive(Debug, PartialEq)] pub struct SynMatch();
    // /// User-defined type for `alt_items`
    // #[derive(Debug, PartialEq)] pub struct SynAltItems();
    // /// User-defined type for `alt_item`
    // #[derive(Debug, PartialEq)] pub struct SynAltItem();
    // /// User-defined type for `repeat_item`
    // #[derive(Debug, PartialEq)] pub struct SynRepeatItem();
    // /// User-defined type for `item`
    // #[derive(Debug, PartialEq)] pub struct SynItem();
    // /// User-defined type for `char_set`
    // #[derive(Debug, PartialEq)] pub struct SynCharSet();
    // /// User-defined type for `char_set_one`
    // #[derive(Debug, PartialEq)] pub struct SynCharSetOne();
    /// Computed `[file_item]*` array in `file -> header  ► [file_item]* ◄ `, array in `file ->  ► [file_item]* ◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynFile1(pub Vec<SynFileItem>);
    /// Computed `[, Id]*` array in `option -> channels { Id  ► [, Id]* ◄  }`
    #[derive(Debug, PartialEq)]
    pub struct SynOption1(pub Vec<String>);
    /// Computed `[, action]*` array in `actions -> action  ► [, action]* ◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynActions1(pub Vec<SynAction>);
    /// Computed `[| alt_item]*` array in `alt_items -> alt_item  ► [| alt_item]* ◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItems1(pub Vec<SynAltItem>);
    /// Computed `[repeat_item]+` array in `alt_item ->  ► [repeat_item]+ ◄ `
    #[derive(Debug, PartialEq)]
    pub struct SynAltItem1(pub Vec<SynRepeatItem>);
    /// Computed `[char_set_one]+` array in `char_set -> [  ► [char_set_one]+ ◄  ]`
    #[derive(Debug, PartialEq)]
    pub struct SynCharSet1(pub Vec<SynCharSetOne>);

    #[derive(Debug)]
    enum SynValue { File(SynFile), FileItem(SynFileItem), Header(SynHeader), Declaration(SynDeclaration), Option(SynOption), Rule(SynRule), Actions(SynActions), Action(SynAction), Match(SynMatch), AltItems(SynAltItems), AltItem(SynAltItem), RepeatItem(SynRepeatItem), Item(SynItem), CharSet(SynCharSet), CharSetOne(SynCharSetOne), File1(SynFile1), Option1(SynOption1), Actions1(SynActions1), AltItems1(SynAltItems1), AltItem1(SynAltItem1), CharSet1(SynCharSet1) }

    impl SynValue {
        fn get_file(self) -> SynFile {
            if let SynValue::File(val) = self { val } else { panic!() }
        }
        fn get_file_item(self) -> SynFileItem {
            if let SynValue::FileItem(val) = self { val } else { panic!() }
        }
        fn get_header(self) -> SynHeader {
            if let SynValue::Header(val) = self { val } else { panic!() }
        }
        fn get_declaration(self) -> SynDeclaration {
            if let SynValue::Declaration(val) = self { val } else { panic!() }
        }
        fn get_option(self) -> SynOption {
            if let SynValue::Option(val) = self { val } else { panic!() }
        }
        fn get_rule(self) -> SynRule {
            if let SynValue::Rule(val) = self { val } else { panic!() }
        }
        fn get_actions(self) -> SynActions {
            if let SynValue::Actions(val) = self { val } else { panic!() }
        }
        fn get_action(self) -> SynAction {
            if let SynValue::Action(val) = self { val } else { panic!() }
        }
        fn get_match(self) -> SynMatch {
            if let SynValue::Match(val) = self { val } else { panic!() }
        }
        fn get_alt_items(self) -> SynAltItems {
            if let SynValue::AltItems(val) = self { val } else { panic!() }
        }
        fn get_alt_item(self) -> SynAltItem {
            if let SynValue::AltItem(val) = self { val } else { panic!() }
        }
        fn get_repeat_item(self) -> SynRepeatItem {
            if let SynValue::RepeatItem(val) = self { val } else { panic!() }
        }
        fn get_item(self) -> SynItem {
            if let SynValue::Item(val) = self { val } else { panic!() }
        }
        fn get_char_set(self) -> SynCharSet {
            if let SynValue::CharSet(val) = self { val } else { panic!() }
        }
        fn get_char_set_one(self) -> SynCharSetOne {
            if let SynValue::CharSetOne(val) = self { val } else { panic!() }
        }
        fn get_file1(self) -> SynFile1 {
            if let SynValue::File1(val) = self { val } else { panic!() }
        }
        fn get_option1(self) -> SynOption1 {
            if let SynValue::Option1(val) = self { val } else { panic!() }
        }
        fn get_actions1(self) -> SynActions1 {
            if let SynValue::Actions1(val) = self { val } else { panic!() }
        }
        fn get_alt_items1(self) -> SynAltItems1 {
            if let SynValue::AltItems1(val) = self { val } else { panic!() }
        }
        fn get_alt_item1(self) -> SynAltItem1 {
            if let SynValue::AltItem1(val) = self { val } else { panic!() }
        }
        fn get_char_set1(self) -> SynCharSet1 {
            if let SynValue::CharSet1(val) = self { val } else { panic!() }
        }
    }

    pub trait TestListener {
        /// Checks if the listener requests an abort. This happens if an error is too difficult to recover from
        /// and may corrupt the stack content. In that case, the parser immediately stops and returns `ParserError::AbortRequest`.
        fn check_abort_request(&self) -> bool { false }
        fn get_mut_log(&mut self) -> &mut impl Logger;
        fn exit(&mut self, _file: SynFile) {}
        fn init_file(&mut self) {}
        fn exit_file(&mut self, _ctx: CtxFile) -> SynFile;
        fn init_file_item(&mut self) {}
        fn exit_file_item(&mut self, _ctx: CtxFileItem) -> SynFileItem;
        fn init_header(&mut self) {}
        fn exit_header(&mut self, _ctx: CtxHeader) -> SynHeader;
        fn init_declaration(&mut self) {}
        fn exit_declaration(&mut self, _ctx: CtxDeclaration) -> SynDeclaration;
        fn init_option(&mut self) {}
        fn exit_option(&mut self, _ctx: CtxOption) -> SynOption;
        fn init_rule(&mut self) {}
        fn exit_rule(&mut self, _ctx: CtxRule) -> SynRule;
        fn init_actions(&mut self) {}
        fn exit_actions(&mut self, _ctx: CtxActions) -> SynActions;
        fn init_action(&mut self) {}
        fn exit_action(&mut self, _ctx: CtxAction) -> SynAction;
        fn init_match(&mut self) {}
        fn exit_match(&mut self, _ctx: CtxMatch) -> SynMatch;
        fn init_alt_items(&mut self) {}
        fn exit_alt_items(&mut self, _ctx: CtxAltItems) -> SynAltItems;
        fn init_alt_item(&mut self) {}
        fn exit_alt_item(&mut self, _ctx: CtxAltItem) -> SynAltItem;
        fn init_repeat_item(&mut self) {}
        fn exit_repeat_item(&mut self, _ctx: CtxRepeatItem) -> SynRepeatItem;
        fn init_item(&mut self) {}
        fn exit_item(&mut self, _ctx: CtxItem) -> SynItem;
        fn init_char_set(&mut self) {}
        fn exit_char_set(&mut self, _ctx: CtxCharSet) -> SynCharSet;
        fn init_char_set_one(&mut self) {}
        fn exit_char_set_one(&mut self, _ctx: CtxCharSetOne) -> SynCharSetOne;
    }

    pub struct Wrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        max_stack: usize,
        stack_t: Vec<String>,
    }

    impl<T: TestListener> ListenerWrapper for Wrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: FactorId, t_data: Option<Vec<String>>) {
            if self.verbose {
                println!("switch: call={call:?}, nt={nt}, factor={factor_id}, t_data={t_data:?}");
            }
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.listener.init_file(),             // file
                        15 => self.init_file1(),                    // file_1
                        1 => self.listener.init_file_item(),        // file_item
                        2 => self.listener.init_header(),           // header
                        3 => self.listener.init_declaration(),      // declaration
                        4 => self.listener.init_option(),           // option
                        16 => self.init_option1(),                  // option_1
                        5 => self.listener.init_rule(),             // rule
                        21 => {}                                    // rule_1
                        6 => self.listener.init_actions(),          // actions
                        17 => self.init_actions1(),                 // actions_1
                        7 => self.listener.init_action(),           // action
                        8 => self.listener.init_match(),            // match
                        9 => self.listener.init_alt_items(),        // alt_items
                        18 => self.init_alt_items1(),               // alt_items_1
                        10 => self.listener.init_alt_item(),        // alt_item
                        19 => self.init_alt_item1(),                // alt_item_1
                        25 => {}                                    // alt_item_2
                        11 => self.listener.init_repeat_item(),     // repeat_item
                        22 => {}                                    // repeat_item_1
                        27 => {}                                    // repeat_item_2
                        28 => {}                                    // repeat_item_3
                        12 => self.listener.init_item(),            // item
                        23 => {}                                    // item_1
                        13 => self.listener.init_char_set(),        // char_set
                        20 => self.init_char_set1(),                // char_set_1
                        26 => {}                                    // char_set_2
                        14 => self.listener.init_char_set_one(),    // char_set_one
                        24 => {}                                    // char_set_one_1
                        _ => panic!("unexpected enter non-terminal id: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    match factor_id {
                        0 |                                         // file -> header [file_item]*
                        1 => self.exit_file(factor_id),             // file -> [file_item]*
                        33 => self.exit_file1(),                    // [file_item]* item in file -> header  ► [file_item]* ◄  | ...
                        34 => {}                                    // end of [file_item]* items in file -> header  ► [file_item]* ◄  | ...
                        2 |                                         // file_item -> option
                        3 |                                         // file_item -> declaration
                        4 => self.exit_file_item(factor_id),        // file_item -> rule
                        5 => self.exit_header(),                    // header -> lexicon Id ;
                        6 => self.exit_declaration(),               // declaration -> mode Id ;
                        7 => self.exit_option(),                    // option -> channels { Id [, Id]* }
                        35 => self.exit_option1(),                  // [, Id]* item in option -> channels { Id  ► [, Id]* ◄  }
                        36 => {}                                    // end of [, Id]* items in option -> channels { Id  ► [, Id]* ◄  }
                        8 |                                         // rule -> fragment Id : match ;
                        43 |                                        // rule -> Id : match -> actions ;
                        44 => self.exit_rule(factor_id),            // rule -> Id : match ;
                     /* 9 */                                        // rule -> Id : match -> actions ; | Id : match ; (never called)
                        10 => self.exit_actions(),                  // actions -> action [, action]*
                        37 => self.exit_actions1(),                 // [, action]* item in actions -> action  ► [, action]* ◄
                        38 => {}                                    // end of [, action]* items in actions -> action  ► [, action]* ◄
                        11 |                                        // action -> mode ( Id )
                        12 |                                        // action -> push ( Id )
                        13 |                                        // action -> pop
                        14 |                                        // action -> skip
                        15 |                                        // action -> more
                        16 |                                        // action -> type ( Id )
                        17 => self.exit_action(factor_id),          // action -> channel ( Id )
                        18 => self.exit_match(),                    // match -> alt_items
                        19 => self.exit_alt_items(),                // alt_items -> alt_item [| alt_item]*
                        39 => self.exit_alt_items1(),               // [| alt_item]* item in alt_items -> alt_item  ► [| alt_item]* ◄
                        40 => {}                                    // end of [| alt_item]* items in alt_items -> alt_item  ► [| alt_item]* ◄
                        20 => self.exit_alt_item(),                 // alt_item -> [repeat_item]+
                        53 |                                        // [repeat_item]+ item in alt_item ->  ► [repeat_item]+ ◄
                        54 => self.exit_alt_item1(),                // end of [repeat_item]+ items in alt_item ->  ► [repeat_item]+ ◄
                     /* 41 */                                       // [repeat_item]+ item in alt_item ->  ► [repeat_item]+ ◄  (never called)
                        46 |                                        // repeat_item -> item ?
                        48 |                                        // repeat_item -> item
                        57 |                                        // repeat_item -> item + ?
                        58 |                                        // repeat_item -> item +
                        59 |                                        // repeat_item -> item * ?
                        60 => self.exit_repeat_item(factor_id),     // repeat_item -> item *
                     /* 21 */                                       // repeat_item -> item | item + | item + ? | item ? | item * | item * ? (never called)
                     /* 45 */                                       // repeat_item -> item + | item + ? (never called)
                     /* 47 */                                       // repeat_item -> item * | item * ? (never called)
                        22 |                                        // item -> ( alt_items )
                        23 |                                        // item -> ~ item
                        24 |                                        // item -> Id
                        26 |                                        // item -> StrLit
                        27 |                                        // item -> char_set
                        49 |                                        // item -> CharLit .. CharLit
                        50 => self.exit_item(factor_id),            // item -> CharLit
                     /* 25 */                                       // item -> CharLit | CharLit .. CharLit (never called)
                        28 |                                        // char_set -> [ [char_set_one]+ ]
                        29 |                                        // char_set -> .
                        30 => self.exit_char_set(factor_id),        // char_set -> FixedSet
                        55 |                                        // [char_set_one]+ item in char_set -> [  ► [char_set_one]+ ◄  ]
                        56 => self.exit_char_set1(),                // end of [char_set_one]+ items in char_set -> [  ► [char_set_one]+ ◄  ]
                     /* 42 */                                       // [char_set_one]+ item in char_set -> [  ► [char_set_one]+ ◄  ] (never called)
                        31 |                                        // char_set_one -> FixedSet
                        51 |                                        // char_set_one -> SetChar - SetChar
                        52 => self.exit_char_set_one(factor_id),    // char_set_one -> SetChar
                     /* 32 */                                       // char_set_one -> SetChar | SetChar - SetChar (never called)
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            if self.verbose {
                println!("> stack_t:   {}", self.stack_t.join(", "));
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
            }
        }

        fn check_abort_request(&self) -> bool {
            self.listener.check_abort_request()
        }

        fn get_mut_log(&mut self) -> &mut impl Logger {
            self.listener.get_mut_log()
        }
    }

    impl<T: TestListener> Wrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            Wrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
        }

        pub fn get_listener(&self) -> &T {
            &self.listener
        }

        pub fn get_mut_listener(&mut self) -> &mut T {
            &mut self.listener
        }

        pub fn listener(self) -> T {
            self.listener
        }

        pub fn set_verbose(&mut self, verbose: bool) {
            self.verbose = verbose;
        }

        fn exit(&mut self) {
            let file = self.stack.pop().unwrap().get_file();
            self.listener.exit(file);
        }

        fn exit_file(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                0 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    let header = self.stack.pop().unwrap().get_header();
                    CtxFile::File1 { header, star }
                }
                1 => {
                    let star = self.stack.pop().unwrap().get_file1();
                    CtxFile::File2 { star }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_file")
            };
            let val = self.listener.exit_file(ctx);
            self.stack.push(SynValue::File(val));
        }

        fn init_file1(&mut self) {
            let val = SynFile1(Vec::new());
            self.stack.push(SynValue::File1(val));
        }

        fn exit_file1(&mut self) {
            let file_item = self.stack.pop().unwrap().get_file_item();
            let mut star_it = self.stack.pop().unwrap().get_file1();
            star_it.0.push(file_item);
            self.stack.push(SynValue::File1(star_it));
        }

        fn exit_file_item(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                2 => {
                    let option = self.stack.pop().unwrap().get_option();
                    CtxFileItem::FileItem1 { option }
                }
                3 => {
                    let declaration = self.stack.pop().unwrap().get_declaration();
                    CtxFileItem::FileItem2 { declaration }
                }
                4 => {
                    let rule = self.stack.pop().unwrap().get_rule();
                    CtxFileItem::FileItem3 { rule }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_file_item")
            };
            let val = self.listener.exit_file_item(ctx);
            self.stack.push(SynValue::FileItem(val));
        }

        fn exit_header(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_header(CtxHeader::Header { id });
            self.stack.push(SynValue::Header(val));
        }

        fn exit_declaration(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_declaration(CtxDeclaration::Declaration { id });
            self.stack.push(SynValue::Declaration(val));
        }

        fn exit_option(&mut self) {
            let star = self.stack.pop().unwrap().get_option1();
            let id = self.stack_t.pop().unwrap();
            let val = self.listener.exit_option(CtxOption::Option { id, star });
            self.stack.push(SynValue::Option(val));
        }

        fn init_option1(&mut self) {
            let val = SynOption1(Vec::new());
            self.stack.push(SynValue::Option1(val));
        }

        fn exit_option1(&mut self) {
            let id = self.stack_t.pop().unwrap();
            let mut star_it = self.stack.pop().unwrap().get_option1();
            star_it.0.push(id);
            self.stack.push(SynValue::Option1(star_it));
        }

        fn exit_rule(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                8 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule1 { id, match1 }
                }
                43 => {
                    let actions = self.stack.pop().unwrap().get_actions();
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule2 { id, match1, actions }
                }
                44 => {
                    let match1 = self.stack.pop().unwrap().get_match();
                    let id = self.stack_t.pop().unwrap();
                    CtxRule::Rule3 { id, match1 }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_rule")
            };
            let val = self.listener.exit_rule(ctx);
            self.stack.push(SynValue::Rule(val));
        }

        fn exit_actions(&mut self) {
            let star = self.stack.pop().unwrap().get_actions1();
            let action = self.stack.pop().unwrap().get_action();
            let val = self.listener.exit_actions(CtxActions::Actions { action, star });
            self.stack.push(SynValue::Actions(val));
        }

        fn init_actions1(&mut self) {
            let val = SynActions1(Vec::new());
            self.stack.push(SynValue::Actions1(val));
        }

        fn exit_actions1(&mut self) {
            let action = self.stack.pop().unwrap().get_action();
            let mut star_it = self.stack.pop().unwrap().get_actions1();
            star_it.0.push(action);
            self.stack.push(SynValue::Actions1(star_it));
        }

        fn exit_action(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                11 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action1 { id }
                }
                12 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action2 { id }
                }
                13 => {
                    CtxAction::Action3
                }
                14 => {
                    CtxAction::Action4
                }
                15 => {
                    CtxAction::Action5
                }
                16 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action6 { id }
                }
                17 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxAction::Action7 { id }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_action")
            };
            let val = self.listener.exit_action(ctx);
            self.stack.push(SynValue::Action(val));
        }

        fn exit_match(&mut self) {
            let alt_items = self.stack.pop().unwrap().get_alt_items();
            let val = self.listener.exit_match(CtxMatch::Match { alt_items });
            self.stack.push(SynValue::Match(val));
        }

        fn exit_alt_items(&mut self) {
            let star = self.stack.pop().unwrap().get_alt_items1();
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let val = self.listener.exit_alt_items(CtxAltItems::AltItems { alt_item, star });
            self.stack.push(SynValue::AltItems(val));
        }

        fn init_alt_items1(&mut self) {
            let val = SynAltItems1(Vec::new());
            self.stack.push(SynValue::AltItems1(val));
        }

        fn exit_alt_items1(&mut self) {
            let alt_item = self.stack.pop().unwrap().get_alt_item();
            let mut star_it = self.stack.pop().unwrap().get_alt_items1();
            star_it.0.push(alt_item);
            self.stack.push(SynValue::AltItems1(star_it));
        }

        fn exit_alt_item(&mut self) {
            let plus = self.stack.pop().unwrap().get_alt_item1();
            let val = self.listener.exit_alt_item(CtxAltItem::AltItem { plus });
            self.stack.push(SynValue::AltItem(val));
        }

        fn init_alt_item1(&mut self) {
            let val = SynAltItem1(Vec::new());
            self.stack.push(SynValue::AltItem1(val));
        }

        fn exit_alt_item1(&mut self) {
            let repeat_item = self.stack.pop().unwrap().get_repeat_item();
            let mut plus_it = self.stack.pop().unwrap().get_alt_item1();
            plus_it.0.push(repeat_item);
            self.stack.push(SynValue::AltItem1(plus_it));
        }

        fn exit_repeat_item(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                46 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem1 { item }
                }
                48 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem2 { item }
                }
                57 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem3 { item }
                }
                58 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem4 { item }
                }
                59 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem5 { item }
                }
                60 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxRepeatItem::RepeatItem6 { item }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_repeat_item")
            };
            let val = self.listener.exit_repeat_item(ctx);
            self.stack.push(SynValue::RepeatItem(val));
        }

        fn exit_item(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                22 => {
                    let alt_items = self.stack.pop().unwrap().get_alt_items();
                    CtxItem::Item1 { alt_items }
                }
                23 => {
                    let item = self.stack.pop().unwrap().get_item();
                    CtxItem::Item2 { item }
                }
                24 => {
                    let id = self.stack_t.pop().unwrap();
                    CtxItem::Item3 { id }
                }
                26 => {
                    let strlit = self.stack_t.pop().unwrap();
                    CtxItem::Item4 { strlit }
                }
                27 => {
                    let char_set = self.stack.pop().unwrap().get_char_set();
                    CtxItem::Item5 { char_set }
                }
                49 => {
                    let charlit_2 = self.stack_t.pop().unwrap();
                    let charlit_1 = self.stack_t.pop().unwrap();
                    CtxItem::Item6 { charlit: [charlit_1, charlit_2] }
                }
                50 => {
                    let charlit = self.stack_t.pop().unwrap();
                    CtxItem::Item7 { charlit }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_item")
            };
            let val = self.listener.exit_item(ctx);
            self.stack.push(SynValue::Item(val));
        }

        fn exit_char_set(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                28 => {
                    let plus = self.stack.pop().unwrap().get_char_set1();
                    CtxCharSet::CharSet1 { plus }
                }
                29 => {
                    CtxCharSet::CharSet2
                }
                30 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSet::CharSet3 { fixedset }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_char_set")
            };
            let val = self.listener.exit_char_set(ctx);
            self.stack.push(SynValue::CharSet(val));
        }

        fn init_char_set1(&mut self) {
            let val = SynCharSet1(Vec::new());
            self.stack.push(SynValue::CharSet1(val));
        }

        fn exit_char_set1(&mut self) {
            let char_set_one = self.stack.pop().unwrap().get_char_set_one();
            let mut plus_it = self.stack.pop().unwrap().get_char_set1();
            plus_it.0.push(char_set_one);
            self.stack.push(SynValue::CharSet1(plus_it));
        }

        fn exit_char_set_one(&mut self, factor_id: FactorId) {
            let ctx = match factor_id {
                31 => {
                    let fixedset = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne1 { fixedset }
                }
                51 => {
                    let setchar_2 = self.stack_t.pop().unwrap();
                    let setchar_1 = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne2 { setchar: [setchar_1, setchar_2] }
                }
                52 => {
                    let setchar = self.stack_t.pop().unwrap();
                    CtxCharSetOne::CharSetOne3 { setchar }
                }
                _ => panic!("unexpected factor id {factor_id} in fn exit_char_set_one")
            };
            let val = self.listener.exit_char_set_one(ctx);
            self.stack.push(SynValue::CharSetOne(val));
        }
    }

    // [wrapper source for rule RTS(100) #1, start file]
    // ------------------------------------------------------------
}
