// Copyright 2023 Redglyph
//
// Integration tests: tests that all the functionalities are accessible and work as expected.

#![cfg(test)]
#![allow(non_camel_case_types)]

mod parser_gen {

    #[test]
    fn test_source_code_manual() {
        let _parser = source_code_manual::build_parser();
    }

    // This is generated by `rlexer::parsergen::gen_integration::write_source_code_from_ll1`, with `build_prs(13)`
    mod source_code_manual {
        // [write_source_code_from_ll1]
        // -------------------------------------------------------------------------
        // Automatically generated

        use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
        use rlexer::parser::{OpCode, Parser};
        use rlexer::symbol_table::SymbolTable;

        const PARSER_NUM_T: usize = 10;
        const PARSER_NUM_NT: usize = 3;
        const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("SUB", Some("-")), ("ADD", Some("+")), ("DIV", Some("/")), ("MUL", Some("*")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None), ("EXP", Some("^")), ("DUM", Some(":"))];
        const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1"];
        const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
        const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (1, &[Symbol::T(6)]), (1, &[Symbol::T(7)]), (2, &[Symbol::T(9), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(8), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(2), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(3), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
        const PARSING_TABLE: [FactorId; 33] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 11, 11, 1, 11, 2, 3, 11, 11, 11, 8, 9, 6, 7, 11, 10, 11, 11, 5, 4, 10];
        const FLAGS: [u32; 3] = [1536, 0, 12];
        const PARENT: [Option<VarId>; 3] = [None, None, Some(0)];
        const OPCODES: [&[OpCode]; 11] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::Exit(1), OpCode::T(5), OpCode::NT(0), OpCode::T(4)], &[OpCode::Exit(2), OpCode::T(6)], &[OpCode::Exit(3), OpCode::T(7)], &[OpCode::Loop(2), OpCode::Exit(4), OpCode::NT(1), OpCode::T(9)], &[OpCode::Loop(2), OpCode::Exit(5), OpCode::NT(1), OpCode::T(8)], &[OpCode::Loop(2), OpCode::Exit(6), OpCode::NT(1), OpCode::T(2)], &[OpCode::Loop(2), OpCode::Exit(7), OpCode::NT(1), OpCode::T(3)], &[OpCode::Loop(2), OpCode::Exit(8), OpCode::NT(1), OpCode::T(0)], &[OpCode::Loop(2), OpCode::Exit(9), OpCode::NT(1), OpCode::T(1)], &[OpCode::Exit(10)]];
        const START_SYMBOL: VarId = 0;

        pub(super) fn build_parser() -> Parser {
            let mut symbol_table = SymbolTable::new();
            symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
            symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
            symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
            let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
            let table: Vec<FactorId> = PARSING_TABLE.into();
            let parsing_table = rlexer::grammar::LLParsingTable {
                num_nt: PARSER_NUM_NT,
                num_t: PARSER_NUM_T + 1,
                factors,
                table,
                flags: FLAGS.into(),
                parent: PARENT.into(),
            };
            Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
        }

        // -------------------------------------------------------------------------
        // [write_source_code_from_ll1]
    }
}

mod listener {
    use std::collections::HashMap;
    use rlexer::dfa::TokenId;
    use rlexer::parser::{Call, Listener};

    // [write_source_code_for_integration_listener]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 8;
    const PARSER_NUM_NT: usize = 5;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("SUB", Some("-")), ("ADD", Some("+")), ("DIV", Some("/")), ("MUL", Some("*")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "T", "F", "E_1", "T_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("E_1", 3), ("T_1", 4)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(3)]), (1, &[Symbol::NT(2), Symbol::NT(4)]), (2, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (2, &[Symbol::T(6)]), (2, &[Symbol::T(7)]), (3, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::Empty]), (4, &[Symbol::T(2), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::T(3), Symbol::NT(2), Symbol::NT(4)]), (4, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 45] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 1, 11, 1, 1, 11, 11, 11, 11, 11, 2, 11, 3, 4, 11, 5, 6, 11, 11, 11, 7, 11, 11, 7, 10, 10, 8, 9, 11, 10, 11, 11, 10];
    const FLAGS: [u32; 5] = [512, 512, 0, 4, 4];
    const PARENT: [Option<VarId>; 5] = [None, None, None, Some(0), Some(1)];
    const OPCODES: [&[OpCode]; 11] = [&[OpCode::NT(3), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::NT(4), OpCode::Exit(1), OpCode::NT(2)], &[OpCode::Exit(2), OpCode::T(5), OpCode::NT(0), OpCode::T(4)], &[OpCode::Exit(3), OpCode::T(6)], &[OpCode::Exit(4), OpCode::T(7)], &[OpCode::Loop(3), OpCode::Exit(5), OpCode::NT(1), OpCode::T(0)], &[OpCode::Loop(3), OpCode::Exit(6), OpCode::NT(1), OpCode::T(1)], &[OpCode::Exit(7)], &[OpCode::Loop(4), OpCode::Exit(8), OpCode::NT(2), OpCode::T(2)], &[OpCode::Loop(4), OpCode::Exit(9), OpCode::NT(2), OpCode::T(3)], &[OpCode::Exit(10)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener]

    // E -> E + T | E - T | T
    // T -> T * F | T / F | F
    // F -> ( E ) | NUM | ID
    //
    //  0: E -> T E_1     - ►E_1 ◄0 ►T
    //  1: T -> F T_1     - ►T_1 ◄1 ►F
    //  2: F -> ( E )     - ◄2 ) ►E (
    //  3: F -> N         - ◄3 N!
    //  4: F -> I         - ◄4 I!
    //  5: E_1 -> - T E_1 - ●E_1 ◄5 ►T -
    //  6: E_1 -> + T E_1 - ●E_1 ◄6 ►T +
    //  7: E_1 -> ε       - ◄7
    //  8: T_1 -> / F T_1 - ●T_1 ◄8 ►F /
    //  9: T_1 -> * F T_1 - ●T_1 ◄9 ►F *
    // 10: T_1 -> ε       - ◄10
    //
    // - NT flags:
    //   - E: parent_left_rec (512)
    //   - T: parent_left_rec (512)
    //   - E_1: child_left_rec (4)
    //   - T_1: child_left_rec (4)
    // - parents:
    //   - E_1 -> E
    //   - T_1 -> T

    pub enum CtxF { LpRp, Num(String), Id(String) }
    pub enum CtxE1 { Add, Sub, Empty }
    pub enum CtxT1 { Mul, Div, Empty }

    pub trait ExprListener {
        fn enter_e(&mut self) {}
        fn enter_t(&mut self) {}
        fn enter_f(&mut self) {}
        fn enter_e_1(&mut self) {}
        fn enter_t_1(&mut self) {}
        fn exit_e(&mut self) {}
        fn exit_t(&mut self) {}
        fn exit_f(&mut self, _ctx: CtxF) {}
        fn exit_e_1(&mut self, _ctx: CtxE1) {}
        fn exit_t_1(&mut self, _ctx: CtxT1) {}
    }

    struct ListenerWrapper<T> {
        listener: T,
        stack_t: Vec<String>
    }

    impl<T: ExprListener> ListenerWrapper<T> {
        pub fn new(listener: T) -> Self {
            Self { listener, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    impl<T: ExprListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter | Call::Loop => {
                    match nt {
                        0 => self.listener.enter_e(),
                        1 => self.listener.enter_t(),
                        2 => self.listener.enter_f(),
                        3 => self.listener.enter_e_1(),
                        4 => self.listener.enter_t_1(),
                        _ => panic!("unexpected nt exit value: {nt}")
                    }
                }
                Call::Exit => {
                    match factor_id {
                        0 => {}                                                             //  0: E -> T E_1     - ►E_1 ◄0 ►T
                        1 => {}                                                             //  1: T -> F T_1     - ►T_1 ◄1 ►F
                        2 => self.listener.exit_f(CtxF::LpRp),                              //  2: F -> ( E )     - ◄2 ) ►E (
                        3 => self.listener.exit_f(CtxF::Num(self.stack_t.pop().unwrap())),  //  3: F -> N         - ◄3 N!
                        4 => self.listener.exit_f(CtxF::Id(self.stack_t.pop().unwrap())),   //  4: F -> I         - ◄4 I!
                        5 => self.listener.exit_e_1(CtxE1::Add),                            //  5: E_1 -> - T E_1 - ●E_1 ◄5 ►T -
                        6 => self.listener.exit_e_1(CtxE1::Sub),                            //  6: E_1 -> + T E_1 - ●E_1 ◄6 ►T +
                        7 => self.exit_e_1(),                                               //  7: E_1 -> ε       - ◄7
                        8 => self.listener.exit_t_1(CtxT1::Mul),                            //  8: T_1 -> / F T_1 - ●T_1 ◄8 ►F /
                        9 => self.listener.exit_t_1(CtxT1::Div),                            //  9: T_1 -> * F T_1 - ●T_1 ◄9 ►F *
                        10 => self.exit_t_1(),                                              // 10: T_1 -> ε       - ◄10
                        _ => panic!("unexpected nt exit factor id: {nt}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
        }
    }

    // TODO: move "hidden" functions here (*e_1, *t_1, ...)
    impl<T: ExprListener> ListenerWrapper<T> {
        fn exit(&mut self) {

        }

        fn exit_e_1(&mut self) {
            self.listener.exit_e_1(CtxE1::Empty);
            self.listener.exit_e();
        }

        fn exit_t_1(&mut self) {
            self.listener.exit_t_1(CtxT1::Empty);
            self.listener.exit_t();
        }
    }

    // User code -----------------------------------------------------

    struct TestListener {
        result: Vec<String>,
        level: usize,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { result: Vec::new(), level: 0, verbose }
        }
    }

    impl ExprListener for TestListener {
        fn enter_e(&mut self) {
            if self.verbose { println!("{: <1$}(E", "", self.level * 4); }
            self.result.push("(E".to_string());
            self.level += 1;
        }

        fn enter_t(&mut self) {
            if self.verbose { println!("{: <1$}(T", "", self.level * 4); }
            self.result.push("(T".to_string());
            self.level += 1;
        }

        fn enter_f(&mut self) {
            if self.verbose { println!("{: <1$}(F", "", self.level * 4); }
            self.result.push("(F".to_string());
            self.level += 1;
        }

        // we're not interested in enter_e_1

        fn enter_t_1(&mut self) {
            if self.verbose { println!("{: <1$}(T_1", "", self.level * 4); }
            self.result.push("(T_1".to_string());
            self.level += 1;
        }

        fn exit_e(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} E)", "", self.level * 4); }
            self.result.push("E)".to_string());
        }

        fn exit_t(&mut self) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T)", "", self.level * 4); }
            self.result.push("T)".to_string());
        }

        fn exit_f(&mut self, ctx: CtxF) {
            self.level -= 1;
            let output = match ctx {
                CtxF::LpRp => format!("F)"),
                CtxF::Num(n) => format!("F)=#{n}"),
                CtxF::Id(i) => format!("F)='{i}'"),
            };
            if self.verbose { println!("{: <1$} {output}", "", self.level * 4); }
            self.result.push(output);
        }

        // we're not interested in exit_e_1

        fn exit_t_1(&mut self, _ctx: CtxT1) {
            self.level -= 1;
            if self.verbose { println!("{: <1$} T_1)", "", self.level * 4); }
            self.result.push("T_1)".to_string());
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // E -> T E_1
            // T -> F T_1
            // F -> ( E ) | NUM | ID
            // E_1 -> + T E_1 | - T E_1 | ε
            // T_1 -> * F T_1 | / F T_1 | ε
            ("a+2*b", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "T_1)", "T)", "(T", "(F", "F)=#2",
                "(T_1", "(F", "F)='b'", "T_1)", "(T_1", "T_1)", "T)", "E)"]),
            ("a*(4+5)", true, vec![
                "(E", "(T", "(F", "F)='a'", "(T_1", "(F", "(E", "(T", "(F", "F)=#4", "(T_1", "T_1)", "T)",
                "(T", "(F", "F)=#5", "(T_1", "T_1)", "T)", "E)", "F)", "T_1)", "(T_1", "T_1)", "T)", "E)"]),
        ];
        const VERBOSE: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let listener = TestListener::new(VERBOSE);
            let mut wrapper = ListenerWrapper::new(listener);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            let listener = wrapper.listener();

            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {}", listener.result.join(" -> ")); }
            assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
        }
    }
}

// ---------------------------------------------------------------------------------------------
// General helper traits

#[allow(unused)]
mod listener2 {
    use std::collections::HashMap;
    use std::str::FromStr;
    use rlexer::dfa::TokenId;
    use rlexer::parser::{Call, Listener};
    use rlexer::CollectJoin;

    // [write_source_code_for_integration_listener2]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 10;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("SUB", Some("-")), ("ADD", Some("+")), ("DIV", Some("/")), ("MUL", Some("*")), ("LPAREN", Some("(")), ("RPAREN", Some(")")), ("N", None), ("I", None), ("EXP", Some("^")), ("DUM", Some(":"))];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 11] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(4), Symbol::NT(0), Symbol::T(5)]), (1, &[Symbol::T(6)]), (1, &[Symbol::T(7)]), (2, &[Symbol::T(9), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(8), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(2), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(3), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(0), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::T(1), Symbol::NT(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 33] = [11, 11, 11, 11, 0, 11, 0, 0, 11, 11, 11, 11, 11, 11, 11, 1, 11, 2, 3, 11, 11, 11, 8, 9, 6, 7, 11, 10, 11, 11, 5, 4, 10];
    const FLAGS: [u32; 3] = [1536, 0, 12];
    const PARENT: [Option<VarId>; 3] = [None, None, Some(0)];
    const OPCODES: [&[OpCode]; 11] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::Exit(1), OpCode::T(5), OpCode::NT(0), OpCode::T(4)], &[OpCode::Exit(2), OpCode::T(6)], &[OpCode::Exit(3), OpCode::T(7)], &[OpCode::Loop(2), OpCode::Exit(4), OpCode::NT(1), OpCode::T(9)], &[OpCode::Loop(2), OpCode::Exit(5), OpCode::NT(1), OpCode::T(8)], &[OpCode::Loop(2), OpCode::Exit(6), OpCode::NT(1), OpCode::T(2)], &[OpCode::Loop(2), OpCode::Exit(7), OpCode::NT(1), OpCode::T(3)], &[OpCode::Loop(2), OpCode::Exit(8), OpCode::NT(1), OpCode::T(0)], &[OpCode::Loop(2), OpCode::Exit(9), OpCode::NT(1), OpCode::T(1)], &[OpCode::Exit(10)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener2]

    // E -> E : E | E ^ E | E / E | E * E | E - E | E + E | F
    // F -> ( E ) | NUM | ID
    //
    // E -> F E_1
    // F -> ( E ) | N | I
    // E_1 -> : F E_1 | ^ F E_1 | / F E_1 | * F E_1 | - F E_1 | + F E_1 | ε
    //
    //  0: E -> F E_1     | ►E_1 ◄0 ►F   | F
    //  1: F -> ( E )     | ◄1 ) ►E (    | E
    //  2: F -> N         | ◄2 N!        | N
    //  3: F -> I         | ◄3 I!        | I
    //  4: E_1 -> : F E_1 | ●E_1 ◄4 ►F : | E F
    //  5: E_1 -> ^ F E_1 | ●E_1 ◄5 ►F ^ | E F
    //  6: E_1 -> / F E_1 | ●E_1 ◄6 ►F / | E F
    //  7: E_1 -> * F E_1 | ●E_1 ◄7 ►F * | E F
    //  8: E_1 -> - F E_1 | ●E_1 ◄8 ►F - | E F
    //  9: E_1 -> + F E_1 | ●E_1 ◄9 ►F + | E F
    // 10: E_1 -> ε       | ◄10          |
    //
    //
    // NT flags:
    //  - E: parent_left_rec | parent_amb (1536)
    //  - E_1: child_left_rec | child_amb (12)
    // parents:
    //  - E_1 -> E

    pub enum CtxE {
        Dum { e: [SynE; 2] },
        Exp { e: [SynE; 2] },
        Div { e: [SynE; 2] },
        Mul { e: [SynE; 2] },
        Sub { e: [SynE; 2] },
        Add  { e: [SynE; 2] },
        F { f: SynE } }
    pub enum CtxF { E { e: SynE }, Num(String), Id(String) }

    enum SynValue { F(SynE), E_1(SynE), E(SynE) }

    impl std::fmt::Debug for SynValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                SynValue::F(e) => write!(f, "E({})", syn_e_str(e)),
                SynValue::E_1(e) => write!(f, "E_1({})", syn_e_str(e)),
                SynValue::E(e) => write!(f, "E({})", syn_e_str(e)),
            }
        }
    }

    impl SynValue {
        fn get_e(self) -> SynE {
            if let SynValue::E(val) = self { val } else { panic!() }
        }
        fn get_e_1(self) -> SynE {
            if let SynValue::E_1(val) = self { val } else { panic!() }
        }
        fn get_f(self) -> SynE {
            if let SynValue::F(val) = self { val } else { panic!() }
        }
    }

    #[derive(Debug, PartialEq)]
    enum AsmE { E, E_1_Dum, E_1_Exp, E_1_Div, E_1_Mul, E_1_Sub, E_1_Add, E_1_Empty }

    struct AsmItem {
        val: SynE,
        ty: AsmE,
    }

    impl std::fmt::Debug for AsmItem {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let e = &self.val;
            match self.ty {
                AsmE::E => write!(f, "E({})", syn_e_str(e)),
                AsmE::E_1_Dum => write!(f, "E_1(: {})", syn_e_str(e)),
                AsmE::E_1_Exp => write!(f, "E_1(^ {})", syn_e_str(e)),
                AsmE::E_1_Div => write!(f, "E_1(/ {})", syn_e_str(e)),
                AsmE::E_1_Mul => write!(f, "E_1(* {})", syn_e_str(e)),
                AsmE::E_1_Sub => write!(f, "E_1(- {})", syn_e_str(e)),
                AsmE::E_1_Add => write!(f, "E_1(+ {})", syn_e_str(e)),
                AsmE::E_1_Empty => write!(f, "E_1(ε)")
            }
        }
    }

    const LEFT_ASSOC_DUM: bool = true;
    const LEFT_ASSOC_EXP: bool = false;
    const LEFT_ASSOC_DIV: bool = true;
    const LEFT_ASSOC_MUL: bool = true;
    const LEFT_ASSOC_SUB: bool = true;
    const LEFT_ASSOC_ADD: bool = true;
    const LEFT_ASSOC_EMPTY: bool = true; // don't care as long as its priority is high enough to fold

    impl AsmE {
        fn is_left_assoc(&self) -> bool {
            match self {
                AsmE::E         => false,
                AsmE::E_1_Dum   => LEFT_ASSOC_DUM,
                AsmE::E_1_Exp   => LEFT_ASSOC_EXP,
                AsmE::E_1_Div   => LEFT_ASSOC_DIV,
                AsmE::E_1_Mul   => LEFT_ASSOC_MUL,
                AsmE::E_1_Sub   => LEFT_ASSOC_SUB,
                AsmE::E_1_Add   => LEFT_ASSOC_ADD,
                AsmE::E_1_Empty => LEFT_ASSOC_EMPTY,
            }
        }
    }

    const PRIORITY_MIN: u16 = 0;
    const PRIORITY_ADD: u16 = 1;
    const PRIORITY_SUB: u16 = 2;
    const PRIORITY_MUL: u16 = 3;
    const PRIORITY_DIV: u16 = 4;
    const PRIORITY_EXP: u16 = 5;
    const PRIORITY_DUM: u16 = 6;
    const PRIORITY_MAX: u16 = u16::MAX;
    const PRIORITY_EMPTY: u16 = PRIORITY_MIN;

    pub trait ExprListener {
        fn init_e(&mut self) {}
        fn init_f(&mut self, _factor_id: VarId) {}
        fn exit_e(&mut self, _ctx: CtxE) -> SynE;
        fn exit_f(&mut self, _ctx: CtxF) -> SynE;
    }

    // `Parser::parse_stream_hook` requires a type implementing `Listener`, but we can only implement
    // `Listener` on a local type, not as a blanket implementation on any type implementing `ExprListenerTrait`,
    // so we must have the `ListenerWrapper` wrapper type above.
    struct ListenerWrapper<T> {
        verbose: bool,
        listener: T,
        stack: Vec<SynValue>,
        asm_stack: Vec<(AsmItem, u16, bool)>, // item, priority, is_left_assoc
        max_stack: usize,
        max_asm_stack: usize,
        stack_t: Vec<String>
    }

    impl<T: ExprListener> ListenerWrapper<T> {
        pub fn new(listener: T, verbose: bool) -> Self {
            ListenerWrapper { verbose, listener, stack: Vec::new(), asm_stack: Vec::new(), max_stack: 0, max_asm_stack: 0, stack_t: Vec::new() }
        }

        pub fn listener(self) -> T {
            self.listener
        }
    }

    impl<T: ExprListener> Listener for ListenerWrapper<T> {
        fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
            if let Some(mut t_data) = t_data {
                self.stack_t.append(&mut t_data);
            }
            match call {
                Call::Enter => {
                    match nt {
                        0 => self.init_e(),
                        1 => self.listener.init_f(factor_id),
                        2 => {}
                        _ => panic!("unexpected exit nt: {nt}")
                    }
                }
                Call::Loop => {}
                Call::Exit => {
                    if self.verbose && nt == 2 {
                        println!("◄ {}", factor_str(factor_id, true));
                    }
                    match factor_id {
                        0 => self.init_e_1(),                                       //  0: E -> F E_1     | ►E_1 ◄0 ►F   | F
                        1 => self.exit_f1(),                                        //  1: F -> ( E )     | ◄1 ) ►E (    | E
                        2 => self.exit_f2(),                                        //  2: F -> N         | ◄2 N!        | N
                        3 => self.exit_f3(),                                        //  3: F -> I         | ◄3 I!        | I
                        4 => self.asm_e_1(factor_id, PRIORITY_DUM, LEFT_ASSOC_DUM), //  4: E_1 -> : F E_1 | ●E_1 ◄4 ►F : | E F
                        5 => self.asm_e_1(factor_id, PRIORITY_EXP, LEFT_ASSOC_EXP), //  5: E_1 -> ^ F E_1 | ●E_1 ◄5 ►F ^ | E F
                        6 => self.asm_e_1(factor_id, PRIORITY_DIV, LEFT_ASSOC_DIV), //  6: E_1 -> / F E_1 | ●E_1 ◄6 ►F / | E F
                        7 => self.asm_e_1(factor_id, PRIORITY_MUL, LEFT_ASSOC_MUL), //  7: E_1 -> * F E_1 | ●E_1 ◄7 ►F * | E F
                        8 => self.asm_e_1(factor_id, PRIORITY_SUB, LEFT_ASSOC_SUB), //  8: E_1 -> - F E_1 | ●E_1 ◄8 ►F - | E F
                        9 => self.asm_e_1(factor_id, PRIORITY_ADD, LEFT_ASSOC_ADD), //  9: E_1 -> + F E_1 | ●E_1 ◄9 ►F + | E F
                        10 => self.exit_e(),                                        // 10: E_1 -> ε       | ◄10          |
                        _ => panic!("unexpected exit factor id: {factor_id}")
                    }
                }
                Call::End => {
                    self.exit();
                }
            }
            self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
            self.max_asm_stack = std::cmp::max(self.max_asm_stack, self.asm_stack.len());
            if self.verbose {
                println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                println!("> asm_stack: {}", self.asm_stack.iter().map(|(it, p, l)| format!("{it:?}/{p}/{}", if *l { "L" } else { "R" })).join(", "));
            }
        }
    }

    impl<T: ExprListener> ListenerWrapper<T> {
        fn exit(&mut self) {
            // TODO:
        }

        fn fold_e_1(&mut self, priority: u16, mut is_left_assoc: bool) {
            // Folding the top two items while the priority of the top item is higher than the argument.
            // If left-associative, we allow folding items of the same priority, so we are sure that
            // the priority is always increasing towards the top of the stack. This allows us to fold
            // right- and left-associative items the same way (which we couldn't if two or more left-associative
            // items had the same priority).
            while self.asm_stack.len() > 1 && self.asm_stack.last().map(|(e, p, left)| e.ty != AsmE::E && (*p > priority || (*p == priority && is_left_assoc))).unwrap() {
                let (new, _, _) = self.asm_stack.pop().unwrap();
                let (top, _, _) = self.asm_stack.last_mut().unwrap();
                if self.verbose {
                    println!("- fold with priority {priority}/{}: {top:?} and {new:?}", if is_left_assoc { "L" } else { "R" });
                }
                match new.ty {
                    AsmE::E_1_Dum   => { top.val = self.listener.exit_e(CtxE::Dum { e: [top.val, new.val] }); }
                    AsmE::E_1_Exp   => { top.val = self.listener.exit_e(CtxE::Exp { e: [top.val, new.val] }); }
                    AsmE::E_1_Div   => { top.val = self.listener.exit_e(CtxE::Div { e: [top.val, new.val] }); }
                    AsmE::E_1_Mul   => { top.val = self.listener.exit_e(CtxE::Mul { e: [top.val, new.val] }); }
                    AsmE::E_1_Sub   => { top.val = self.listener.exit_e(CtxE::Sub { e: [top.val, new.val] }); }
                    AsmE::E_1_Add   => { top.val = self.listener.exit_e(CtxE::Add { e: [top.val, new.val] }); }
                    AsmE::E_1_Empty => { },
                    // we must never pop AsmE::E here, so we must ignore its case
                    _ => panic!()
                }
                if self.verbose {
                    println!("-> {top:?}");
                }
                is_left_assoc = top.ty.is_left_assoc();
            }
        }

        fn init_e(&mut self) {
            // stopper for this expression (PRIORITY_MIN and right-associativity means it will never be merged)
            self.listener.init_e();
            self.asm_stack.push((AsmItem { val: None, ty: AsmE::E}, PRIORITY_MIN, false));
        }

        fn init_e_1(&mut self) {
            // F of E -> F E_1 is now on the stack => attach it
            let new_f = self.stack.pop().unwrap().get_f();
            // child_amb, so promoting the value:
            let mut new_e = self.listener.exit_e(CtxE::F { f: new_f });
            let top = &mut self.asm_stack.last_mut().unwrap().0;
            assert_eq!(top.ty, AsmE::E);
            assert_eq!(top.val, None);
            if self.verbose { println!("◄ 0, attach {} to E", syn_e_str(&new_e)); }
            top.val = new_e;
        }

        // left_rec/ambig, E : E | E ^ E | E / E | E * E | E - E | E + E | F
        // - 0: E -> F E_1
        fn exit_e(&mut self) {
            // child_amb e_1:
            self.fold_e_1(PRIORITY_MIN, false);
            let (e, _, _) = self.asm_stack.pop().expect("E should be on top of the stack");
            assert_eq!(e.ty, AsmE::E, "the top of the stack should be E instead of {e:?}");
            self.stack.push(SynValue::E(e.val));
        }

        // child_left_rec, child_amb
        fn asm_e_1(&mut self, factor_id: VarId, priority: u16, is_left_assoc: bool) {
            self.fold_e_1(priority, is_left_assoc);
            // child_amb, so promoting the value:
            let new_f = self.stack.pop().unwrap().get_f();
            let mut new_e = self.listener.exit_e(CtxE::F { f: new_f });
            let r = match factor_id {
                4 => AsmItem { val: new_e, ty: AsmE::E_1_Dum },
                5 => AsmItem { val: new_e, ty: AsmE::E_1_Exp },
                6 => AsmItem { val: new_e, ty: AsmE::E_1_Div },
                7 => AsmItem { val: new_e, ty: AsmE::E_1_Mul },
                8 => AsmItem { val: new_e, ty: AsmE::E_1_Sub },
                9 => AsmItem { val: new_e, ty: AsmE::E_1_Add },
                _ => panic!()
            };
            self.asm_stack.push((r, priority, is_left_assoc));
        }

        fn exit_f1(&mut self) {
            let ctx = CtxF::E { e: self.stack.pop().unwrap().get_e() };
            self.stack.push(SynValue::F(self.listener.exit_f(ctx)));
        }

        fn exit_f2(&mut self) {
            let ctx = CtxF::Num(self.stack_t.pop().unwrap());
            self.stack.push(SynValue::F(self.listener.exit_f(ctx)));
        }

        fn exit_f3(&mut self) {
            let ctx = CtxF::Id(self.stack_t.pop().unwrap());
            self.stack.push(SynValue::F(self.listener.exit_f(ctx)));
        }
    }

    // User code -----------------------------------------------------

    type SynE = Option<i64>;
    type SynF = Option<i64>;

    fn syn_e_str(e: &SynE) -> String {
        if let Some(v) = e {
            v.to_string()
        } else {
            "?".to_string()
        }
    }

    struct TestListener {
        vars: HashMap<String, i64>,
        result: Option<i64>,
        verbose: bool
    }

    impl TestListener {
        pub fn new(verbose: bool) -> Self {
            Self { vars: HashMap::new(), result: None, verbose }
        }
    }

    fn factor_str(factor_id: VarId, nt: bool) -> String {
        match factor_id {
             0 => if nt { "E -> F E_1"     } else { "F E_1"   },
             1 => if nt { "F -> ( E )"     } else { "( E )"   },
             2 => if nt { "F -> N"         } else { "N"       },
             3 => if nt { "F -> I"         } else { "I"       },
             4 => if nt { "E_1 -> : F E_1" } else { ": F E_1" },
             5 => if nt { "E_1 -> ^ F E_1" } else { "^ F E_1" },
             6 => if nt { "E_1 -> / F E_1" } else { "/ F E_1" },
             7 => if nt { "E_1 -> * F E_1" } else { "* F E_1" },
             8 => if nt { "E_1 -> - F E_1" } else { "- F E_1" },
             9 => if nt { "E_1 -> + F E_1" } else { "+ F E_1" },
            10 => if nt { "E_1 -> ε"       } else { "ε"       },
            _ => panic!()
        }.to_string()
    }

    impl ExprListener for TestListener {

        fn init_e(&mut self) {
            if self.verbose {
                println!("► E");
            }
            self.result = None;
        }

        fn init_f(&mut self, factor_id: VarId) {
            if self.verbose { println!("► F -> {}", factor_str(factor_id, false)); }
        }

        fn exit_e(&mut self, ctx: CtxE) -> SynE {
            let value = match &ctx {
                CtxE::Dum { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        Some(i64::max(*e0, *e1))
                    } else {
                        None
                    }
                }
                CtxE::Exp { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        if *e1 <= u32::MAX as i64 {
                            e0.checked_pow(*e1 as u32)
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }
                CtxE::Div { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_div(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Mul { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_mul(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Sub { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_sub(*e1)
                    } else {
                        None
                    }
                }
                CtxE::Add { e } => {
                    if let [Some(e0), Some(e1)] = e {
                        e0.checked_add(*e1)
                    } else {
                        None
                    }
                }
                CtxE::F { f } => *f,
            };
            if self.verbose {
                let output = match ctx {
                    CtxE::Dum { e } => format!("◄ E={:?} : {:?}={value:?}", e[0], e[1]),
                    CtxE::Exp { e } => format!("◄ E={:?} ^ {:?}={value:?}", e[0], e[1]),
                    CtxE::Div { e } => format!("◄ E={:?} / {:?}={value:?}", e[0], e[1]),
                    CtxE::Mul { e } => format!("◄ E={:?} * {:?}={value:?}", e[0], e[1]),
                    CtxE::Sub { e } => format!("◄ E={:?} - {:?}={value:?}", e[0], e[1]),
                    CtxE::Add { e } => format!("◄ E={:?} + {:?}={value:?}", e[0], e[1]),
                    CtxE::F { f } => format!("◄ E=F={value:?}"),
                };
                println!("{output}");
            }
            self.result = value;
            value
        }

        fn exit_f(&mut self, ctx: CtxF) -> SynE {
            let value = match &ctx {
                CtxF::E { e } => *e,
                CtxF::Num(s) => i64::from_str(s).ok(),
                CtxF::Id(s) => self.vars.get(s).cloned(),
            };
            if self.verbose {
                let output = match ctx {
                    CtxF::E { .. } => format!("◄ F=E={value:?}"),
                    CtxF::Num(n) => format!("◄ F=NUM #{n}={value:?}"),
                    CtxF::Id(i) => format!("◄ F=ID '{i}'={value:?}"),
                };
                println!("{output}");
            }
            value
        }
    }

    #[test]
    fn parser_parse_stream() {
        let tests = vec![
            // left
            ("2+3*4*5", true, Some(62)),    // priority high-low-high (assembly)
            ("1+2+3+4+5+6+7+8+9", true, Some(45)),  // parser stack accumulation
            ("2*3+4*5", true, Some(26)),    // priority high-low-high (assembly)
            ("2+3*4+5", true, Some(19)),    // priority low-high-low (assembly)
            ("a+2*b", true, Some(50)),
            ("a*(4+5)", true, Some(90)),
            ("1*2*3*4", true, Some(24)),
            ("1+2+3+4", true, Some(10)),
            ("(1)", true, Some(1)),
            ("((5))", true, Some(5)),
            // right
            ("2^3", true, Some(8)),
            ("4^3^2", true, Some(262144)),
            // both left and right
            ("5+3*2^8-3-2+1", true, Some(769)),
            ("5:3:2^2", true, Some(25)),
            ("5:(2^4-3*(3))", true, Some(7)),
            // undef
            ("z", true, None),
            ("5*z+y", true, None),
            // errors
            ("a*(4+5", false, None),
            ("a b", false, None),
            ("a++", false, None),
        ];
        const VERBOSE: bool = false;
        const VERBOSE_LISTENER: bool = false;
        let mut parser = build_parser();

        // The lexer provides the required stream, so this isn't necessary in a real case:
        let mut symb_table = SymbolTable::new();
        symb_table.extend_terminals(SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
        let symbols = (0..SYMBOLS_T.len() as TokenId)
            .map(|t| Symbol::T(t))
            .map(|s| (s.to_str(Some(&symb_table)), s))
            .collect::<HashMap<_, _>>();
        for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
            if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
            let stream = input.chars().into_iter().filter_map(|c| {
                if c.is_ascii_whitespace() {
                    None
                } else {
                    let c_str = c.to_string();
                    Some(match c {
                        '0'..='9' => (Symbol::T(6), c_str),
                        'a'..='z' => (Symbol::T(7), c_str),
                        _ => {
                            if let Some(s) = symbols.get(&c_str) {
                                // println!("stream: '{}' -> sym!({})", c, symbol_to_macro(s));
                                (*s, c_str)
                            } else {
                                panic!("unrecognized test input '{c}' in test {test_id}, input {input}");
                            }
                        }
                    })
                }
            });

            // User code under test ------------------------------

            let mut listener = TestListener::new(VERBOSE_LISTENER);
            listener.vars.extend([
                ("a".to_string(), 10),
                ("b".to_string(), 20),
                ("c".to_string(), 30),
            ]);
            let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
            let success = match parser.parse_stream(&mut wrapper, stream) {
                Ok(_) => {
                    if VERBOSE { println!("parsing completed successfully"); }
                    true
                }
                Err(e) => {
                    if VERBOSE { println!("parsing failed: {e}"); }
                    false
                }
            };
            if VERBOSE {
                println!("max stack: {}\nmax asm_stack: {}", wrapper.max_stack, wrapper.max_asm_stack);
                println!("listener stack: {:?}", wrapper.stack);
                println!("listener asm_stack: {:?}", wrapper.asm_stack);
            }
            let listener = wrapper.listener();
            // ---------------------------------------------------

            assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
            if VERBOSE { println!("listener data: {:?}", listener.result); }
            if success {
                assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
            }
        }
    }
}

#[allow(unused)]
mod listener3 {
    // [write_source_code_for_integration_listener3]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 6;
    const PARSER_NUM_NT: usize = 2;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("struct", Some("struct")), ("{", Some("{")), ("}", Some("}")), (":", Some(":")), (";", Some(";")), ("id", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["STRUCT", "LIST"];
    const SYMBOLS_NAMES: [(&str, VarId); 0] = [];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 3] = [(0, &[Symbol::T(0), Symbol::T(5), Symbol::T(1), Symbol::NT(1)]), (1, &[Symbol::T(5), Symbol::T(3), Symbol::T(5), Symbol::T(4), Symbol::NT(1)]), (1, &[Symbol::T(2)])];
    const PARSING_TABLE: [FactorId; 14] = [0, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 1, 3];
    const FLAGS: [u32; 2] = [0, 2];
    const PARENT: [Option<VarId>; 2] = [None, None];
    const OPCODES: [&[OpCode]; 3] = [&[OpCode::Exit(0), OpCode::NT(1), OpCode::T(1), OpCode::T(5), OpCode::T(0)], &[OpCode::Exit(1), OpCode::NT(1), OpCode::T(4), OpCode::T(5), OpCode::T(3), OpCode::T(5)], &[OpCode::Exit(2), OpCode::T(2)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener3]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // STRUCT -> 'struct' id '{' LIST
        // LIST -> id ':' id ';' LIST | '}'
        //
        //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
        //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id LIST
        //  2: LIST -> }                  | ◄2 }                  |
        //
        // - NT flags:
        //   - LIST: right_rec (2)
        // - parents:
        //   - (nothing)

        #[derive(Debug)]
        pub enum Ctx { Struct(SynStruct) }
        #[derive(Debug)]
        pub enum CtxStruct { Struct { id: String, list: SynList } }
        #[derive(Debug)]
        pub enum CtxList { List1 { id: [String; 2], list: SynList }, List2 }

        // SynStruct, SynList: defined by user below

        #[derive(Debug)]
        enum SynValue { Struct(SynStruct), List(SynList) }

        impl SynValue {
            fn get_struct(self) -> SynStruct {
                if let SynValue::Struct(val) = self { val } else { panic!() }
            }

            fn get_list(self) -> SynList {
                if let SynValue::List(val) = self { val } else { panic!() }
            }
        }

        pub trait StructListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_struct(&mut self) {}
            fn init_list(&mut self) {}
            fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
            fn exit_list(&mut self, _ctx: CtxList) -> SynList;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StructListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StructListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_struct(),   // STRUCT
                            1 => self.listener.init_list(),     // LIST
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_struct(),    //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                            1 => self.exit_list1(),     //  1: LIST -> id : id ; LIST     | ◄1 ►LIST ; id! : id!  | id id LIST
                            2 => self.exit_list2(),     //  2: LIST -> }                  | ◄2 }                  |
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StructListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let val = self.stack.pop().unwrap().get_struct();
                self.listener.exit(Ctx::Struct(val));
            }

            fn exit_struct(&mut self) {
                let list = self.stack.pop().unwrap().get_list();
                let id = self.stack_t.pop().unwrap();
                let val = self.listener.exit_struct(CtxStruct::Struct { id, list });
                self.stack.push(SynValue::Struct(val));
            }

            fn exit_list1(&mut self) {
                let list = self.stack.pop().unwrap().get_list();
                let id2 = self.stack_t.pop().unwrap();
                let id1 = self.stack_t.pop().unwrap();
                let val = self.listener.exit_list(CtxList::List1 { id: [id1, id2], list });
                self.stack.push(SynValue::List(val));
            }

            fn exit_list2(&mut self) {
                let val = self.listener.exit_list(CtxList::List2);
                self.stack.push(SynValue::List(val));
            }
        }

        // User code -----------------------------------------------------

        type SynStruct = (String, Vec<(String, String)>);
        type SynList = Vec<(String, String)>;

        struct TestListener {
            result: HashMap<String, Vec<(String, String)>>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: HashMap::new(), verbose }
            }
        }

        impl StructListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::Struct((struct_name, list)) = ctx;
                self.result.insert(struct_name, list);
            }

            fn init_struct(&mut self) {
                if self.verbose { println!("► struct"); }
            }

            fn init_list(&mut self) {
                if self.verbose { println!("► list"); }
            }

            fn exit_struct(&mut self, ctx: CtxStruct) -> SynStruct {
                if self.verbose { println!("◄ struct (ctx = {ctx:?})"); }
                match ctx {
                    CtxStruct::Struct { id, mut list } => {
                        list.reverse();
                        (id, list)
                    }
                }
            }

            fn exit_list(&mut self, ctx: CtxList) -> SynList {
                if self.verbose { println!("◄ list (ctx = {ctx:?})"); }
                match ctx {
                    CtxList::List1 { id: [a, b], mut list } => {
                        list.push((a, b));
                        list
                    }
                    CtxList::List2 => vec![]
                }
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "struct test1 { a : int ; b : string ; c : bool ; }",
                    true,
                    ("test1", vec![("a", "int"), ("b", "string"), ("c", "bool")])
                ),
                (
                    "struct test2 { }",
                    true,
                    ("test2", vec![])
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(5), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let err_msg = format!("test {test_id} failed for input {input}");
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    let result = listener.result.into_iter().last().expect(&err_msg);
                    let expected_result = (expected_result.0.to_string(), expected_result.1.into_iter().map(|(s1, s2)| (s1.to_string(), s2.to_string())).to_vec());
                    assert_eq!(result, expected_result, "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener4 {
    // [write_source_code_for_integration_listener4]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 6;
    const PARSER_NUM_NT: usize = 2;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("struct", Some("struct")), ("{", Some("{")), ("}", Some("}")), (":", Some(":")), (";", Some(";")), ("id", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["STRUCT", "LIST"];
    const SYMBOLS_NAMES: [(&str, VarId); 0] = [];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 3] = [(0, &[Symbol::T(0), Symbol::T(5), Symbol::T(1), Symbol::NT(1)]), (1, &[Symbol::T(5), Symbol::T(3), Symbol::T(5), Symbol::T(4), Symbol::NT(1)]), (1, &[Symbol::T(2)])];
    const PARSING_TABLE: [FactorId; 14] = [0, 3, 3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 1, 3];
    const FLAGS: [u32; 2] = [0, 130];
    const PARENT: [Option<VarId>; 2] = [None, None];
    const OPCODES: [&[OpCode]; 3] = [&[OpCode::Exit(0), OpCode::NT(1), OpCode::T(1), OpCode::T(5), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(4), OpCode::T(5), OpCode::T(3), OpCode::T(5)], &[OpCode::Exit(2), OpCode::T(2)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener4]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // STRUCT -> 'struct' id '{' LIST
        // LIST -> <L> id ':' id ';' LIST | '}'
        //
        //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
        //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | LIST id id
        //  2: LIST -> }                  | ◄2 }                  | LIST
        //
        // - NT flags:
        //   - LIST: right_rec | L-form (130)
        // - parents:            ^^^^^^
        //   - (nothing)

        #[derive(Debug)]
        pub enum Ctx { Struct(SynStruct) }
        #[derive(Debug)]
        pub enum CtxStruct { Struct { id: String, list: SynList } }
        #[derive(Debug)]
        pub enum CtxList { List1 { id: [String; 2], list: SynList }, List2 { list: SynList } }

        // SynStruct, SynList: defined by user below

        #[derive(Debug)]
        enum SynValue { Struct(SynStruct), List(SynList) }

        impl SynValue {
            fn get_struct(self) -> SynStruct {
                if let SynValue::Struct(val) = self { val } else { panic!() }
            }
            fn get_list(self) -> SynList {
                if let SynValue::List(val) = self { val } else { panic!() }
            }
        }

        pub trait StructListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_struct(&mut self) {}
            fn init_list(&mut self) -> SynList;
            fn exit_struct(&mut self, _ctx: CtxStruct) -> SynStruct;
            fn iter_list(&mut self, _ctx: CtxList) -> SynList;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StructListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StructListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_struct(),   // STRUCT
                            1 => self.init_list(),              // LIST
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_struct(),    //  0: STRUCT -> struct id { LIST | ◄0 ►LIST { id! struct | id LIST
                            1 => self.exit_list1(),     //  1: LIST -> id : id ; LIST     | ●LIST ◄1 ; id! : id!  | LIST id id
                            2 => self.exit_list2(),     //  2: LIST -> }                  | ◄2 }                  | LIST
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StructListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let val = self.stack.pop().unwrap().get_struct();
                self.listener.exit(Ctx::Struct(val));
            }

            fn init_list(&mut self)  {
                let val = self.listener.init_list();
                self.stack.push(SynValue::List(val));
            }

            fn exit_struct(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let list = self.stack.pop().unwrap().get_list();
                let val = self.listener.exit_struct(CtxStruct::Struct { id, list });
                self.stack.push(SynValue::Struct(val));
            }

            fn exit_list1(&mut self) {
                let id2 = self.stack_t.pop().unwrap();
                let id1 = self.stack_t.pop().unwrap();
                let list = self.stack.pop().unwrap().get_list();
                let val = self.listener.iter_list(CtxList::List1 { id: [id1, id2], list });
                self.stack.push(SynValue::List(val));
            }

            fn exit_list2(&mut self) {
                let list = self.stack.pop().unwrap().get_list();
                let val = self.listener.iter_list(CtxList::List2 { list });
                self.stack.push(SynValue::List(val));
            }
        }

        // User code -----------------------------------------------------

        type SynStruct = String;
        #[derive(Debug)]
        pub struct SynList(u32);

        struct TestListener {
            result: HashMap<String, Vec<(String, String)>>,
            cur_list: Option<Vec<(String, String)>>,
            max_list_length: Option<u32>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: HashMap::new(), cur_list: None, max_list_length: None, verbose }
            }
        }

        impl StructListener for TestListener {
            fn exit(&mut self, _ctx: Ctx) {
                self.max_list_length = self.result.iter().map(|x| x.1.len() as u32).max();
            }

            fn init_struct(&mut self) {
                if self.verbose { println!("► struct"); }
            }

            fn init_list(&mut self) -> SynList {
                if self.verbose { println!("► list"); }
                self.cur_list = Some(Vec::new());
                SynList(0)
            }

            fn exit_struct(&mut self, ctx: CtxStruct) -> SynStruct {
                if self.verbose { println!("◄ struct (ctx = {ctx:?})"); }
                match ctx {
                    CtxStruct::Struct { id, list: list_meta } => {
                        let list = self.cur_list.take().unwrap();
                        self.result.insert(id.clone(), list);
                        id
                    }
                }
            }

            fn iter_list(&mut self, ctx: CtxList) -> SynList {
                if self.verbose { println!("◄ list (ctx = {ctx:?})"); }
                match ctx {
                    CtxList::List1 { id: [a, b], list } => {
                        self.cur_list.as_mut().unwrap().push((a, b));
                        SynList(list.0 + 1)
                    }
                    CtxList::List2 { list } => list,
                }
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "struct test1 { a : int ; b : string ; c : bool ; }",
                    true,
                    ("test1", vec![("a", "int"), ("b", "string"), ("c", "bool")], Some(3))
                ),
                (
                    "struct test2 { }",
                    true,
                    ("test2", vec![], Some(0))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(5), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let err_msg = format!("test {test_id} failed for input {input}");
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    let result = listener.result.into_iter().last().expect(&err_msg);
                    let expected_max_length = expected_result.2;
                    let expected_result = (expected_result.0.to_string(), expected_result.1.into_iter().map(|(s1, s2)| (s1.to_string(), s2.to_string())).to_vec());
                    assert_eq!(result, expected_result, "{err_msg}");
                    assert_eq!(listener.max_list_length, expected_max_length, "test {test_id} failed for input {input}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener5 {
    // [write_source_code_for_integration_listener5]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 2;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [(".", Some(".")), ("id", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 4] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(1)]), (2, &[Symbol::T(0), Symbol::T(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 9] = [4, 0, 4, 4, 1, 4, 2, 4, 3];
    const FLAGS: [u32; 3] = [512, 0, 4];
    const PARENT: [Option<VarId>; 3] = [None, None, Some(0)];
    const OPCODES: [&[OpCode]; 4] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::Exit(1), OpCode::T(1)], &[OpCode::Loop(2), OpCode::Exit(2), OpCode::T(1), OpCode::T(0)], &[OpCode::Exit(3)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener5]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // E -> F | E . id
        // F -> id
        //
        //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
        //  1: F -> id         | ◄1 id!        | id
        //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | E id
        //  3: E_1 -> ε        | ◄3            |
        //
        // NT flags:
        //  - E: parent_left_rec (512)
        //  - E_1: child_left_rec (4)
        // parents:
        //  - E_1 -> E

        #[derive(Debug)]
        pub enum Ctx { E { e: SynE } }
        #[derive(Debug)]
        pub enum CtxE { E_Id { e: SynE, id: String }, F { f: SynF }, E { e: SynE } }
        #[derive(Debug)]
        pub enum CtxF { F { id: String } }

        // SynE, SynF: defined by user below

        #[derive(Debug)]
        enum SynValue { E(SynE), F(SynF) }

        impl SynValue {
            fn get_e(self) -> SynE {
                if let SynValue::E(val) = self { val } else { panic!() }
            }
            fn get_f(self) -> SynF {
                if let SynValue::F(val) = self { val } else { panic!() }
            }
        }

        pub trait ExprListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_e(&mut self) {}
            fn init_f(&mut self) {}
            fn exit_e(&mut self, _ctx: CtxE) -> SynE;
            fn exit_f(&mut self, _ctx: CtxF) -> SynF;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: ExprListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_e(),    // E
                            1 => self.listener.init_f(),    // F
                            2 => {}                         // E_1
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.init_e_1(),   //  0: E -> F E_1      | ►E_1 ◄0 ►F    | F
                            1 => self.exit_f(),     //  1: F -> id         | ◄1 id!        | id
                            2 => self.exit_e_1(),   //  2: E_1 -> . id E_1 | ●E_1 ◄2 id! . | E id
                            3 => self.exit_e(),     //  3: E_1 -> ε        | ◄3            |
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                // self.max_asm_stack = std::cmp::max(self.max_asm_stack, self.asm_stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                self.listener.exit(Ctx::E { e });
            }

            fn init_e_1(&mut self) {
                let f = self.stack.pop().unwrap().get_f();
                let val = self.listener.exit_e(CtxE::F { f });
                self.stack.push(SynValue::E(val));
            }

            fn exit_f(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let val = self.listener.exit_f(CtxF::F { id });
                self.stack.push(SynValue::F(val));
            }

            fn exit_e_1(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let e = self.stack.pop().unwrap().get_e();
                let val = self.listener.exit_e(CtxE::E_Id { e, id });
                self.stack.push(SynValue::E(val));
            }

            fn exit_e(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                let val = self.listener.exit_e(CtxE::E { e });
                self.stack.push(SynValue::E(val));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug)]
        pub enum SynE {
            Tmp(Vec<String>),
            Final(String)
        }

        #[derive(Debug)]
        pub struct SynF(String);

        struct TestListener {
            result: Option<String>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl ExprListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                if let Ctx::E { e: SynE::Final(e) } = ctx {
                    self.result = Some(e);
                } else {
                    panic!("unexpected final context {ctx:?}");
                }
            }

            fn init_e(&mut self) {
                if self.verbose { println!("► E"); }
            }

            fn init_f(&mut self) {
                if self.verbose { println!("► F"); }
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                if self.verbose { println!("◄ E (ctx = {ctx:?})"); }
                match ctx {
                    CtxE::E_Id { e: SynE::Tmp(mut e), id } => {
                        e.push(id);
                        SynE::Tmp(e)
                    },
                    CtxE::F { f } => {
                        SynE::Tmp(vec![f.0])
                    }
                    CtxE::E { e: SynE::Tmp(e) } => {
                        SynE::Final(e.join(""))
                    }
                    _ => panic!("unexpected context {ctx:?}")
                }
            }

            fn exit_f(&mut self, ctx: CtxF) -> SynF {
                if self.verbose { println!("◄ list (ctx = {ctx:?})"); }
                let CtxF::F { id } = ctx;
                SynF(id)
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a . b . c . d",
                    true,
                    (Some("abcd"))
                ),
                (
                    "a",
                    true,
                    (Some("a"))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let listener = wrapper.listener();
                    let expected_result = expected_result.map(|s| s.to_string());
                    assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener6 {
    // [write_source_code_for_integration_listener6]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 4;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [(".", Some(".")), ("id", None), ("(", Some("(")), (")", Some(")"))];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1", "E_2"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("E_1", 2), ("E_2", 3)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 6] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (1, &[Symbol::T(1)]), (2, &[Symbol::T(0), Symbol::T(1), Symbol::NT(3)]), (2, &[Symbol::Empty]), (3, &[Symbol::T(2), Symbol::T(3), Symbol::NT(2)]), (3, &[Symbol::NT(2)])];
    const PARSING_TABLE: [FactorId; 20] = [6, 0, 6, 6, 6, 6, 1, 6, 6, 6, 2, 6, 6, 6, 3, 5, 6, 4, 6, 5];
    const FLAGS: [u32; 4] = [512, 0, 36, 64];
    const PARENT: [Option<VarId>; 4] = [None, None, Some(0), Some(2)];
    const OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::Exit(1), OpCode::T(1)], &[OpCode::NT(3), OpCode::T(1), OpCode::T(0)], &[OpCode::Exit(3)], &[OpCode::Loop(2), OpCode::Exit(4), OpCode::T(3), OpCode::T(2)], &[OpCode::Loop(2), OpCode::Exit(5)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener6]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // E -> F | E . id | E . id ( )
        // F -> id
        //
        //  0: E -> F E_1      | ►E_1 ◄0 ►F  | F
        //  1: F -> id         | ◄1 id!      | id
        //  2: E_1 -> . id E_2 | ►E_2 id! .  |
        //  3: E_1 -> ε        | ◄3          |
        //  4: E_2 -> ( ) E_1  | ●E_1 ◄4 ) ( | id E
        //  5: E_2 -> E_1      | ●E_1 ◄5     | id E
        //
        // NT flags:
        //  - E: parent_left_rec (512)
        //  - E_1: child_left_rec | parent_left_fact (36)
        //  - E_2: child_left_fact (64)
        // parents:
        //  - E_1 -> E
        //  - E_2 -> E_1

        #[derive(Debug)]
        pub enum Ctx {
            /// Rule `E -> F | E . id | E . id ( )`
            E { e: SynE }
        }
        #[derive(Debug)]
        pub enum CtxE {
            /// Factor `E -> E . id`
            E_Id { e: SynE, id: String },
            /// Factor `E -> E . id ( )`
            E_Id_par { e: SynE, id: String },
            /// Factor `E -> F`
            F { f: SynF },
            /// end of loop
            E { e: SynE },
        }
        #[derive(Debug)]
        pub enum CtxF {
            /// Factor `F -> id`
            F { id: String }
        }

        // SynE, SynF: defined by user below

        #[derive(Debug)]
        enum SynValue { E(SynE), F(SynF) }

        impl SynValue {
            fn get_e(self) -> SynE {
                if let SynValue::E(val) = self { val } else { panic!() }
            }
            fn get_f(self) -> SynF {
                if let SynValue::F(val) = self { val } else { panic!() }
            }
        }

        pub trait ExprListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_e(&mut self) {}
            fn init_f(&mut self) {}
            fn exit_e(&mut self, _ctx: CtxE) -> SynE;
            fn exit_f(&mut self, _ctx: CtxF) -> SynF;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: ExprListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_e(),
                            1 => self.listener.init_f(),
                            2 => {}
                            3 => {}
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.init_e_1(),               //  0: E -> F E_1      | ►E_1 ◄0 ►F  | F
                            1 => self.exit_f(),                 //  1: F -> id         | ◄1 id!      | id
                            /* no exit */                       //  2: E_1 -> . id E_2 | ►E_2 id! .  |
                            3 => self.exit_e(),                 //  3: E_1 -> ε        | ◄3          |
                            4 |                                 //  4: E_2 -> ( ) E_1  | ●E_1 ◄4 ) ( | id E
                            5 => self.exit_e_2(factor_id),      //  5: E_2 -> E_1      | ●E_1 ◄5     | id E
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                self.listener.exit(Ctx::E { e });
            }

            fn init_e_1(&mut self) {
                let f = self.stack.pop().unwrap().get_f();
                let val = self.listener.exit_e(CtxE::F { f });
                self.stack.push(SynValue::E(val));
            }

            fn exit_f(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let val = self.listener.exit_f(CtxF::F { id });
                self.stack.push(SynValue::F(val));
            }

            fn exit_e_2(&mut self, factor_id: VarId) {
                let e = self.stack.pop().unwrap().get_e();
                let id = self.stack_t.pop().unwrap();
                let ctx = match factor_id {
                    4 => CtxE::E_Id_par { e, id },
                    5 => CtxE::E_Id { e, id },
                    _ => panic!()
                };
                let val = self.listener.exit_e(ctx);
                self.stack.push(SynValue::E(val));
            }

            fn exit_e(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                let val = self.listener.exit_e(CtxE::E { e });
                self.stack.push(SynValue::E(val));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug)]
        pub struct SynE(Vec<String>);
        #[derive(Debug)]
        pub struct SynF(String);

        struct TestListener {
            result: Option<Vec<String>>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl ExprListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::E { e } = ctx;
                self.result = Some(e.0);
            }

            fn init_e(&mut self) {
                if self.verbose { println!("► E"); }
            }

            fn init_f(&mut self) {
                if self.verbose { println!("► F"); }
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                if self.verbose { println!("◄ E (ctx = {ctx:?})"); }
                match ctx {
                    CtxE::F { f } => {
                        SynE(vec![f.0])
                    }
                    CtxE::E_Id_par { mut e, mut id } => {
                        id.push_str("()");
                        e.0.push(id);
                        e
                    }
                    CtxE::E_Id { mut e, id } => {
                        e.0.push(id);
                        e
                    }
                    CtxE::E { mut e } => {
                        e.0.push("".to_string());
                        e
                    }
                }
            }

            fn exit_f(&mut self, ctx: CtxF) -> SynF {
                if self.verbose { println!("◄ list (ctx = {ctx:?})"); }
                let CtxF::F { id } = ctx;
                SynF(id)
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a . b . c ( ) . d",
                    true,
                    (Some(vec!["a", "b", "c()", "d", ""]))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let listener = wrapper.listener();
                    let expected_result = expected_result.map(|v| v.into_iter().map(|s| s.to_string()).to_vec());
                    assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener7 {
    // [write_source_code_for_integration_listener7]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 2;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "A_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("A_1", 1)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 3] = [(0, &[Symbol::T(0), Symbol::NT(1), Symbol::T(2)]), (1, &[Symbol::T(1), Symbol::NT(1)]), (1, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 8] = [0, 3, 3, 3, 3, 1, 2, 3];
    const FLAGS: [u32; 2] = [2048, 1];
    const PARENT: [Option<VarId>; 2] = [None, Some(0)];
    const OPCODES: [&[OpCode]; 3] = [&[OpCode::Exit(0), OpCode::T(2), OpCode::NT(1), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(1)], &[OpCode::Exit(2)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener7]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::{hashmap, s};
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // A -> a (b)* c
        //
        //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c   // !
        //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | A_1 b     // !
        //  2: A_1 -> ε     | ◄2            |           //
        //
        // NT flags:
        //  - A: parent_+_or_* (2048)
        //  - A_1: child_+_or_* (1)
        // parents:
        //  - A_1 -> A

        #[derive(Debug)]
        pub enum Ctx {
            A(SynA)
        }

        #[derive(Debug)]
        pub enum CtxA {
            /// Factor `A -> a (b)* c`
            A { a: String, b: Vec<String>, c: String },
        }

        // SynA: defined by user below

        #[derive(Debug)]
        struct SynAStar(Vec<String>);

        #[derive(Debug)]
        enum SynValue { A(SynA), AStar(SynAStar) }

        impl SynValue {
            fn get_a(self) -> SynA {
                if let SynValue::A(val) = self { val } else { panic!() }
            }
            fn get_a_star(self) -> SynAStar {
                if let SynValue::AStar(val) = self { val } else { panic!() }
            }
        }

        pub trait StarListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StarListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StarListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),
                            1 => self.init_a_1(),
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_a(),     //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c   // !
                            1 => self.exit_a_1(),   //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | A_1 b     // !
                            2 => { },               //  2: A_1 -> ε     | ◄2            |           //
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StarListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A(a));
            }

            fn init_a_1(&mut self) {
                let a_star = SynAStar(Vec::new());
                self.stack.push(SynValue::AStar(a_star));
            }

            fn exit_a(&mut self) {
                let c = self.stack_t.pop().unwrap();
                let b = self.stack.pop().unwrap().get_a_star().0;
                let a = self.stack_t.pop().unwrap();
                let val = self.listener.exit_a(CtxA::A { a, b, c });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_1(&mut self) {
                let b = self.stack_t.pop().unwrap();
                let mut a_star = self.stack.pop().unwrap().get_a_star();
                a_star.0.push(b);
                self.stack.push(SynValue::AStar(a_star));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug, PartialEq)]
        pub struct SynA { a: String, b: Vec<String>, c: String }

        struct TestListener {
            result: Option<SynA>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl StarListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A(a) = ctx;
                self.result = Some(a);
            }

            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A"); }
                let CtxA::A { a, b, c } = ctx;
                SynA { a, b, c}
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a b b c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![s!("b"), s!("b")], c: s!("c")}))
                ),
                (
                    "a c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![], c: s!("c")}))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                let err_msg = format!("test {test_id} failed for input {input}");
                assert_eq!(success, expected_success, "{err_msg}");
                if success {
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    assert_eq!(listener.result, expected_result, "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener8 {
    // [write_source_code_for_integration_listener8]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 2;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "A_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("A_1", 1)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 3] = [(0, &[Symbol::T(0), Symbol::NT(1), Symbol::T(2)]), (1, &[Symbol::T(1), Symbol::NT(1)]), (1, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 8] = [0, 3, 3, 3, 3, 1, 2, 3];
    const FLAGS: [u32; 2] = [2048, 129];
    const PARENT: [Option<VarId>; 2] = [None, Some(0)];
    const OPCODES: [&[OpCode]; 3] = [&[OpCode::Exit(0), OpCode::T(2), OpCode::NT(1), OpCode::T(0)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(1)], &[OpCode::Exit(2)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener8]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::{hashmap, s};
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // A -> a (b <L>)* c
        //
        //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
        //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | b A_1
        //  2: A_1 -> ε     | ◄2            |
        //
        // NT flags:
        //  - A: parent_+_or_* (2048)
        //  - A_1: child_+_or_* | L-form (129)
        // parents:
        //  - A_1 -> A

        #[derive(Debug)]
        pub enum Ctx {
            A(SynA)
        }

        #[derive(Debug)]
        pub enum CtxA {
            /// Factor `A -> a (b)* c`
            A { a: String, a_star: SynAStar, c: String },
        }

        #[derive(Debug)]
        pub enum CtxAStar {
            /// Iteration of `(b)*`
            AStar { a_star: SynAStar, b: String },
        }

        // SynA, SynAStar: defined by user below

        #[derive(Debug)]
        enum SynValue { A(SynA), AStar(SynAStar) }

        impl SynValue {
            fn get_a(self) -> SynA {
                if let SynValue::A(val) = self { val } else { panic!() }
            }
            fn get_a_star(self) -> SynAStar {
                if let SynValue::AStar(val) = self { val } else { panic!() }
            }
        }

        pub trait StarListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn init_a_iter(&mut self) -> SynAStar;
            fn iter_a(&mut self, _ctx: CtxAStar) -> SynAStar;
            fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StarListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StarListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),
                            1 => self.init_a_1(),
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_a(),             //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                            1 => self.exit_a_1(),           //  1: A_1 -> b A_1 | ●A_1 ◄1 b!    | b A_1
                            2 => {}                         //  2: A_1 -> ε     | ◄2            |
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StarListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A(a));
            }

            fn init_a_1(&mut self) {
                let val = self.listener.init_a_iter();
                self.stack.push(SynValue::AStar(val));
            }

            fn exit_a(&mut self) {
                let c = self.stack_t.pop().unwrap();
                let a_star = self.stack.pop().unwrap().get_a_star();
                let a = self.stack_t.pop().unwrap();
                let val = self.listener.exit_a(CtxA::A { a, a_star, c });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_1(&mut self) {
                let a_star = self.stack.pop().unwrap().get_a_star();
                let b = self.stack_t.pop().unwrap();
                let val = self.listener.iter_a(CtxAStar::AStar { a_star, b });
                self.stack.push(SynValue::AStar(val));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug, PartialEq)]
        pub struct SynA { a: String, b: Vec<String>, num_b: u32, c: String }

        #[derive(Debug)]
        pub struct SynAStar(u32);

        struct TestListener {
            acc: Vec<String>,
            result: Option<SynA>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { acc: Vec::new(), result: None, verbose }
            }
        }

        impl StarListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A(a) = ctx;
                self.result = Some(a);
            }


            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn init_a_iter(&mut self) -> SynAStar {
                SynAStar(0)
            }

            fn iter_a(&mut self, ctx: CtxAStar) -> SynAStar {
                let CtxAStar::AStar { mut a_star, b } = ctx;
                a_star.0 += 1;
                self.acc.push(b);
                a_star
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A"); }
                let CtxA::A { a, a_star, c } = ctx;
                let b = std::mem::take(&mut self.acc);
                SynA { a, b, num_b: a_star.0, c }
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a b b b c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![s!("b"), s!("b"), s!("b")], num_b: 3, c: s!("c")}))
                ),
                (
                    "a c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![], num_b: 0, c: s!("c")}))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                }
                // ---------------------------------------------------

                let err_msg = format!("test {test_id} failed for input {input}");
                assert_eq!(success, expected_success, "{err_msg}");
                if success {
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    assert_eq!(listener.result, expected_result, "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener9 {
    // [write_source_code_for_integration_listener9]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 4;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "B", "A_1", "B_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("A_1", 2), ("B_1", 3)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 6] = [(0, &[Symbol::T(0), Symbol::NT(2)]), (1, &[Symbol::T(2), Symbol::NT(3)]), (2, &[Symbol::NT(1), Symbol::T(1), Symbol::NT(2)]), (2, &[Symbol::Empty]), (3, &[Symbol::NT(1)]), (3, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 16] = [0, 6, 6, 6, 6, 6, 1, 6, 6, 6, 2, 3, 6, 5, 4, 6];
    const FLAGS: [u32; 4] = [6656, 4129, 4, 64];
    const PARENT: [Option<VarId>; 4] = [None, Some(0), Some(0), Some(1)];
    const OPCODES: [&[OpCode]; 6] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::T(0)], &[OpCode::NT(3), OpCode::T(2)], &[OpCode::Loop(2), OpCode::Exit(2), OpCode::T(1), OpCode::NT(1)], &[OpCode::Exit(3)], &[OpCode::Loop(1), OpCode::Exit(4)], &[OpCode::Exit(5)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener9]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::{hashmap, s};
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        /// A -> A (c)+ b | a
        //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
        //  1: A_1 -> c A_3     | ►A_3 c!         |
        //  2: A_2 -> A_1 b A_2 | ●A_2 ◄2 b! ►A_1 | A A_1 b
        //  3: A_2 -> ε         | ◄3              |
        //  4: A_3 -> A_1       | ●A_1 ◄4         | A_1 c
        //  5: A_3 -> ε         | ◄5              | A_1 c
        //
        // NT flags:
        //  - A: parent_left_rec | parent_+_or_* | plus (6656)
        //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
        //  - A_2: child_left_rec (4)
        //  - A_3: child_left_fact (64)
        // parents:
        //  - A_1 -> A
        //  - A_2 -> A
        //  - A_3 -> A_1

        #[derive(Debug)]
        pub enum Ctx {
            A { a: SynA }
        }

        #[derive(Debug)]
        pub enum CtxA {
            /// Factor `A -> a` (init)
            A1 { a: String },
            /// Factor `A -> A (c)+ b (iteration)
            A2 { a: SynA, c_plus: Vec<String>, b: String },
            /// Factor `A -> A (c)+ b (final)
            A3 { a: SynA },
        }

        // SynA: defined by user below

        #[derive(Debug)]
        pub struct SynAPlus(Vec<String>);

        #[derive(Debug)]
        enum SynValue { A(SynA), APlus(SynAPlus) }

        impl SynValue {
            fn get_a(self) -> SynA {
                if let SynValue::A(val) = self { val } else { panic!() }
            }
            fn get_a_plus(self) -> SynAPlus {
                if let SynValue::APlus(val) = self { val } else { panic!() }
            }
        }

        pub trait StarListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StarListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StarListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),    //  - A: parent_left_rec | parent_+_or_* | plus (6656)
                            1 => self.init_a_1(),           //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
                            2 => {}                         //  - A_2: child_left_rec (4)
                            3 => {}                         //  - A_3: child_left_fact (64)
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.init_a_2(),   //  0: A -> a A_2       | ►A_2 ◄0 a!      | a
                                                    //  1: A_1 -> c A_3     | ►A_3 c!         |
                            2 => self.exit_a_2(),   //  2: A_2 -> A_1 b A_2 | ●A_2 ◄2 b! ►A_1 | A A_1 b
                            3 => self.exit_a(),     //  3: A_2 -> ε         | ◄3              |
                            4 |                     //  4: A_3 -> A_1       | ●A_1 ◄4         | A_1 c
                            5 => self.exit_a_3(),   //  5: A_3 -> ε         | ◄5              | A_1 c
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StarListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A { a });
            }

            fn init_a_1(&mut self) {
                let a_star = SynAPlus(Vec::new());
                self.stack.push(SynValue::APlus(a_star));
            }

            fn init_a_2(&mut self) {
                let a = self.stack_t.pop().unwrap();
                let val = self.listener.exit_a(CtxA::A1 { a });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                let val = self.listener.exit_a(CtxA::A3 { a });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_2(&mut self) {
                let b = self.stack_t.pop().unwrap();
                let c_plus = self.stack.pop().unwrap().get_a_plus().0;
                let a = self.stack.pop().unwrap().get_a();
                let val = self.listener.exit_a(CtxA::A2 { a, c_plus, b });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_3(&mut self) {
                let c = self.stack_t.pop().unwrap();
                let mut a_plus = self.stack.pop().unwrap().get_a_plus();
                a_plus.0.push(c);
                self.stack.push(SynValue::APlus(a_plus));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug, PartialEq)]
        pub struct SynA(String);

        struct TestListener {
            result: Option<String>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl StarListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A { a } = ctx;
                self.result = Some(a.0);
            }

            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A"); }
                let a = match ctx {
                    CtxA::A1 { a } => a,
                    CtxA::A2 { a, c_plus, b } => a.0 + &c_plus.into_iter().collect::<String>() + &b + ";",
                    CtxA::A3 { a } => a.0,
                };
                SynA(a)
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a c c c b",
                    true,
                    (Some("acccb;"))
                ),
                (
                    "a c c c b c c b",
                    true,
                    (Some("acccb;ccb;"))
                ),
                (
                    "a b",
                    false,
                    (None)
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                let err_msg = format!("test {test_id} failed for input {input}");
                assert_eq!(success, expected_success, "{err_msg}");
                if success {
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    assert_eq!(listener.result, expected_result.map(str::to_string), "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener10 {
    // [write_source_code_for_integration_listener10]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "A_1", "A_2"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("A_1", 1), ("A_2", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 4] = [(0, &[Symbol::T(0), Symbol::NT(1), Symbol::T(2)]), (1, &[Symbol::T(1), Symbol::NT(2)]), (2, &[Symbol::NT(1)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 12] = [0, 4, 4, 4, 4, 1, 4, 4, 4, 2, 3, 4];
    const FLAGS: [u32; 3] = [6144, 4129, 64];
    const PARENT: [Option<VarId>; 3] = [None, Some(0), Some(1)];
    const OPCODES: [&[OpCode]; 4] = [&[OpCode::Exit(0), OpCode::T(2), OpCode::NT(1), OpCode::T(0)], &[OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(2)], &[OpCode::Exit(3)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener10]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::{hashmap, s};
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // A -> a (b)+ c
        //
        //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
        //  1: A_1 -> b A_2 | ►A_2 b!       |
        //  2: A_2 -> A_1   | ●A_1 ◄2       | A_1 b
        //  3: A_2 -> ε     | ◄3            | A_1 b
        //
        // NT flags:
        //  - A: parent_+_or_* | plus (6144)
        //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
        //  - A_2: child_left_fact (64)
        // parents:
        //  - A_1 -> A
        //  - A_2 -> A_1

        #[derive(Debug)]
        pub enum Ctx {
            A(SynA)
        }

        #[derive(Debug)]
        pub enum CtxA {
            /// Factor `A -> a (b)+ c`
            A { a: String, b: Vec<String>, c: String },
        }

        // SynA: defined by user below

        #[derive(Debug)]
        struct SynAPlus(Vec<String>);

        #[derive(Debug)]
        enum SynValue { A(SynA), APlus(SynAPlus) }

        impl SynValue {
            fn get_a(self) -> SynA {
                if let SynValue::A(val) = self { val } else { panic!() }
            }
            fn get_a_star(self) -> SynAPlus {
                if let SynValue::APlus(val) = self { val } else { panic!() }
            }
        }

        pub trait StarListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn exit_a(&mut self, ctx: CtxA) -> SynA;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StarListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StarListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),
                            1 => self.init_a_1(),
                            2 => {},
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_a(),             //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                                                            //  1: A_1 -> b A_2 | ►A_2 b!       |
                            2 |                             //  2: A_2 -> A_1   | ●A_1 ◄2       | A_1 b
                            3 => self.exit_a_2(),           //  3: A_2 -> ε     | ◄3            | A_1 b
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StarListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A(a));
            }

            fn init_a_1(&mut self) {
                let a_star = SynAPlus(Vec::new());
                self.stack.push(SynValue::APlus(a_star));
            }

            fn exit_a(&mut self) {
                let c = self.stack_t.pop().unwrap();
                let b = self.stack.pop().unwrap().get_a_star().0;
                let a = self.stack_t.pop().unwrap();
                let val = self.listener.exit_a(CtxA::A { a, b, c });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_2(&mut self) {
                let b = self.stack_t.pop().unwrap();
                let mut a_star = self.stack.pop().unwrap().get_a_star();
                a_star.0.push(b);
                self.stack.push(SynValue::APlus(a_star));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug, PartialEq)]
        pub struct SynA { a: String, b: Vec<String>, c: String }

        struct TestListener {
            result: Option<SynA>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl StarListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A(a) = ctx;
                self.result = Some(a);
            }

            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A"); }
                let CtxA::A { a, b, c } = ctx;
                SynA { a, b, c}
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a b b c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![s!("b"), s!("b")], c: s!("c")}))
                ),
                (
                    "a c",
                    false,
                    (None)
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                let err_msg = format!("test {test_id} failed for input {input}");
                assert_eq!(success, expected_success, "{err_msg}");
                if success {
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    assert_eq!(listener.result, expected_result, "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener11 {
    // [write_source_code_for_integration_listener11]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 4;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "B", "A_1", "A_2"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("A_1", 2), ("A_2", 3)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 5] = [(0, &[Symbol::T(0), Symbol::NT(2), Symbol::T(2)]), (1, &[Symbol::T(1)]), (2, &[Symbol::NT(1), Symbol::NT(3)]), (3, &[Symbol::NT(2)]), (3, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 16] = [0, 5, 5, 5, 5, 1, 5, 5, 5, 2, 5, 5, 5, 3, 4, 5];
    const FLAGS: [u32; 4] = [6144, 0, 4129, 64];
    const PARENT: [Option<VarId>; 4] = [None, None, Some(0), Some(2)];
    const OPCODES: [&[OpCode]; 5] = [&[OpCode::Exit(0), OpCode::T(2), OpCode::NT(2), OpCode::T(0)], &[OpCode::Exit(1), OpCode::T(1)], &[OpCode::NT(3), OpCode::NT(1)], &[OpCode::Loop(2), OpCode::Exit(3)], &[OpCode::Exit(4)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener11]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::{hashmap, s};
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // A -> a (B)+ c
        // B -> b
        //
        //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
        //  1: B -> b       | ◄1 b!         | b
        //  2: A_1 -> B A_2 | ►A_2 ►B       |
        //  3: A_2 -> A_1   | ●A_1 ◄3       | B A_1
        //  4: A_2 -> ε     | ◄4            | B A_1
        //
        // NT flags:
        //  - A: parent_+_or_* | plus (6144)
        //  - A_1: child_+_or_* | parent_left_fact | plus (4129)
        //  - A_2: child_left_fact (64)
        // parents:
        //  - A_1 -> A
        //  - A_2 -> A_1

        #[derive(Debug)]
        pub enum Ctx {
            A(SynA)
        }

        #[derive(Debug)]
        pub enum CtxA {
            /// Factor `A -> a (B)+ c`
            A { a: String, b: Vec<String>, c: String },
        }
        #[derive(Debug)]
        pub enum CtxB {
            B { b: String },
        }

        // SynA: defined by user below

        #[derive(Debug)]
        struct SynAPlus(Vec<String>);

        #[derive(Debug)]
        enum SynValue { A(SynA), B(SynB), APlus(SynAPlus) }

        impl SynValue {
            fn get_a(self) -> SynA {
                if let SynValue::A(val) = self { val } else { panic!() }
            }
            fn get_b(self) -> SynB {
                if let SynValue::B(val) = self { val } else { panic!() }
            }
            fn get_a_star(self) -> SynAPlus {
                if let SynValue::APlus(val) = self { val } else { panic!() }
            }
        }

        pub trait StarListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn init_b(&mut self) {}
            fn exit_a(&mut self, ctx: CtxA) -> SynA;
            fn exit_b(&mut self, ctx: CtxB) -> SynB;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: StarListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: StarListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),
                            1 => self.listener.init_b(),
                            2 => self.init_a_1(),
                            3 => {},
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => self.exit_a(),     //  0: A -> a A_1 c | ◄0 c! ►A_1 a! | a A_1 c
                            1 => self.exit_b(),     //  1: B -> b       | ◄1 b!         | b
                                                    //  2: A_1 -> B A_2 | ►A_2 ►B       |
                            3 |                     //  3: A_2 -> A_1   | ●A_1 ◄3       | A_1 B
                            4 => self.exit_a_2(),   //  4: A_2 -> ε     | ◄4            | A_1 B
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: StarListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A(a));
            }

            fn init_a_1(&mut self) {
                let a_star = SynAPlus(Vec::new());
                self.stack.push(SynValue::APlus(a_star));
            }

            fn exit_a(&mut self) {
                let c = self.stack_t.pop().unwrap();
                let b = self.stack.pop().unwrap().get_a_star().0;
                let a = self.stack_t.pop().unwrap();
                let val = self.listener.exit_a(CtxA::A { a, b, c });
                self.stack.push(SynValue::A(val));
            }

            fn exit_b(&mut self) {
                let b = self.stack_t.pop().unwrap();
                let val = self.listener.exit_b(CtxB::B { b });
                self.stack.push(SynValue::B(val));
            }

            fn exit_a_2(&mut self) {
                let b = self.stack.pop().unwrap().get_b();
                let mut a_star = self.stack.pop().unwrap().get_a_star();
                a_star.0.push(b.0);
                self.stack.push(SynValue::APlus(a_star));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug, PartialEq)]
        pub struct SynA { a: String, b: Vec<String>, c: String }
        #[derive(Debug)]
        pub struct SynB(String);

        struct TestListener {
            result: Option<SynA>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl StarListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A(a) = ctx;
                self.result = Some(a);
            }

            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn init_b(&mut self) {
                if self.verbose { println!("► B"); }
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A"); }
                let CtxA::A { a, b, c } = ctx;
                SynA { a, b, c}
            }

            fn exit_b(&mut self, ctx: CtxB) -> SynB {
                if self.verbose { println!("◄ B"); }
                let CtxB::B { b } = ctx;
                SynB(b)
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a b b c",
                    true,
                    (Some(SynA { a: s!("a"), b: vec![s!("b"), s!("b")], c: s!("c")}))
                ),
                (
                    "a c",
                    false,
                    (None)
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                let err_msg = format!("test {test_id} failed for input {input}");
                assert_eq!(success, expected_success, "{err_msg}");
                if success {
                    assert!(wrapper.stack.is_empty(), "{err_msg}");
                    assert!(wrapper.stack_t.is_empty(), "{err_msg}");
                    let listener = wrapper.listener();
                    assert_eq!(listener.result, expected_result, "{err_msg}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener12 {
    // [write_source_code_for_integration_listener12]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 4;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [("a", None), ("b", None), ("c", None), ("d", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["A", "A_1", "A_2"];
    const SYMBOLS_NAMES: [(&str, VarId); 2] = [("A_1", 1), ("A_2", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 5] = [(0, &[Symbol::T(1), Symbol::NT(2)]), (1, &[Symbol::T(0), Symbol::NT(1)]), (1, &[Symbol::Empty]), (2, &[Symbol::T(2), Symbol::NT(1)]), (2, &[Symbol::T(3), Symbol::NT(1)])];
    const PARSING_TABLE: [FactorId; 15] = [5, 0, 5, 5, 5, 1, 5, 5, 5, 2, 5, 5, 3, 4, 5];
    const FLAGS: [u32; 3] = [544, 4, 64];
    const PARENT: [Option<VarId>; 3] = [None, Some(0), Some(0)];
    const OPCODES: [&[OpCode]; 5] = [&[OpCode::NT(2), OpCode::T(1)], &[OpCode::Loop(1), OpCode::Exit(1), OpCode::T(0)], &[OpCode::Exit(2)], &[OpCode::NT(1), OpCode::Exit(3), OpCode::T(2)], &[OpCode::NT(1), OpCode::Exit(4), OpCode::T(3)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener12]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // A -> A a | b c | b d
        //
        //  0: A -> b A_2   | ►A_2 b!    |
        //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
        //  2: A_1 -> ε     | ◄2         |
        //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
        //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
        //
        // NT flags:
        //  - A: parent_left_fact | parent_left_rec (544)
        //  - A_1: child_left_rec (4)
        //  - A_2: child_left_fact (64)
        // parents:
        //  - A_1 -> A
        //  - A_2 -> A

        #[derive(Debug)]
        pub enum Ctx { A { a: SynA } }
        #[derive(Debug)]
        pub enum CtxA {
            A1 { a: SynA, a1: String },
            A2 { a: SynA },
            A3 { b: String, c: String },
            A4 { b: String, d: String },
        }

        // User-defined: SynA

        #[derive(Debug)]
        enum SynValue { A(SynA) }

        impl SynValue {
            fn get_a(self) -> SynA {
                let SynValue::A(val) = self;
                val
            }
        }

        pub trait LeftRecListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_a(&mut self) {}
            fn exit_a(&mut self, _ctx: CtxA) -> SynA;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: LeftRecListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: LeftRecListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_a(),    // A
                            1 => {}                         // A_1
                            2 => {}                         // A_2
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 => {}                         //  0: A -> b A_2   | ►A_2 b!    |
                            1 => self.exit_a_1(),           //  1: A_1 -> a A_1 | ●A_1 ◄1 a! | A a
                            2 => self.exit_a(),             //  2: A_1 -> ε     | ◄2         |
                            3 |                             //  3: A_2 -> c A_1 | ►A_1 ◄3 c! | b c
                            4 => self.init_a_1(factor_id),  //  4: A_2 -> d A_1 | ►A_1 ◄4 d! | b d
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: LeftRecListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                self.listener.exit(Ctx::A { a });
            }

            fn exit_a(&mut self) {
                let a = self.stack.pop().unwrap().get_a();
                let val = self.listener.exit_a(CtxA::A2 { a });
                self.stack.push(SynValue::A(val));
            }

            fn exit_a_1(&mut self) {
                let a1 = self.stack_t.pop().unwrap();
                let a = self.stack.pop().unwrap().get_a();
                let val = self.listener.exit_a(CtxA::A1 { a, a1 });
                self.stack.push(SynValue::A(val));
            }

            fn init_a_1(&mut self, factor_id: VarId) {
                let ctx = match factor_id {
                    3 => {
                        let c = self.stack_t.pop().unwrap();
                        let b = self.stack_t.pop().unwrap();
                        CtxA::A3 { b, c }
                    }
                    4 => {
                        let d = self.stack_t.pop().unwrap();
                        let b = self.stack_t.pop().unwrap();
                        CtxA::A4 { b, d }
                    }
                    _ => panic!()
                };
                let val = self.listener.exit_a(ctx);
                self.stack.push(SynValue::A(val));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug)]
        pub enum Bcbd { Bc(String), Bd(String) }

        #[derive(Debug)]
        pub struct SynA {
            choice: Bcbd,
            count_a: u32,
            finished: bool
        }

        struct TestListener {
            result: Option<String>,
            finished: bool,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, finished: false, verbose }
            }
        }

        impl LeftRecListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                let Ctx::A { a } = ctx;
                self.result = Some(match a.choice {
                    Bcbd::Bc(s) | Bcbd::Bd(s) => s
                } + &a.count_a.to_string());
                self.finished = a.finished;
            }

            fn init_a(&mut self) {
                if self.verbose { println!("► A"); }
            }

            fn exit_a(&mut self, ctx: CtxA) -> SynA {
                if self.verbose { println!("◄ A (ctx = {ctx:?})"); }
                match ctx {
                    CtxA::A1 { mut a, .. } => {
                        a.count_a += 1;
                        a
                    }
                    CtxA::A2 { mut a } => {
                        a.finished = true;
                        a
                    }
                    CtxA::A3 { b, c } => SynA { choice: Bcbd::Bc(b + &c), count_a: 0, finished: false },
                    CtxA::A4 { b, d } => SynA { choice: Bcbd::Bd(b + &d), count_a: 0, finished: false }
                }
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "b d a a",
                    true,
                    Some("bd2")
                ),
                (
                    "b c a",
                    true,
                    Some("bc1")
                ),
                (
                    "b c",
                    true,
                    Some("bc0")
                )
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) { (*s, w.to_string()) } else { (Symbol::T(T_ID), w.to_string()) }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let listener = wrapper.listener();
                    let expected_result = expected_result.map(|s| s.to_string());
                    assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
                    assert!(listener.finished, "test {test_id} failed for input {input}");
                }
            }
        }
    }
}

#[allow(unused)]
mod listener13 {
    // [write_source_code_for_integration_listener13]
    // -------------------------------------------------------------------------
    // Automatically generated

    use rlexer::grammar::{ProdFactor, Symbol, VarId, FactorId};
    use rlexer::parser::{OpCode, Parser};
    use rlexer::symbol_table::SymbolTable;

    const PARSER_NUM_T: usize = 3;
    const PARSER_NUM_NT: usize = 3;
    const SYMBOLS_T: [(&str, Option<&str>); PARSER_NUM_T] = [(".", Some(".")), ("id", None), ("num", None)];
    const SYMBOLS_NT: [&str; PARSER_NUM_NT] = ["E", "F", "E_1"];
    const SYMBOLS_NAMES: [(&str, VarId); 1] = [("E_1", 2)];
    const PARSING_FACTORS: [(VarId, &[Symbol]); 5] = [(0, &[Symbol::NT(1), Symbol::NT(2)]), (0, &[Symbol::T(2), Symbol::NT(2)]), (1, &[Symbol::T(1)]), (2, &[Symbol::T(0), Symbol::T(1), Symbol::NT(2)]), (2, &[Symbol::Empty])];
    const PARSING_TABLE: [FactorId; 12] = [5, 0, 1, 5, 5, 2, 5, 5, 3, 5, 5, 4];
    const FLAGS: [u32; 3] = [512, 0, 4];
    const PARENT: [Option<VarId>; 3] = [None, None, Some(0)];
    const OPCODES: [&[OpCode]; 5] = [&[OpCode::NT(2), OpCode::Exit(0), OpCode::NT(1)], &[OpCode::NT(2), OpCode::Exit(1), OpCode::T(2)], &[OpCode::Exit(2), OpCode::T(1)], &[OpCode::Loop(2), OpCode::Exit(3), OpCode::T(1), OpCode::T(0)], &[OpCode::Exit(4)]];
    const START_SYMBOL: VarId = 0;

    pub(super) fn build_parser() -> Parser {
        let mut symbol_table = SymbolTable::new();
        symbol_table.extend_terminals(SYMBOLS_T.into_iter().map(|(s, os)| (s.to_string(), os.map(|s| s.to_string()))));
        symbol_table.extend_non_terminals(SYMBOLS_NT.into_iter().map(|s| s.to_string()));
        symbol_table.extend_names(SYMBOLS_NAMES.into_iter().map(|(s, v)| (s.to_string(), v)));
        let factors: Vec<(VarId, ProdFactor)> = PARSING_FACTORS.into_iter().map(|(v, s)| (v, ProdFactor::new(s.to_vec()))).collect();
        let table: Vec<FactorId> = PARSING_TABLE.into();
        let parsing_table = rlexer::grammar::LLParsingTable {
            num_nt: PARSER_NUM_NT,
            num_t: PARSER_NUM_T + 1,
            factors,
            table,
            flags: FLAGS.into(),
            parent: PARENT.into(),
        };
        Parser::new(parsing_table, symbol_table, OPCODES.into_iter().map(|strip| strip.to_vec()).collect(), START_SYMBOL)
    }

    // -------------------------------------------------------------------------
    // [write_source_code_for_integration_listener13]

    mod test {
        use std::collections::HashMap;
        use rlexer::dfa::TokenId;
        use rlexer::grammar::{Symbol, VarId};
        use rlexer::hashmap;
        use rlexer::parser::{Call, Listener};
        use rlexer::symbol_table::SymbolTable;
        use rlexer::CollectJoin;

        // E -> F | num | E . id
        // F -> id
        //
        //  0: E -> F E_1      | ◄0 ►E_1 ►F    | F
        //  1: E -> num E_1    | ◄1 ►E_1 num!  | num
        //  2: F -> id         | ◄2 id!        | id
        //  3: E_1 -> . id E_1 | ●E_1 ◄3 id! . | E id
        //  4: E_1 -> ε        | ◄4            |
        //
        // NT flags:
        //  - E: parent_left_rec (512)
        //  - E_1: child_left_rec (4)
        // parents:
        //  - E_1 -> E

        #[derive(Debug)]
        pub enum Ctx { E { e: SynE } }
        #[derive(Debug)]
        pub enum CtxE { F { f: SynF }, Num { num: String }, E_Id { e: SynE, id: String }, E { e: SynE } }
        #[derive(Debug)]
        pub enum CtxF { F { id: String } }

        // SynE, SynF: defined by user below

        #[derive(Debug)]
        enum SynValue { E(SynE), F(SynF) }

        impl SynValue {
            fn get_e(self) -> SynE {
                if let SynValue::E(val) = self { val } else { panic!() }
            }
            fn get_f(self) -> SynF {
                if let SynValue::F(val) = self { val } else { panic!() }
            }
        }

        pub trait ExprListener {
            fn exit(&mut self, _ctx: Ctx) {}
            fn init_e(&mut self) {}
            fn init_f(&mut self) {}
            fn exit_e(&mut self, _ctx: CtxE) -> SynE;
            fn exit_f(&mut self, _ctx: CtxF) -> SynF;
        }

        struct ListenerWrapper<T> {
            verbose: bool,
            listener: T,
            stack: Vec<SynValue>,
            max_stack: usize,
            stack_t: Vec<String>,
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            pub fn new(listener: T, verbose: bool) -> Self {
                ListenerWrapper { verbose, listener, stack: Vec::new(), max_stack: 0, stack_t: Vec::new() }
            }

            pub fn listener(self) -> T {
                self.listener
            }
        }

        impl<T: ExprListener> Listener for ListenerWrapper<T> {
            fn switch(&mut self, call: Call, nt: VarId, factor_id: VarId, t_data: Option<Vec<String>>) {
                if let Some(mut t_data) = t_data {
                    self.stack_t.append(&mut t_data);
                }
                match call {
                    Call::Enter => {
                        match nt {
                            0 => self.listener.init_e(),    // E
                            1 => self.listener.init_f(),    // F
                            2 => {}                         // E_1
                            _ => panic!("unexpected exit non-terminal id: {nt}")
                        }
                    }
                    Call::Loop => {}
                    Call::Exit => {
                        match factor_id {
                            0 |                             //  0: E -> F E_1      | ◄0 ►E_1 ►F    | F
                            1 => self.init_e_1(factor_id),  //  1: E -> num E_1    | ◄1 ►E_1 num!  | num
                            2 => self.exit_f(),             //  2: F -> id         | ◄2 id!        | id
                            3 => self.exit_e_1(),           //  3: E_1 -> . id E_1 | ●E_1 ◄3 id! . | E id
                            4 => self.exit_e(),             //  4: E_1 -> ε        | ◄4            |
                            _ => panic!("unexpected exit factor id: {factor_id}")
                        }
                    }
                    Call::End => {
                        self.exit();
                    }
                }
                self.max_stack = std::cmp::max(self.max_stack, self.stack.len());
                // self.max_asm_stack = std::cmp::max(self.max_asm_stack, self.asm_stack.len());
                if self.verbose {
                    println!("> stack_t:   {}", self.stack_t.join(", "));
                    println!("> stack:     {}", self.stack.iter().map(|it| format!("{it:?}")).join(", "));
                }
            }
        }

        impl<T: ExprListener> ListenerWrapper<T> {
            fn exit(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                self.listener.exit(Ctx::E { e });
            }

            fn init_e_1(&mut self, factor_id: VarId) {
                let ctx = match factor_id {
                    0 => {
                        let f = self.stack.pop().unwrap().get_f();
                        CtxE::F { f }
                    }
                    1 => {
                        let num = self.stack_t.pop().unwrap();
                        CtxE::Num { num }
                    }
                    _ => panic!("unexpected factor id: {factor_id}")
                };
                let val = self.listener.exit_e(ctx);
                self.stack.push(SynValue::E(val));
            }

            fn exit_f(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let val = self.listener.exit_f(CtxF::F { id });
                self.stack.push(SynValue::F(val));
            }

            fn exit_e_1(&mut self) {
                let id = self.stack_t.pop().unwrap();
                let e = self.stack.pop().unwrap().get_e();
                let val = self.listener.exit_e(CtxE::E_Id { e, id });
                self.stack.push(SynValue::E(val));
            }

            fn exit_e(&mut self) {
                let e = self.stack.pop().unwrap().get_e();
                let val = self.listener.exit_e(CtxE::E { e });
                self.stack.push(SynValue::E(val));
            }
        }

        // User code -----------------------------------------------------

        #[derive(Debug)]
        pub enum SynE {
            Tmp(Vec<String>),
            Final(String)
        }

        #[derive(Debug)]
        pub struct SynF(String);

        struct TestListener {
            result: Option<String>,
            verbose: bool,
        }

        impl TestListener {
            pub fn new(verbose: bool) -> Self {
                Self { result: None, verbose }
            }
        }

        impl ExprListener for TestListener {
            fn exit(&mut self, ctx: Ctx) {
                if self.verbose { println!("◄ (ctx = {ctx:?})"); }
                if let Ctx::E { e: SynE::Final(e) } = ctx {
                    self.result = Some(e);
                } else {
                    panic!("unexpected final context {ctx:?}");
                }
            }

            fn init_e(&mut self) {
                if self.verbose { println!("► E"); }
            }

            fn init_f(&mut self) {
                if self.verbose { println!("► F"); }
            }

            fn exit_e(&mut self, ctx: CtxE) -> SynE {
                if self.verbose { println!("◄ E (ctx = {ctx:?})"); }
                match ctx {
                    CtxE::E_Id { e: SynE::Tmp(mut e), id } => {
                        e.push(id);
                        SynE::Tmp(e)
                    },
                    CtxE::F { f } => {
                        SynE::Tmp(vec![f.0])
                    }
                    CtxE::Num { num } => {
                        SynE::Tmp(vec![format!("[{num}]")])
                    }
                    CtxE::E { e: SynE::Tmp(e) } => {
                        SynE::Final(e.join("/"))
                    }
                    _ => panic!("unexpected context {ctx:?}")
                }
            }

            fn exit_f(&mut self, ctx: CtxF) -> SynF {
                if self.verbose { println!("◄ list (ctx = {ctx:?})"); }
                let CtxF::F { id } = ctx;
                SynF(id)
            }
        }

        #[test]
        fn parser_parse_stream() {
            let tests = vec![
                (
                    "a . b . c . d",
                    true,
                    (Some("a/b/c/d"))
                ),
                (
                    "10 . b . c . d",
                    true,
                    (Some("[10]/b/c/d"))
                ),
                (
                    "a",
                    true,
                    (Some("a"))
                ),
            ];
            const VERBOSE: bool = false;
            const VERBOSE_LISTENER: bool = false;
            const T_ID: VarId = 1;
            const T_NUM: VarId = 2;

            let mut parser = super::build_parser();

            // The lexer provides the required stream, so this isn't necessary in a real case:
            let mut symb_table = SymbolTable::new();
            symb_table.extend_terminals(super::SYMBOLS_T.iter().map(|(s, ss)| (s.to_string(), ss.map(|s| s.to_string()))));
            let symbols = (0..super::SYMBOLS_T.len() as TokenId)
                .map(|t| Symbol::T(t))
                .map(|s| (s.to_str(Some(&symb_table)), s))
                .collect::<HashMap<_, _>>();
            for (test_id, (input, expected_success, expected_result)) in tests.into_iter().enumerate() {
                if VERBOSE { println!("{:=<80}\ninput '{input}'", ""); }
                let stream = input.split_ascii_whitespace().map(|w| {
                    if let Some(s) = symbols.get(w) {
                        (*s, w.to_string())
                    } else {
                        if w.chars().next().unwrap().is_digit(10) {
                            (Symbol::T(T_NUM), w.to_string())
                        } else {
                            (Symbol::T(T_ID), w.to_string())
                        }
                    }
                });

                // User code under test ------------------------------

                let listener = TestListener::new(VERBOSE_LISTENER);
                let mut wrapper = ListenerWrapper::new(listener, VERBOSE_LISTENER);
                let success = match parser.parse_stream(&mut wrapper, stream) {
                    Ok(_) => {
                        if VERBOSE { println!("parsing completed successfully"); }
                        true
                    }
                    Err(e) => {
                        if VERBOSE { println!("parsing failed: {e}"); }
                        false
                    }
                };
                if VERBOSE {
                    println!("max stack: {}", wrapper.max_stack);
                    println!("wrapper stack: {:?}", wrapper.stack);
                    // println!("listener asm_stack: {:?}", wrapper.asm_stack);
                }
                // ---------------------------------------------------

                assert_eq!(success, expected_success, "test {test_id} failed for input {input}");
                if success {
                    let listener = wrapper.listener();
                    let expected_result = expected_result.map(|s| s.to_string());
                    assert_eq!(listener.result, expected_result, "test {test_id} failed for input {input}");
                }
            }
        }
    }
}
